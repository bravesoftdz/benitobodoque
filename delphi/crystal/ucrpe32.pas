(*
UCRPE32.PAS
Seagate Crystal Reports VCL Component - Main Unit
=================================================
Author   : Frank Zimmerman
Date     : October 1999
Version  : 7.x.0.51
Purpose  : This is the main unit file of the Crystal Reports
           Delphi VCL Component.
Supports : Delphi 2, 3 and 4 / C++ Builder 1,3 and 4
History  : Initial Version November, 1995 Created by John B. Murphy
Copyright (c) 1995, 1996 Crystal Services
Copyright (c) 1997, 1998, 1999 Seagate Software, Inc.
*)

unit UCrpe32;

{$I UCRPEDEF.INC}

interface

uses
  Windows, Classes, Controls, Forms, SysUtils, ExtCtrls,
  StdCtrls, Graphics, CRDynamic, UCrpeUtl;

{C++ Builder 3}
{$IFDEF CR_B3UP}
  {$ObjExportAll On}
{$ENDIF CR_B3UP}

const
{------------------------------------------------------------------------------}
{ AboutBox Constants                                                           }
{------------------------------------------------------------------------------}
  TCRPE_PRODUCT_NAME             = 'Seagate Crystal Reports ';
  {$IFDEF CR_DELPHI2}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for Delphi 2 ';
  TCRPE_VERSION                  = '7.2.0.51 ';
  {$ENDIF CR_DELPHI2}
  {$IFDEF CR_BUILDER1}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for C++ Builder 1 ';
  TCRPE_VERSION                  = '7.1.0.51 ';
  {$ENDIF CR_BUILDER1}
  {$IFDEF CR_DELPHI3}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for Delphi 3 ';
  TCRPE_VERSION                  = '7.3.0.51 ';
  {$ENDIF CR_DELPHI3}
  {$IFDEF CR_BUILDER3}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for C++ Builder 3 ';
  TCRPE_VERSION                  = '7.3.0.51 ';
  {$ENDIF CR_BUILDER3}
  {$IFDEF CR_DELPHI4}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for Delphi 4 ';
  TCRPE_VERSION                  = '7.4.0.51 ';
  {$ENDIF CR_DELPHI4}
  {$IFDEF CR_BUILDER4}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for C++ Builder 4 ';
  TCRPE_VERSION                  = '7.4.0.51 ';
  {$ENDIF CR_BUILDER4}
  {$IFDEF CR_DELPHI5}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for Delphi 5 ';
  TCRPE_VERSION                  = '7.5.0.51 ';
  {$ENDIF CR_DELPHI5}
  {$IFDEF CR_UNKNOWN}
  TCRPE_PRODUCT_NAME2            = 'VCL Component for Delphi X ';
  TCRPE_VERSION                  = '7.X.0.51 ';
  {$ENDIF CR_UNKNOWN}
  TCRPE_COMPANY_NAME             = 'Seagate Software, Inc. ';
  TCRPE_COMPANY_ADDRESS1         = '840 Cambie Street ';
  TCRPE_COMPANY_ADDRESS2         = 'Vancouver, B.C.  Canada   V6B 4J2 ';
  TCRPE_INFORMATION_SALES        = 'For Product and Sales Information: ';
  TCRPE_SALES_NUM                = '(604) 681-3435 ';
  TCRPE_INFORMATION_TECH         = 'For Seagate Software Technical Support: ';
  TCRPE_PHONE                    = 'Phone ';
  TCRPE_PHONE_NUM                = '(604) 669-8379 ';
  TCRPE_FAX                      = 'Fax ';
  TCRPE_FAX_NUM                  = '(604) 681-7163 ';
  TCRPE_EMAIL                    = 'Email ';
  TCRPE_EMAIL_ADDRESS            = 'answers@seagatesoftware.com ';
  TCRPE_WEBACD                   = 'Web Support ';
  TCRPE_WEBACD_ADDRESS           = 'http://community.seagatesoftware.com ';
  TCRPE_WEBSITE                  = 'Web Site ';
  TCRPE_WEBSITE_ADDRESS          = 'http://www.seagatesoftware.com ';
  TCRPE_COPYRIGHT                = 'Copyright (c)1999 ';

  {For SectionFormat - BackgroundColor}
  clUnchangedColor  = PE_UNCHANGED_COLOR;  {-2}
  {EmptyString}
  CrEmptyStr        = 'emptystr';
  CrwNull           = 'emptystr';

type
  {AboutBox}
  TCrAboutBox = string;
  {General}
  TCrState  = (crsSetup, crsInit);
  TCrBoolean = (cFalse, cTrue, cDefault);
  TCrReportName = string; {255}
  TCrDesignControls = string;
  {Output}
  TCrOutput = (toWindow, toPrinter, toExport);
  {TCrOutput = (toWindow, toPrinter, toExport, toFax);}
  {Error}
  TCrError = (errVCL, errEngine);
  TCrErrorOption = (errNoOption, errFormula, errPaging, errCancelDialog,
    errFormatFormulaName, errLinkedParameter);
  {Events}
  TCrpeCancelEvent = procedure(Sender: TObject; var Cancel: Boolean) of object;
  TCrpeJobNumEvent = procedure(Sender: TObject; const JobNum: Word) of object;
  TCrpePrinterEvent = procedure(Sender: TObject; var PDMode: PDevMode; var Cancel: Boolean) of object;
  TCrpeVersionEvent = procedure(Sender: TObject; var Major, Minor : integer) of object;
  TCrpeErrorEvent = procedure(Sender: TObject; const ErrorNum: smallint;
     const ErrorString: string; var IgnoreError: TCrBoolean) of object;
  {ReportOptions}
  TCrDateTimeType = (dtConvertToString, dtConvertToDate,
    dtKeepAsDateTime, dtDefault);
  {SummaryInfo}
  TCrSummaryString = string; {128}
  {Margins}
  TCrMarginTwips = -2..PE_SM_DEFAULT;
  {Log}
  TCrpeLog = TComponent;
  {Subreport}
  TCrSubreportName = string; {128}
  {Connect}
  TCrConnectMethod = (useConnect, useLogOnInfo);
  {Table}
  TCrLogOnInfoTable = integer;
  TCrTableNumber = integer;
  TCrTableType = (ttUnknown, ttStandard, ttSQL, ttStoredProcedure);
  {SessionInfo}
  TCrSessionInfoTable = integer;

  {Printer}
  TCrPrinterName = string; {80}
  TCrPreserveRptSet = (prOrientation, prPaperSize, prPaperSource);
  TCrPreserveRptSettings = set of TCrPreserveRptSet;
  TCrOrientation = (orDefault, orPortrait, orLandscape);
  {PrinterDevice: copied from Delphi's Printers.pas}
  TCrPrinterDevice = class
    Driver, Device, Port: string;
  end;
  {PrintOptions}
  TCrCollation = (Uncollated, Collated, DefaultCollation);
  TCrPrintFileName = string; {limited to 512 characters}

  {Export}
  TCrExportAppName = string;
  TCrExportFileName = string; {255}
  TCrExportDestination = (toFile, toEmailViaMapi, toEmailViaVIM,
   toEmailViaSMI, toMSExchange, toLotusNotes, toApplication);
  TCrExportType = (Records, TabSeparated, Ascii, Dif, Csv, CharacterSeparated,
   TabSeparatedText, CrystalReportRPT, LotusWK1, LotusWK3, LotusWKS, RTF,
   WordForWindows, ExcelXLS, HTML30, HTML32ext, HTML32std, ODBCTable,
   PaginatedText, ReportDefinition);
  TCrExportExcelType = (Excel2, Excel3, Excel4, Excel5, Excel5Extended,
    Excel7, Excel7Tab, Excel8, Excel8Tab);
  TCrColumnWidth = (ByArea, ByConstant);

  {SortFields}
  TCrSortFieldsNumber = integer;
  TCrSortDirection = (sdDescending, sdAscending, sdDefault);
  {GroupSortFields}
  TCrGroupSortFieldsNumber = integer;

  {Groups}
  TCrGroupConditionNumber = integer;
  TCrGroupOptionsNumber = integer;
  TCrGroupCondition = (AnyChange, dateDaily, dateWeekly, dateBiWeekly,
    dateSemiMonthly, dateMonthly, dateQuarterly, dateSemiAnnually,
    dateAnnually, boolToYes, boolToNo, boolEveryYes, boolEveryNo,
    boolNextIsYes, boolNextIsNo, timeBySecond, timeByMinute,
    timeByHour, timeByAMPM);
  TCrGroupDirection = (gdDescending, gdAscending, gdOriginal,
    gdSpecified, gdDefault);
  TCrGroupType = (gtOther, gtDate, gtBoolean, gtTime);
  TCrTopNOptions = (tnUnsorted, tnSorted, tnTopN, tnBottomN, tnDefault);

  {Formulas}
  TCrFormulaName = string;
  {SQL Expressions}
  TCrExpressionName = string;
  {Stored Proc Params}
  TCrStoredProcParamName = string; {128}
  TCrStoredProcParamType = (spLongVarChar, spBinary, spVarBinary,
    spLongVarBinary, spBigInt, spTinyInt, spBit, spChar, spNumeric,
    spDecimal, spInteger, spSmallInt, spFloat, spReal, spDouble,
    spDate, spTime, spTimeStamp, spVarChar);

  {Sections/Areas}
  {AreaFormat}
  TCrAreaFormatFormulasSection = string;
  TCrAreaFormatSection = string;
  {SectionFormat}
  TCrSectionFormatSection = string;
  TCrSectionFormatFormulasSection = string;
  {SectionHeight}
  TCrSectionHeightSection = string;
  {SectionFont}
  TCrSectionFontSection = string;
  TCrFontScope = (fsFields, fsText, fsBoth);
  TCrFontFamily = (ffDefault, ffRoman, ffSwiss, ffModern,
     ffScript,ffDecorative);
  TCrFontCharSet = (fcAnsi, fcDefault, fcSymbol, fcShiftJis,
    fcHangeul, fcChineseBig5, fcOEM);
  TCrFontWeight = (fwDefault, fwThin, fwExtraLight, fwLight, fwNormal,
    fwMedium, fwSemiBold, fwBold, fwExtraBold, fwHeavy);

  {ParamFields}
  TCrParamFieldType = (pfNumber, pfCurrency, pfBoolean, pfDate,
    pfString, pfDateTime, pfTime, pfInteger, pfColor, pfChar,
    pfLong, pfNoValue);
  TCrParamInfoValueType = (vtRanges, vtDiscrete);
  TCrRangeBounds = (IncludeStartAndEnd, IncludeStartOnly,
    IncludeEndOnly, ExcludeStartAndEnd);
  TCrRangeNumber = integer;
  TCrParamFieldName       = string; {255}
  TCrParamFieldReportName = string; {128}
  TCrParamFieldSource = (psReport, psStoredProc, psQuery);
  TCrPickListSortMethod = (psmNoSort, psmAlphaNumericAscending,
    psmAlphaNumericDescending, psmNumericAscending, psmNumericDescending,
    psmDefaultSort);

  {WindowParent}
  TCrWinControl = TWinControl;
  {WindowZoom}
  TCrZoomPreview = (pwNormal, pwPageWidth, pwWholePage, pwDefault);
  TCrZoomMagnification = -1..400;  {-1 is default;
   0,1,2 are ZoomPreview constants; 3..24 are not valid, 25..400 are valid}
  {WindowStyle}
  TCrFormBorderStyle = bsNone..bsDialog;
  {WindowCursor}
  TCrWindowCursor = (wcDefault, wcArrow, wcCross, wcIBeam, wcUpArrow,
   wcSizeAll, wcSizeNWSE, wcSizeNESW, wcSizeWE, wcSizeNS, wcNo,
   wcWait, wcAppStart, wcHelp, wcMagnify);

  {Graphs}
  {GraphType}
  TCrGraphTypeNumber = integer;
  TCrGraphType = (
    {Bar: 0..5}
    barSideBySide, barStacked, barPercent, bar3DSideBySide, bar3DStacked,
    bar3DPercent,
    {Line: 6..11}
    lineRegular, lineStacked, linePercent, lineWithMarkers,
    lineStackedWithMarkers, linePercentWithMarkers,
    {Area: 12..17}
    areaAbsolute, areaStacked, areaPercent, area3DAbsolute, area3DStacked,
    area3DPercent,
    {Pie: 18..21}
    pieRegular, pie3DRegular, pieMultiple, pieMultiProp,
    {Doughnut: 22..24}
    doughnutRegular, doughnutMultiple, doughnutMultiProp,
    {3D Riser: 25..28}
    ThreeDRegular, ThreeDPyramid, ThreeDOctagon, ThreeDCutCorners,
    {3D Surface: 29..31}
    ThreeDSurfaceRegular, ThreeDSurfaceWithSides, ThreeDSurfaceHoneyComb,
    {XYScatter: 32..35}
    XYScatter, XYScatterDualAxis, XYScatterLabeled, XYScatterDualAxisLabeled,
    {Radar: 36..38}
    radarRegular, radarStacked, radarDualAxis,
    {Bubble: 39,40}
    bubbleRegular, bubbleDualAxis,
    {StockHiLo: 41..46}
    stockHiLo, stockHiLoDualAxis, stockHiLoOpen, stockHiLoOpenDualAxis,
    stockHiLoOpenClose, stockHiLoOpenCloseDualAxis,
    {User Defined: 47}
    userDefinedGraph,
    {Unknown: 48..59}
    unknownBar, unknownLine, unknownArea, unknownPie, unknownDoughnut,
    unknown3DRiser, unknown3DSurface, unknownXYScatter, unknownRadar,
    unknownBubble, unknownStockHiLo, unknownGraphType);
  {GraphData}
  TCrGraphDataNumber = integer;
  TCrGraphDirection = (Rows, Cols, RowCol, ColRow, Unknown);
  {GraphText}
  TCrGraphTextNumber = integer;
  TCrGraphTextType = string; {128 max in length}
  {Graph Axis}
  TCrGraphAxisNumber = integer;
  TCrGraphGridLines = (gglDefault, gglNone, gglMinor, gglMajor,
    gglMajorAndMinor);
  TCrGraphDVType = (gdvDefault, gdvAutomatic, gdvManual);
  {GraphOptions}
  TCrGraphOptionsNumber = integer;
  TCrGraphBarDirection = (bdHorizontal, bdVertical, bdDefault);
  {GraphOptionInfo}
  TCrGraphOptionInfoNumber = integer;
  TCrGraphColor  = (gcDefault, gcColor, gcMonochrome);
  TCrGraphLegend = (glDefault, glNone, glUpperRight, glBottomCenter,
   glTopCenter, glRight, glLeft);
  TCrGraphPieSize = (gpsDefault, gpsMinimum, gpsSmall, gpsAverage,
   gpsLarge, gpsMaximum);
  TCrGraphPieSlice = (gslDefault, gslNone, gslSmall, gslLarge);
  TCrGraphBarSize = (gbsDefault, gbsMinimum, gbsSmall, gbsAverage,
   gbsLarge, gbsMaximum);
  TCrGraphMarkerSize = (gmsDefault, gmsSmall, gmsMediumSmall, gmsMedium,
   gmsMediumLarge, gmsLarge);
  TCrGraphMarkerShape = (gshDefault, gshRectangle, gshCircle, gshDiamond,
   gshTriangle);
  TCrGraphDataPoints = (gdpDefault, gdpNone, gdpShowLabel, gdpShowValue);
  TCrGraphNumberFormat = (gnfDefault, gnfNoDecimal, gnfOneDecimal,
   gnfTwoDecimal, gnfCurrencyNoDecimal, gnfCurrencyTwoDecimal,
   gnfPercentNoDecimal, gnfPercentOneDecimal, gnfPercentTwoDecimal);
  TCrGraphViewingAngle = (gvaDefault, gvaStandard, gvaTall, gvaTop,
   gvaDistorted, gvaShort, gvaGroupEye, gvaGroupEmphasis, gvaFewSeries,
   gvaFewGroups, gvaDistortedStd, gvaThickGroups, gvaShorter,
   gvaThickSeries, gvaThickStd, gvaBirdsEye, gvaMax);

{Property editors removed here...}

{------------------------------------------------------------------------------}
{ Window Event Types                                                           }
{------------------------------------------------------------------------------}
  TCrStartEventDestination = (seNoWhere, seToWindow, seToPrinter,
    seToExport, seFromQuery);
  TCrStopEventJobStatus = (seUndefined, seNotStarted, seInProgress,
    seCompleted, seFailed, seCancelled, seHalted);
  TCrDrillDownType = (ddOnGroup, ddOnGroupTree, ddOnGraph,
    ddOnMap, ddOnSubreport);
  TCrpeGeneralPrintWindowEvent = procedure(WindowHandle: HWnd;
    var Cancel: Boolean) of object;
  TCrpeZoomLevelChangingEvent = procedure(WindowHandle: HWnd;
    ZoomLevel: Word; var Cancel: Boolean) of object;
  TCrpeCloseButtonClickedEvent = procedure(WindowHandle: HWnd;
    ViewIndex: Word; var Cancel: Boolean) of object;
  TCrpeSearchButtonClickedEvent = procedure(WindowHandle: HWnd;
    SearchString: string; var Cancel: Boolean) of object;
  TCrpeGroupTreeButtonClickedEvent = procedure(WindowHandle: HWnd;
    Visible: boolean; var Cancel: Boolean) of object;
  TCrpeReadingRecordsEvent = procedure(Cancelled: boolean;
    RecordsRead: LongInt; RecordsSelected: LongInt; Done: boolean;
    var Cancel: Boolean) of object;
  TCrpeStartEvent = procedure(Destination: TCrStartEventDestination;
    var Cancel: Boolean) of object;
  TCrpeStopEvent = procedure(Destination:  TCrStartEventDestination;
    JobStatus: TCrStopEventJobStatus; var Cancel: Boolean) of object;
  TCrpeShowGroupEvent = procedure(WindowHandle: HWnd; NGroupLevel: Word;
    GroupList: TStringList; var Cancel: Boolean) of object;
  TCrpeDrillOnGroupEvent = procedure(WindowHandle: HWnd; NGroupLevel: Word;
    DrillType: TCrDrillDownType; GroupList: TStringList; var Cancel: Boolean) of object;
  TCrpeDrillOnDetailEvent = procedure(WindowHandle: HWnd; NSelectedField: smallint;
    NFields: smallint; FieldNames: TStringList; FieldValues: TStringList;
    var Cancel: Boolean) of object;

{------------------------------------------------------------------------------}
{ Class ECrpeError                                                             }
{------------------------------------------------------------------------------}
   ECrpeError = class(Exception)
     ErrorNo : Integer;
     constructor Create(const nNo: Integer; const sMsg: string);
   end;

{------------------------------------------------------------------------------}
{ Class TCrFieldMappingInfo                                                    }
{------------------------------------------------------------------------------}
  TCrFieldMappingType = (fmAuto, fmPrompt, fmEvent);
  TCrFieldValueType = (fvUnknown, fvInt8s, fvInt8u, fvInt16s,
    fvInt16u, fvInt32s, fvInt32u, fvNumber, fvCurrency,
    fvBoolean, fvDate, fvTime, fvString, fvTransientMemo,
    fvPersistentMemo, fvBlob, fvDateTime, fvBitmap, fvIcon,
    fvPicture, fvOle, fvGraph);

  TCrFieldMappingInfo = class(TPersistent)
  private
    FTableName : string;
    FFieldName : string;
    FFieldType : TCrFieldValueType;
    FMapTo     : integer;
  public
    property TableName : string
        read FTableName
       write FTableName;
    property FieldName : string
        read FFieldName
       write FFieldName;
    property FieldType : TCrFieldValueType
        read FFieldType
       write FFieldType;
    property MapTo : integer
        read FMapTo
       write FMapTo;
  end;
  TCrpeFieldMappingEvent = procedure(var ReportFields: TList;
    var DatabaseFields: TList; var Cancel: Boolean) of object;

{------------------------------------------------------------------------------}
{ Mouse Click Event Types                                                      }
{------------------------------------------------------------------------------}
  TCrMouseClickAction = (mbNotSupported, mbDown, mbUp, mbDoubleClick);
  TCrMouseClickType = (mcNone, mcLeft, mcRight, mcMiddle);

  TCrMouseInfo = record
    Action     : TCrMouseClickAction;
    Button     : TCrMouseClickType;
    ShiftKey   : Boolean;
    ControlKey : Boolean;
    x,y        : integer;
  end;

  TCrpeMouseClickEvent = procedure(WindowHandle: HWnd;
    MouseInfo: TCrMouseInfo; FieldValue: string;
    FieldType: TCrParamFieldType; Section: string;
    ObjectHandle: Hwnd; var Cancel: Boolean) of object;

{------------------------------------------------------------------------------}
{ Class TCrpeString                                                            }
{  Same as a regular TStringList, except Put() defers to Add()                 }
{  if index is larger than size.                                               }
{------------------------------------------------------------------------------}
   TCrpeString = class(TStringList)
   protected
     procedure Put(Index: Integer; const S: string); override;
   end; { Class TCrpeString Declaration }

{------------------------------------------------------------------------------}
{ Sub-Class forward definitions                                                }
{------------------------------------------------------------------------------}
  TCrpeAreaFormat = class;
  TCrpeAreaFormatFormulas = class;
  TCrpeConnect = class;
  TCrpeExport = class;
  TCrpeExportEmail = class;
  TCrpeExportExcel = class;
  TCrpeExportExchange = class;
  TCrpeExportLotusNotes = class;
  TCrpeExportODBC = class;
  TCrpeFormulas = class;
  TCrpeGraphAxis = class;
  TCrpeGraphData = class;
  TCrpeGraphOptionInfo = class;
  TCrpeGraphOptions = class;
  TCrpeGraphText = class;
  TCrpeGraphType = class;
  TCrpeGroupCondition = class;
  TCrpeGroupOptions = class;
  TCrpeGroupSelection = class;
  TCrpeGroupSortFields = class;
  TCrpeLogOnInfo = class;
  TCrpeLogOnServer = class;
  TCrpeMargins = class;
  TCrpePages = class;
  TCrpeParamFields = class;
  TCrpePrintDate = class;
  TCrpePrinter = class;
  TCrpePrintOptions = class;
  TCrpeRecords = class;
  TCrpeReportOptions = class;
  TCrpeSectionFont = class;
  TCrpeSectionFormat = class;
  TCrpeSectionFormatFormulas = class;
  TCrpeSectionHeight = class;
  TCrpeSelection = class;
  TCrpeSessionInfo = class;
  TCrpeSortFields = class;
  TCrpeSQL = class;
  TCrpeSQLExpressions = class;
  TCrpeStoredProcParams = class;
  TCrpeSubreports = class;
  TCrpeSubreportsItem = class;
  TCrpeSummaryInfo = class;
  TCrpeTables = class;
  TCrpeVersion = class;
  TCrpeWindowButtonBar = class;
  TCrpeWindowCursor = class;
  TCrpeWindowSize = class;
  TCrpeWindowStyle = class;
  TCrpeWindowZoom = class;
  {TCrpeFax = class;}

  
{******************************************************************************}
{ TCrpe Class                                                                  }
{------------------------------------------------------------------------------}
{ The Delphi component to encapsulate the interface to the Print Engine.       }
{******************************************************************************}
  TCrpe = class(TComponent)
  private
    {Index variable for Subreports Item}
    FIndex            : integer;
    FPrintJob         : Smallint;
    {General}
    hDLL              : THandle; {Handle for CRPE32.DLL}
    FAbout            : TCrAboutBox;
    FCanCloseEngine   : boolean;
    FConnectMethod    : TCrConnectMethod;
    FCrpePath         : string;
    FCrpeState        : TCrState;
    FDesignControls   : TCrDesignControls;
    FDiscardSavedData : boolean;
    FEngineOpened     : boolean;
    FHasSavedData     : boolean;
    FIsJobFinished    : boolean;
    FLoadEngineOnUse  : boolean;
    FLog              : TCrpeLog;
    {FMultiThread      : boolean;}
    FOutput           : TCrOutput;
    FPrintEnded       : boolean;
    FProgressDialog   : boolean;
    FReportName       : TCrReportName;
    FSendOnExecute    : boolean;

    {Error}
    FLastErrorNumber  : smallint;
    FLastErrorString  : string;

    {Events}
    FOnJobOpened       : TCrpeJobNumEvent;
    FOnExecuteBegin    : TCrpeCancelEvent;
    FOnExecuteDoneSend : TCrpeCancelEvent;
    FOnCreate          : TNotifyEvent;
    FOnExecuteEnd      : TNotifyEvent;
    FOnWindowClose     : TNotifyEvent;
    FOnPrintEnded      : TNotifyEvent;
    FOnPrinterSend     : TCrpePrinterEvent;
    FOnGetVersion      : TCrpeVersionEvent;
    FOnError           : TCrpeErrorEvent;
    FOnFieldMapping    : TCrpeFieldMappingEvent;

    {WindowEvents}
    FWindowEvents            : boolean;
    FwOnCloseWindow          : TCrpeGeneralPrintWindowEvent;
    FwOnPrintBtnClick        : TCrpeGeneralPrintWindowEvent;
    FwOnExportBtnClick       : TCrpeGeneralPrintWindowEvent;
    FwOnFirstPageBtnClick    : TCrpeGeneralPrintWindowEvent;
    FwOnPreviousPageBtnClick : TCrpeGeneralPrintWindowEvent;
    FwOnNextPageBtnClick     : TCrpeGeneralPrintWindowEvent;
    FwOnLastPageBtnClick     : TCrpeGeneralPrintWindowEvent;
    FwOnCancelBtnClick       : TCrpeGeneralPrintWindowEvent;
    FwOnActivateWindow       : TCrpeGeneralPrintWindowEvent;
    FwOnDeActivateWindow     : TCrpeGeneralPrintWindowEvent;
    FwOnPrintSetupBtnClick   : TCrpeGeneralPrintWindowEvent;
    FwOnRefreshBtnClick      : TCrpeGeneralPrintWindowEvent;
    FwOnZoomLevelChange      : TCrpeZoomLevelChangingEvent;
    FwOnCloseBtnClick        : TCrpeCloseButtonClickedEvent;
    FwOnSearchBtnClick       : TCrpeSearchButtonClickedEvent;
    FwOnGroupTreeBtnClick    : TCrpeGroupTreeButtonClickedEvent;
    FwOnReadingRecords       : TCrpeReadingRecordsEvent;
    FwOnStartEvent           : TCrpeStartEvent;
    FwOnStopEvent            : TCrpeStopEvent;
    FwOnShowGroup            : TCrpeShowGroupEvent;
    FwOnDrillGroup           : TCrpeDrillOnGroupEvent;
    FwOnDrillDetail          : TCrpeDrillOnDetailEvent;
    FwOnMouseClick           : TCrpeMouseClickEvent;

    {Export}
    FExport         : TCrpeExport;
    FExportOpt      : PEExportOptions;
    {UXF}
    UXFDif          : UXFDifOptions;
    UXFRec          : UXFRecordStyleOptions;
    UXFCsv          : UXFCommaTabSeparatedOptions;
    UXFCharSep      : UXFCharSeparatedOptions;
    UXFHTML         : UXFHTML3Options;
    UXFODBC         : UXFODBCOptions;
    UXFPagText      : UXFPaginatedTextOptions;
    UXFXls          : UXFXlsOptions;
    {UXD}
    UXDDisk         : UXDDiskOptions;
    UXDMapi         : UXDMapiOptions;
    UXDVIM          : UXDVIMOptions;
    UXDSMI          : UXDSMIOptions;
    UXDExch         : UXDPostFolderOptions;
    UXDNotes        : UXDNotesOptions;
    UXDApp          : UXDApplicationOptions;
    pFormat, pDisk  : Pointer;

    FVersion           : TCrpeVersion;
    FPrintDate         : TCrpePrintDate;
    FSubreports        : TCrpeSubreports;
    FLogOnServer       : TCrpeLogOnServer;
    FRecords           : TCrpeRecords;
    FPages             : TCrpePages;
    {Printer}
    FPrinter           : TCrpePrinter;
    FPrintOptions      : TCrpePrintOptions;
    {FFax              : TCrpeFax;}
    FSummaryInfo       : TCrpeSummaryInfo;
    FReportOptions     : TCrpeReportOptions;

    {Window Handles}
    FParentFormHandle  : hWnd;
    FDialogParent      : TCrWinControl;
    FWindowParent      : TCrWinControl;
    {Window classes}
    FWindowButtonBar   : TCrpeWindowButtonBar;
    FWindowCursor      : TCrpeWindowCursor;
    FWindowSize        : TCrpeWindowSize;
    FWindowState       : TWindowState;
    FWindowStyle       : TCrpeWindowStyle;
    FWindowZoom        : TCrpeWindowZoom;
  protected
    {General}
    procedure SetDLLHandle;
    procedure SetAbout (const Value: TCrAboutBox);
    procedure SetDesignControls (const Value: TCrDesignControls);
    function  GetHasSavedData : boolean;
    function  GetDiscardSavedData : boolean;
    procedure SetDiscardSavedData(const Value: boolean);
    function  GetDetailCopies: Smallint;
    procedure SetDetailCopies(const Value: Smallint);
    function  GetLog : TCrpeLog;
    procedure SetLog (const Value: TCrpeLog);
    function  GetMargins : TCrpeMargins;
    procedure SetMargins(const Value: TCrpeMargins);
    function  GetOutput : TCrOutput;
    procedure SetOutput(const Value: TCrOutput);
    function  GetPrintDate : TCrpePrintDate;
    procedure SetPrintDate(const Value: TCrpePrintDate);
    function  GetProgressDialog : boolean;
    procedure SetProgressDialog(const Value: boolean);
    function  GetReportName: TCrReportName;
    procedure SetReportName(NewName: TCrReportName);
    function  GetReportTitle: string;
    procedure SetReportTitle(const Value: string);
    function  GetSendOnExecute : boolean;
    procedure SetSendOnExecute(const Value: boolean);
    function  GetVersion : TCrpeVersion;
    procedure SetVersion(const Value: TCrpeVersion);
    function  GetFieldMapping : TCrFieldMappingType;
    procedure SetFieldMapping(const Value: TCrFieldMappingType);
    {Engine}
    procedure Loaded; override;
    procedure GetCRPEVersion;
    function  OpenPrintEngine : boolean;
    procedure ClosePrintEngine;
    function  OpenPrintJob : boolean;
    procedure ClosePrintJob;
    function  GetJobNumber : Smallint;
    function  GetLoadEngineOnUse : boolean;
    procedure SetLoadEngineOnUse(const Value: boolean);
    (*function  GetMultiThread : boolean;
    procedure SetMultiThread(const Value: boolean);*)

    {Subreports}
    function  GetSubreports : TCrpeSubreports;
    procedure SetSubreports (const Value: TCrpeSubreports);
    {Window}
    function  GetPrintEnded : Boolean;
    function  GetWindowParent : TCrWinControl;
    procedure SetWindowParent (const Value: TCrWinControl);
    function  GetDialogParent : TCrWinControl;
    procedure SetDialogParent (const Value : TCrWinControl);
    function  PreviewWindowStyle : integer;
    function  GetWindowZoom : TCrpeWindowZoom;
    procedure SetWindowZoom (const Value: TCrpeWindowZoom);
    function  GetWindowStyle : TCrpeWindowStyle;
    procedure SetWindowStyle (const Value: TCrpeWindowStyle);
    function  GetWindowState : TWindowState;
    procedure SetWindowState (const Value : TWindowState);
    function  GetWindowSize : TCrpeWindowSize;
    procedure SetWindowSize (const Value: TCrpeWindowSize);
    function  GetWindowButtonBar : TCrpeWindowButtonBar;
    procedure SetWindowButtonBar(const Value: TCrpeWindowButtonBar);
    function  GetWindowCursor : TCrpeWindowCursor;
    procedure SetWindowCursor (const Value: TCrpeWindowCursor);
    {Pages}
    function  GetPages : TCrpePages;
    procedure SetPages(const Value: TCrpePages);
    {Records}
    function  GetRecords : TCrpeRecords;
    procedure SetRecords(const Value: TCrpeRecords);
    {Tables}
    function  GetTables : TCrpeTables;
    procedure SetTables(const Value: TCrpeTables);
    {Sorting}
    function  GetSortFields : TCrpeSortFields;
    procedure SetSortFields(const Value : TCrpeSortFields);
    function  GetGroupSortFields : TCrpeGroupSortFields;
    procedure SetGroupSortFields(const Value : TCrpeGroupSortFields);
    function  GetGroupCondition : TCrpeGroupCondition;
    procedure SetGroupCondition(const Value : TCrpeGroupCondition);
    function  GetGroupOptions : TCrpeGroupOptions;
    procedure SetGroupOptions(const Value : TCrpeGroupOptions);
    {Formulas}
    function  GetFormulas : TCrpeFormulas;
    procedure SetFormulas(const Value: TCrpeFormulas);
    {Selection}
    function  GetSelection : TCrpeSelection;
    procedure SetSelection (Value : TCrpeSelection);
    function  GetGroupSelection : TCrpeGroupSelection;
    procedure SetGroupSelection(Value : TCrpeGroupSelection);
    {ParamFields}
    function  GetParamField : TCrpeParamFields;
    procedure SetParamField(const Value: TCrpeParamFields);
    {SQL}
    function  GetConnectMethod : TCrConnectMethod;
    procedure SetConnectMethod(const Value: TCrConnectMethod);
    function  GetConnect : TCrpeConnect;
    procedure SetConnect(const Value: TCrpeConnect);
    function  GetLogOnInfo : TCrpeLogonInfo;
    procedure SetLogOnInfo(const Value : TCrpeLogonInfo);
    function  GetLogOnServer : TCrpeLogOnServer;
    procedure SetLogOnServer (const Value: TCrpeLogOnServer);
    function  GetSQL : TCrpeSQL;
    procedure SetSQL (const Value: TCrpeSQL);
    {Section}
    function  GetSectionFormat : TCrpeSectionFormat;
    procedure SetSectionFormat(const Value : TCrpeSectionFormat);
    function  GetSectionFormatFormulas : TCrpeSectionFormatFormulas;
    procedure SetSectionFormatFormulas(const Value : TCrpeSectionFormatFormulas);
    function  GetAreaFormat : TCrpeAreaFormat;
    procedure SetAreaFormat(const Value : TCrpeAreaFormat);
    function  GetAreaFormatFormulas : TCrpeAreaFormatFormulas;
    procedure SetAreaFormatFormulas (const Value : TCrpeAreaFormatFormulas);
    function  GetSectionFont : TCrpeSectionFont;
    procedure SetSectionFont(const Value : TCrpeSectionFont);
    function  GetSectionHeight : TCrpeSectionHeight;
    procedure SetSectionHeight(const Value : TCrpeSectionHeight);
    function  GetSectionCodes(var slNCodes: TStringList; var slSCodes: TStringList;
      var nSections: smallint; bArea: boolean): boolean;
    {Graph}
    function  GetGraphType : TCrpeGraphType;
    procedure SetGraphType(const Value : TCrpeGraphType);
    function  GetGraphText : TCrpeGraphText;
    procedure SetGraphText(const Value : TCrpeGraphText);
    function  GetGraphOptions : TCrpeGraphOptions;
    procedure SetGraphOptions(const Value : TCrpeGraphOptions);
    function  GetGraphOptionInfo : TCrpeGraphOptionInfo;
    procedure SetGraphOptionInfo(const Value : TCrpeGraphOptionInfo);
    function  GetGraphData : TCrpeGraphData;
    procedure SetGraphData(const Value : TCrpeGraphData);
    function  GetGraphAxis : TCrpeGraphAxis;
    procedure SetGraphAxis(const Value : TCrpeGraphAxis);
    {SummaryInfo}
    function  GetSummaryInfo : TCrpeSummaryInfo;
    procedure SetSummaryInfo(const Value : TCrpeSummaryInfo);
    {ReportOptions}
    function  GetReportOptions : TCrpeReportOptions;
    procedure SetReportOptions(const Value : TCrpeReportOptions);
    {Export}
    function  GetExport : TCrpeExport;
    procedure SetExport(const Value: TCrpeExport);
    {Printer}
    function  GetCrpePrinter : TCrpePrinter;
    procedure SetCrpePrinter(const Value: TCrpePrinter);
    function  GetPrintOptions : TCrpePrintOptions;
    procedure SetPrintOptions(const Value: TCrpePrintOptions);
    {Fax}
    {function  GetFax : TCrpeFax;
    procedure SetFax(const Value: TCrpeFax);}
    {MS Access Session}
    function  GetSessionInfo : TCrpeSessionInfo;
    procedure SetSessionInfo(const Value : TCrpeSessionInfo);
    {Status}
    function  GetStatus : integer;
    function  GetCanCloseEngine : boolean;
    function  GetIsJobFinished  : boolean;
    {Events}
    function  GetOnCreate: TNotifyEvent;
    procedure SetOnCreate(const Value: TNotifyEvent);
    function  GetOnJobOpened: TCrpeJobNumEvent;
    procedure SetOnJobOpened(const Value: TCrpeJobNumEvent);
    function  GetOnError : TCrpeErrorEvent;
    procedure SetOnError (const Value : TCrpeErrorEvent);
    function  GetLastErrorNumber : integer;
    procedure SetLastErrorNumber(const Value: integer);
    function  GetLastErrorString : string;
    procedure SetLastErrorString(const Value: string);
    function  GetOnExecuteBegin : TCrpeCancelEvent;
    procedure SetOnExecuteBegin(const Value: TCrpeCancelEvent);
    function  GetOnExecuteDoneSend : TCrpeCancelEvent;
    procedure SetOnExecuteDoneSend(const Value: TCrpeCancelEvent);
    function  GetOnExecuteEnd : TNotifyEvent;
    procedure SetOnExecuteEnd(const Value: TNotifyEvent);
    function  GetOnWindowClose : TNotifyEvent;
    procedure SetOnWindowClose(const Value: TNotifyEvent);
    function  GetOnPrintEnded : TNotifyEvent;
    procedure SetOnPrintEnded(const Value: TNotifyEvent);
    function  GetOnPrinterSend : TCrpePrinterEvent;
    procedure SetOnPrinterSend(const Value: TCrpePrinterEvent);
    function  GetOnGetVersion : TCrpeVersionEvent;
    procedure SetOnGetVersion(const Value: TCrpeVersionEvent);
    {WindowEvents}
    function  GetWindowEvents : boolean;
    procedure SetWindowEvents (const Value: boolean);
    function  GetwOnCloseWindow : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnCloseWindow (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnPrintBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnPrintBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnExportBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnExportBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnFirstPageBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnFirstPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnPreviousPageBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnPreviousPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnNextPageBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnNextPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnLastPageBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnLastPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnCancelBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnCancelBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnActivateWindow : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnActivateWindow (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnDeActivateWindow : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnDeActivateWindow (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnPrintSetupBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnPrintSetupBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnRefreshBtnClick : TCrpeGeneralPrintWindowEvent;
    procedure SetwOnRefreshBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
    function  GetwOnZoomLevelChange : TCrpeZoomLevelChangingEvent;
    procedure SetwOnZoomLevelChange (const Value: TCrpeZoomLevelChangingEvent);
    function  GetwOnCloseBtnClick : TCrpeCloseButtonClickedEvent;
    procedure SetwOnCloseBtnClick (const Value: TCrpeCloseButtonClickedEvent);
    function  GetwOnSearchBtnClick : TCrpeSearchButtonClickedEvent;
    procedure SetwOnSearchBtnClick (const Value: TCrpeSearchButtonClickedEvent);
    function  GetwOnGroupTreeBtnClick : TCrpeGroupTreeButtonClickedEvent;
    procedure SetwOnGroupTreeBtnClick (const Value: TCrpeGroupTreeButtonClickedEvent);
    function  GetwOnReadingRecords : TCrpeReadingRecordsEvent;
    procedure SetwOnReadingRecords (const Value: TCrpeReadingRecordsEvent);
    function  GetwOnStartEvent : TCrpeStartEvent;
    procedure SetwOnStartEvent (const Value: TCrpeStartEvent);
    function  GetwOnStopEvent : TCrpeStopEvent;
    procedure SetwOnStopEvent (const Value: TCrpeStopEvent);
    function  GetwOnShowGroup : TCrpeShowGroupEvent;
    procedure SetwOnShowGroup (const Value: TCrpeShowGroupEvent);
    function  GetwOnDrillGroup : TCrpeDrillOnGroupEvent;
    procedure SetwOnDrillGroup (const Value: TCrpeDrillOnGroupEvent);
    function  GetwOnDrillDetail : TCrpeDrillOnDetailEvent;
    procedure SetwOnDrillDetail (const Value: TCrpeDrillOnDetailEvent);
    function  GetOnFieldMapping : TCrpeFieldMappingEvent;
    procedure SetOnFieldMapping (const Value: TCrpeFieldMappingEvent);
    function  GetwOnMouseClick : TCrpeMouseClickEvent;
    procedure SetwOnMouseClick (const Value: TCrpeMouseClickEvent);

    function  SubItem : TCrpeSubreportsItem;
    {Log functions}
    procedure LogEvent(VCLCallStr: string; JobNum: smallint;
      param1: Pointer; param2: Pointer; param3: Pointer; param4: Pointer;
      param5: Pointer; param6: Pointer; param7: Pointer; param8: Pointer;
      param9: Pointer; param10: Pointer; param11: Pointer);
    procedure LogResult(VCLCallStr: string; boolResult: Bool; intResult: Smallint);
    {Errors}
    function  GetErrorMsg(const nJob: Word; const Option: TCrErrorOption;
      const ErrType: TCrError; const ErrConst: string; const ErrString: string): TCrBoolean;

  {These properties appear on the Object Inspector}
  published
    {General}
    property About : TCrAboutBox
        read FAbout
       write SetAbout;
    property DesignControls : TCrDesignControls
        read FDesignControls
       write SetDesignControls;
    property Log : TCrpeLog
        read GetLog
       write SetLog;
    property Version : TCrpeVersion
        read GetVersion
       write SetVersion;

    (*property MultiThread : boolean
        read GetMultiThread
       write SetMultiThread
     default False;*)

    property ReportName : TCrReportName
        read GetReportName
       write SetReportName;
    property CrpePath : string
        read FCrpePath
       write FCrpePath;
    property Output : TCrOutput
        read GetOutput
       write SetOutput
     default toWindow;
    property ReportTitle : string
        read GetReportTitle
       write SetReportTitle;
    property DetailCopies : Smallint
        read GetDetailCopies
       write SetDetailCopies
     default 1;
    property Margins : TCrpeMargins
        read GetMargins
       write SetMargins;
    property DiscardSavedData : Boolean
        read GetDiscardSavedData
       write SetDiscardSavedData
     default False;
    property SendOnExecute : Boolean
        read GetSendOnExecute
       write SetSendOnExecute
     default True;
    property ProgressDialog : boolean
        read GetProgressDialog
       write SetProgressDialog
     default True;
    property LoadEngineOnUse : boolean
        read GetLoadEngineOnUse
       write SetLoadEngineOnUse
     default False;
    property FieldMapping : TCrFieldMappingType
        read GetFieldMapping
       write SetFieldMapping
     default fmAuto;

    {Events}
    property OnCreate : TNotifyEvent
        read GetOnCreate
       write SetOnCreate;
    property OnExecuteBegin : TCrpeCancelEvent
        read GetOnExecuteBegin
       write SetOnExecuteBegin;
    property OnJobOpened : TCrpeJobNumEvent
        read GetOnJobOpened
       write SetOnJobOpened;
    property OnExecuteDoneSend : TCrpeCancelEvent
        read GetOnExecuteDoneSend
       write SetOnExecuteDoneSend;
    property OnExecuteEnd : TNotifyEvent
        read GetOnExecuteEnd
       write SetOnExecuteEnd;
    property OnWindowClose : TNotifyEvent
        read GetOnWindowClose
       write SetOnWindowClose;
    property OnPrintEnded: TNotifyEvent
        read GetOnPrintEnded
       write SetOnPrintEnded;
    property OnPrinterSend: TCrpePrinterEvent
        read GetOnPrinterSend
       write SetOnPrinterSend;
    property OnGetVersion: TCrpeVersionEvent
        read GetOnGetVersion
       write SetOnGetVersion;
    property OnError: TCrpeErrorEvent
        read GetOnError
       write SetOnError;

    {WindowEvents}
    property WindowEvents: boolean
        read GetWindowEvents
       write SetWindowEvents
     default False;
    property wOnCloseWindow : TCrpeGeneralPrintWindowEvent
        read GetwOnCloseWindow
       write SetwOnCloseWindow;
    property wOnPrintBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnPrintBtnClick
       write SetwOnPrintBtnClick;
    property wOnExportBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnExportBtnClick
       write SetwOnExportBtnClick;
    property wOnFirstPageBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnFirstPageBtnClick
       write SetwOnFirstPageBtnClick;
    property wOnPreviousPageBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnPreviousPageBtnClick
       write SetwOnPreviousPageBtnClick;
    property wOnNextPageBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnNextPageBtnClick
       write SetwOnNextPageBtnClick;
    property wOnLastPageBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnLastPageBtnClick
       write SetwOnLastPageBtnClick;
    property wOnCancelBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnCancelBtnClick
       write SetwOnCancelBtnClick;
    property wOnActivateWindow : TCrpeGeneralPrintWindowEvent
        read GetwOnActivateWindow
       write SetwOnActivateWindow;
    property wOnDeActivateWindow : TCrpeGeneralPrintWindowEvent
        read GetwOnDeActivateWindow
       write SetwOnDeActivateWindow;
    property wOnPrintSetupBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnPrintSetupBtnClick
       write SetwOnPrintSetupBtnClick;
    property wOnRefreshBtnClick : TCrpeGeneralPrintWindowEvent
        read GetwOnRefreshBtnClick
       write SetwOnRefreshBtnClick;
    property wOnZoomLevelChange : TCrpeZoomLevelChangingEvent
        read GetwOnZoomLevelChange
       write SetwOnZoomLevelChange;
    property wOnCloseBtnClick : TCrpeCloseButtonClickedEvent
        read GetwOnCloseBtnClick
       write SetwOnCloseBtnClick;
    property wOnSearchBtnClick : TCrpeSearchButtonClickedEvent
        read GetwOnSearchBtnClick
       write SetwOnSearchBtnClick;
    property wOnGroupTreeBtnClick : TCrpeGroupTreeButtonClickedEvent
        read GetwOnGroupTreeBtnClick
       write SetwOnGroupTreeBtnClick;
    property wOnReadingRecords : TCrpeReadingRecordsEvent
        read GetwOnReadingRecords
       write SetwOnReadingRecords;
    property wOnStartEvent : TCrpeStartEvent
        read GetwOnStartEvent
       write SetwOnStartEvent;
    property wOnStopEvent : TCrpeStopEvent
        read GetwOnStopEvent
       write SetwOnStopEvent;
    property wOnShowGroup : TCrpeShowGroupEvent
        read GetwOnShowGroup
       write SetwOnShowGroup;
    property wOnDrillGroup : TCrpeDrillOnGroupEvent
        read GetwOnDrillGroup
       write SetwOnDrillGroup;
    property wOnDrillDetail : TCrpeDrillOnDetailEvent
        read GetwOnDrillDetail
       write SetwOnDrillDetail;
    property OnFieldMapping : TCrpeFieldMappingEvent
        read GetOnFieldMapping
       write SetOnFieldMapping;
    property wOnMouseClick : TCrpeMouseClickEvent
        read GetwOnMouseClick
       write SetwOnMouseClick;

    {PrintDate}
    property PrintDate : TCrpePrintDate
        read GetPrintDate
       write SetPrintDate;

    {Subreports}
    property Subreports : TCrpeSubreports
        read GetSubreports
       write SetSubreports;

    {Tables}
    property Tables : TCrpeTables
        read GetTables
       write SetTables;

    {Sorting}
    property SortFields : TCrpeSortFields
        read GetSortFields
       write SetSortFields;
    property GroupSortFields : TCrpeGroupSortFields
        read GetGroupSortFields
       write SetGroupSortFields;
    property GroupCondition : TCrpeGroupCondition
        read GetGroupCondition
       write SetGroupCondition;
    property GroupOptions : TCrpeGroupOptions
        read GetGroupOptions
       write SetGroupOptions;

    {Formulas}
    property ParamFields : TCrpeParamFields
        read GetParamField
       write SetParamField;
    property Formulas : TCrpeFormulas
        read GetFormulas
       write SetFormulas;
    property GroupSelection : TCrpeGroupSelection
        read GetGroupSelection
       write SetGroupSelection;
    property Selection : TCrpeSelection
        read GetSelection
       write SetSelection;

    {Sections}
    property SectionFormat : TCrpeSectionFormat
        read GetSectionFormat
       write SetSectionFormat;
    property SectionFormatFormulas : TCrpeSectionFormatFormulas
        read GetSectionFormatFormulas
       write SetSectionFormatFormulas;
    property AreaFormat : TCrpeAreaFormat
        read GetAreaFormat
       write SetAreaFormat;
    property AreaFormatFormulas : TCrpeAreaFormatFormulas
        read GetAreaFormatFormulas
       write SetAreaFormatFormulas;
    property SectionFont : TCrpeSectionFont
        read GetSectionFont
       write SetSectionFont;
    property SectionHeight : TCrpeSectionHeight
        read GetSectionHeight
       write SetSectionHeight;

    {SQL}
    property ConnectMethod : TCrConnectMethod
        read GetConnectMethod
       write SetConnectMethod
     default useConnect;
    property Connect : TCrpeConnect
        read GetConnect
       write SetConnect;
    property SQL : TCrpeSQL
        read GetSQL
       write SetSQL;
    property LogOnInfo : TCrpeLogonInfo
        read GetLogOnInfo
       write SetLogOnInfo;
    property LogOnServer : TCrpeLogOnServer
        read GetLogOnServer
       write SetLogOnServer;

    {MSAccess SessionInfo}
    property SessionInfo : TCrpeSessionInfo
        read GetSessionInfo
       write SetSessionInfo;

    {Export}
    property Export : TCrpeExport
        read GetExport
       write SetExport;

    {Printer}
    property Printer : TCrpePrinter
        read GetCrpePrinter
       write SetCrpePrinter;
    property PrintOptions : TCrpePrintOptions
        read GetPrintOptions
       write SetPrintOptions;

    {Fax}
    {property Fax : TCrpeFax
        read GetFax
       write SetFax;}

    {WindowZoom}
    property WindowZoom : TCrpeWindowZoom
        read GetWindowZoom
       write SetWindowZoom;
    {Window Style}
    property WindowStyle : TCrpeWindowStyle
        read GetWindowStyle
       write SetWindowStyle;
    {Window State}
    property WindowState : TWindowState
        read GetWindowState
       write SetWindowState
     default wsNormal;
    {Window Size}
    property WindowSize : TCrpeWindowSize
        read GetWindowSize
       write SetWindowSize;
    {Window Buttons}
    property WindowButtonBar : TCrpeWindowButtonBar
        read GetWindowButtonBar
       write SetWindowButtonBar;
    {Window Cursor}
    property WindowCursor : TCrpeWindowCursor
        read GetWindowCursor
       write SetWindowCursor;
    {Window Parent}
    property WindowParent: TCrWinControl
        read GetWindowParent
       write SetWindowParent;
    {DialogParent}
    property DialogParent: TCrWinControl
        read GetDialogParent
       write SetDialogParent;

    {Graphs}
    property GraphType : TCrpeGraphType
        read GetGraphType
       write SetGraphType;
    property GraphText : TCrpeGraphText
        read GetGraphText
       write SetGraphText;
    property GraphOptions : TCrpeGraphOptions
        read GetGraphOptions
       write SetGraphOptions;
    property GraphOptionInfo : TCrpeGraphOptionInfo
        read GetGraphOptionInfo
       write SetGraphOptionInfo;
    property GraphData : TCrpeGraphData
        read GetGraphData
       write SetGraphData;
    property GraphAxis : TCrpeGraphAxis
        read GetGraphAxis
       write SetGraphAxis;

    {SummaryInfo}
    property SummaryInfo : TCrpeSummaryInfo
        read GetSummaryInfo
       write SetSummaryInfo;
    {ReportOptions}
    property ReportOptions : TCrpeReportOptions
        read GetReportOptions
       write SetReportOptions;

  {These properties are runtime only; ie. not on the Object Inspector}
  public
    {General}
    property JobNumber: Smallint
        read GetJobNumber;
    property HasSavedData : boolean
        read GetHasSavedData
     default False;
    property CanCloseEngine : boolean
        read GetCanCloseEngine
     default True;
    property IsJobFinished : boolean
        read GetIsJobFinished
     default True;
    function  VerifyDatabase : boolean;
    {Error}
    property LastErrorNumber: Integer
        read GetLastErrorNumber
       write SetLastErrorNumber
     default 0;
    property LastErrorString: string
        read GetLastErrorString
       write SetLastErrorString;
    {Status}
    property Status: integer
        read GetStatus;
    {Pages}
    property Pages : TCrpePages
        read GetPages
       write SetPages;
    {Print}
    property PrintEnded: Boolean
        read GetPrintEnded;
    {Records}
    property Records : TCrpeRecords
        read GetRecords
       write SetRecords;
   {SQL}
   function  LogOnPrivateInfo(DllName: string; PrivateInfo: pointer): boolean;
   {Window}
   function  Focused: Boolean;
   procedure SetFocus;
   function  ReportWindowHandle: HWnd;
   procedure CloseWindow;
   procedure PrintWindow;
   procedure ExportWindow(const bMail: Boolean);
   procedure HideWindow;
   procedure ShowWindow;
   procedure RetrieveWindowState;
   {Retrieve procedures}
   function  RetrieveReportTitle : boolean;
   function  RetrieveDetailCopies : boolean;
   function  RetrieveFieldMapping : boolean;
   {Send procedures}
   function  SendDetailCopies : boolean;
   function  SendDialogParent : boolean;
   function  SendOutput : boolean;
   function  SendProgressDialog : boolean;
   function  SendReportTitle : boolean;
   function  SendFieldMapping : boolean;
   {General}
   function  OpenEngine: boolean;
   procedure CloseEngine;
   function  OpenJob: boolean;
   procedure CloseJob;
   procedure CancelJob;
   function  Execute : boolean;
   function  DiscardData : boolean;
   procedure Clear;
   procedure CopyFrom(Source: TCrpe);
   {Constructor/Destructor}
   constructor Create(AOwner: TComponent); override;
   destructor Destroy; override;
  end; { Class TCrpe Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeVersion                                                           }
{------------------------------------------------------------------------------}
   TCrpeVersion = class(TPersistent)
   private
      FDLL         : string;
      FEngine      : string;
      FFileVersion : string;
      FWindows     : string;
      FMajor       : integer;
      FMinor       : integer;
   protected
      function  GetDLL : string;
      procedure SetDLL(const Value : string);
      function  GetEngine : string;
      procedure SetEngine(const Value : string);
      function  GetFileVersion : string;
      procedure SetFileVersion(const Value : string);
      function  GetWindows : string;
      procedure SetWindows(const Value : string);
      function  GetMajor : integer;
      procedure SetMajor(const Value : integer);
      function  GetMinor : integer;
      procedure SetMinor(const Value : integer);
   published
      property DLL : string
          read GetDLL
         write SetDLL;
      property Engine : string
          read GetEngine
         write SetEngine;
      property FileVersion : string
          read GetFileVersion
         write SetFileVersion;
      property Windows : string
          read GetWindows
         write SetWindows;
      property Major : integer
          read GetMajor
         write SetMajor;
      property Minor : integer
          read GetMinor
         write SetMinor;
   public
     Cr : TCrpe;
     procedure Clear;
     function  Retrieve: boolean;
     procedure CopyFrom (Source: TCrpeVersion);
     constructor Create;
   end; { Class TCrpeVersion Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowSize                                                        }
{------------------------------------------------------------------------------}
   TCrpeWindowSize = class(TPersistent)
   private
      FTop     : smallint;
      FLeft    : smallint;
      FWidth   : smallint;
      FHeight  : smallint;
   protected
      function  GetLeft : smallint;
      procedure SetLeft(const Value : smallint);
      function  GetTop : smallint;
      procedure SetTop(const Value : smallint);
      function  GetWidth : smallint;
      procedure SetWidth(const Value : smallint);
      function  GetHeight : smallint;
      procedure SetHeight(const Value : smallint);
   published
      property Left : smallint
          read GetLeft
         write SetLeft
       default -1;
      property Top : smallint
          read GetTop
         write SetTop
       default -1;
      property Width : smallint
          read GetWidth
         write SetWidth
       default -1;
      property Height : smallint
          read GetHeight
         write SetHeight
       default -1;
   public
     Cr : TCrpe;
     procedure Clear;
     function  Retrieve : boolean;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeWindowSize);
     constructor Create;
   end; { Class TCrpeWindowSize Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowZoom                                                        }
{------------------------------------------------------------------------------}
   TCrpeWindowZoom = class(TPersistent)
   private
      {TZoomPreview = (pwNormal, pwPageWidth, pwWholePage, pwDefault)}
      {TZoomMagnification = -1..400;  -1 or 3..24 means default}
      FPreview       : TCrZoomPreview;
      FMagnification : TCrZoomMagnification;
   protected
      function  GetPreview : TCrZoomPreview;
      procedure SetPreview(const Value: TCrZoomPreview);
      function  GetMagnification : TCrZoomMagnification;
      procedure SetMagnification(const Value: TCrZoomMagnification);
   published
      property Preview : TCrZoomPreview
          read GetPreview
         write SetPreview
       default pwDefault;
      property Magnification : TCrZoomMagnification
          read GetMagnification
         write SetMagnification
       default 0;
   public
     Cr : TCrpe;
     procedure NextLevel;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeWindowZoom);
     constructor Create;
   end; { Class TCrpeWindowZoom Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowStyle                                                       }
{------------------------------------------------------------------------------}
   TCrpeWindowStyle = class(TPersistent)
   private
      FTitle       : string;
      FSystemMenu  : boolean;
      FMaxButton   : boolean;
      FMinButton   : boolean;
      FBorderStyle : TCrFormBorderStyle;
      FDisabled    : boolean;
      FMDIForm     : TForm;
   protected
      function  GetTitle : string;
      procedure SetTitle(const Value: string);
      function  GetSystemMenu : boolean;
      procedure SetSystemMenu(const Value: boolean);
      function  GetMaxButton : boolean;
      procedure SetMaxButton(const Value: boolean);
      function  GetMinButton : boolean;
      procedure SetMinButton(const Value: boolean);
      function  GetBorderStyle : TCrFormBorderStyle;
      procedure SetBorderStyle(const Value: TCrFormBorderStyle);
      function  GetDisabled : boolean;
      procedure SetDisabled(const Value: boolean);
      procedure OnMDIResize(Sender: TObject);
      procedure OnMDIClose(Sender: TObject; var Action: TCloseAction);
   published
      property Title : string
          read GetTitle
         write SetTitle;
      property SystemMenu : Boolean
          read GetSystemMenu
         write SetSystemMenu
       default True;
      property MaxButton : Boolean
          read GetMaxButton
         write SetMaxButton
       default True;
      property MinButton : Boolean
          read GetMinButton
         write SetMinButton
       default True;
      property BorderStyle : TCrFormBorderStyle
          read GetBorderStyle
         write SetBorderStyle
       default bsSizeable;
      property Disabled : Boolean
          read GetDisabled
         write SetDisabled
       default False;
   public
     Cr : TCrpe;
     procedure Clear;
     procedure CopyFrom (Source: TCrpeWindowStyle);
     constructor Create;
   end; { Class TCrpeWindowStyle Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowButtonBar                                                   }
{------------------------------------------------------------------------------}
   TCrpeWindowButtonBar = class(TPersistent)
   private
      FVisible        : boolean;
      FAllowDrillDown : boolean;
      FCancelBtn      : boolean;
      FCloseBtn       : boolean;
      FExportBtn      : boolean;
      FGroupTree      : boolean;
      FNavigationCtls : boolean;
      FPrintBtn       : boolean;
      FPrintSetupBtn  : boolean;
      FProgressCtls   : boolean;
      FRefreshBtn     : boolean;
      FSearchBtn      : boolean;
      FZoomCtl        : boolean;
      FToolbarTips    : boolean;
      FDocumentTips   : boolean;
   protected
      procedure SetVisible(const Value: boolean);
   published
      property Visible : boolean
          read FVisible
         write SetVisible
       default True;
      property AllowDrillDown : boolean
          read FAllowDrillDown
         write FAllowDrillDown
       default False;
      property CancelBtn : Boolean
          read FCancelBtn
         write FCancelBtn
       default False;
      property CloseBtn : Boolean
          read FCloseBtn
         write FCloseBtn
       default False;
      property ExportBtn : Boolean
          read FExportBtn
         write FExportBtn
       default True;
      property GroupTree : Boolean
          read FGroupTree
         write FGroupTree
       default False;
      property NavigationCtls : Boolean
          read FNavigationCtls
         write FNavigationCtls
       default True;
      property PrintBtn : Boolean
          read FPrintBtn
         write FPrintBtn
       default True;
      property PrintSetupBtn : Boolean
          read FPrintSetupBtn
         write FPrintSetupBtn
       default False;
      property ProgressCtls : Boolean
          read FProgressCtls
         write FProgressCtls
       default True;
      property RefreshBtn : Boolean
          read FRefreshBtn
         write FRefreshBtn
       default False;
      property SearchBtn : Boolean
          read FSearchBtn
         write FSearchBtn
       default False;
      property ZoomCtl : Boolean
          read FZoomCtl
         write FZoomCtl
       default True;
      property ToolbarTips : Boolean
          read FToolbarTips
         write FToolbarTips
       default True;
      property DocumentTips : Boolean
          read FDocumentTips
         write FDocumentTips
       default False;
   public
     Cr : TCrpe;
     procedure Clear;
     function  Send : boolean;
     function  Retrieve : boolean;
     procedure CopyFrom (Source: TCrpeWindowButtonBar);
     constructor Create;
   end; { Class TCrpeWindowButtonBar Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowCursor                                                      }
{------------------------------------------------------------------------------}
   TCrpeWindowCursor = class(TPersistent)
   private
      FGroupArea       : TCrWindowCursor;
      FGroupAreaField  : TCrWindowCursor;
      FDetailArea      : TCrWindowCursor;
      FDetailAreaField : TCrWindowCursor;
      FGraph           : TCrWindowCursor;
   protected
   published
      property GroupArea : TCrWindowCursor
          read FGroupArea
         write FGroupArea;
      property GroupAreaField : TCrWindowCursor
          read FGroupAreaField
         write FGroupAreaField;
      property DetailArea : TCrWindowCursor
          read FDetailArea
         write FDetailArea;
      property DetailAreaField : TCrWindowCursor
          read FDetailAreaField
         write FDetailAreaField;
      property Graph : TCrWindowCursor
          read FGraph
         write FGraph;
   public
     Cr : TCrpe;
     procedure Clear;
     function  Retrieve: boolean;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeWindowCursor);
     constructor Create;
   end; { Class TCrpeWindowCursor Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpePages                                                             }
{------------------------------------------------------------------------------}
   TCrpePages = class(TPersistent)
   private
   protected
     function  GetIndex : integer;
     procedure SetIndex (const nIndex: integer);
     function  GetItem (nIndex: integer) : string;
   public
     Cr : TCrpe;
     property ItemIndex : integer
         read GetIndex
        write SetIndex;
     property Item[nIndex: integer]: string
         read GetItem; default;
     function  GetDisplayed: Word;
     function  GetLatest: Word;
     function  GetStart: Word;
     function  Count: SmallInt;
     procedure First;
     procedure Next;
     procedure Previous;
     procedure Last;
     procedure GoToPage(const Value : SmallInt);
   end; { Class TCrpePages Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeRecords                                                           }
{------------------------------------------------------------------------------}
   TCrpeRecords = class(TPersistent)
   private
   public
     Cr : TCrpe;
     function Printed : LongInt;
     function Selected : LongInt;
     function Read : LongInt;
   end; { Class TCrpeRecords Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeSummaryInfo                                                       }
{------------------------------------------------------------------------------}
   TCrpeSummaryInfo = class(TPersistent)
   private
      FAppName   : TCrSummaryString;
      FTitle     : TCrSummaryString;
      FSubject   : TCrSummaryString;
      FAuthor    : TCrSummaryString;
      FKeywords  : TCrSummaryString;
      FComments  : TCrpeString;
      FTemplate  : TCrSummaryString;
   protected
      procedure SetTitle(Value: TCrSummaryString);
      procedure SetSubject(Value: TCrSummaryString);
      procedure SetAuthor(Value: TCrSummaryString);
      procedure SetKeywords(Value: TCrSummaryString);
      function  GetComments : TCrpeString;
      procedure SetComments(const ListVar: TCrpeString);
      procedure SetTemplate(Value: TCrSummaryString);
      procedure SetAppName(Value: TCrSummaryString);
   published
      property Title : TCrSummaryString
          read FTitle
         write SetTitle;
      property Subject : TCrSummaryString
          read FSubject
         write SetSubject;
      property Author : TCrSummaryString
          read FAuthor
         write SetAuthor;
      property Keywords : TCrSummaryString
          read FKeywords
         write SetKeywords;
      property Comments : TCrpeString
          read GetComments
         write SetComments;
      property Template : TCrSummaryString
          read FTemplate
         write SetTemplate;
      property AppName : TCrSummaryString
          read FAppName
         write SetAppName;
   public
     Cr : TCrpe;
     procedure Clear;
     function  Retrieve : boolean;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeSummaryInfo);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSummaryInfo Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeMargins                                                           }
{------------------------------------------------------------------------------}
   TCrpeMargins = class(TPersistent)
   private
      FTop    : TCrMarginTwips;
      FBottom : TCrMarginTwips;
      FLeft   : TCrMarginTwips;
      FRight  : TCrMarginTwips;
   protected
   published
      property Left : TCrMarginTwips
          read FLeft
         write FLeft
       default PE_SM_DEFAULT;
      property Right : TCrMarginTwips
          read FRight
         write FRight
       default PE_SM_DEFAULT;
      property Top : TCrMarginTwips
          read FTop
         write FTop
       default PE_SM_DEFAULT;
      property Bottom : TCrMarginTwips
          read FBottom
         write FBottom
       default PE_SM_DEFAULT;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeMargins);
     constructor Create;
   end; { Class TCrpeMargins Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpePrintDate                                                         }
{------------------------------------------------------------------------------}
   TCrpePrintDate = class(TPersistent)
   private
      FDay    : Smallint;
      FMonth  : Smallint;
      FYear   : Smallint;
   protected
   published
      property Day : Smallint
          read FDay
         write FDay;
      property Month : Smallint
          read FMonth
         write FMonth;
      property Year : Smallint
          read FYear
         write FYear;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpePrintDate);
     constructor Create;
   end; { Class TCrpePrintDate Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportEmail                                                       }
{------------------------------------------------------------------------------}
   TCrpeExportEmail = class(TPersistent)
   private
      FCCList,
      FMessage,
      FSubject,
      FToList,
      FBCCList : string;
   protected
   published
      property CCList: string
          read FCCList
         write FCCList;
      property Message : string
          read FMessage
         write FMessage;
      property Subject : string
          read FSubject
         write FSubject;
      property ToList : string
          read FToList
         write FToList;
      property BCCList : string
          read FBCCList
         write FBCCList;
   public
     procedure Clear;
     procedure CopyFrom (Source: TCrpeExportEmail);
   end; { Class TCrpeExportEmail Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportExchange                                                    }
{------------------------------------------------------------------------------}
   TCrpeExportExchange = class(TPersistent)
   private
      FFolder,
      FPassword,
      FProfile   : string;
   protected
   published
      property Folder: string
          read FFolder
         write FFolder;
      property Password : string
          read FPassword
         write FPassword;
      property Profile : string
          read FProfile
         write FProfile;
   public
     procedure Clear;
     procedure CopyFrom (Source: TCrpeExportExchange);
   end; { Class TCrpeExportExchange Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportODBC                                                        }
{------------------------------------------------------------------------------}
   TCrpeExportODBC = class(TPersistent)
   private
      FPassword,
      FSource,
      FTable,
      FUser         : string;
   protected
   published
      property Password: string
          read FPassword
         write FPassword;
      property Source : string
          read FSource
         write FSource;
      property Table : string
          read FTable
         write FTable;
      property User : string
          read FUser
         write FUser;
   public
     procedure Clear;
     procedure CopyFrom (Source: TCrpeExportODBC);
   end; { Class TCrpeExportODBC Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportExcel                                                       }
{------------------------------------------------------------------------------}
   TCrpeExportExcel = class(TPersistent)
   private
     FColumnHeadings : boolean;
     FColumnWidth    : TCrColumnWidth;
     FTabularFormat  : boolean;
     FConstant       : double;
     FArea           : string;
     FWorksheetFunctions : boolean;
     FXlsType        : TCrExportExcelType;
   protected
   published
      property ColumnHeadings: boolean
          read FColumnHeadings
         write FColumnHeadings
       default False;
      property ColumnWidth : TCrColumnWidth
          read FColumnWidth
         write FColumnWidth
       default ByArea;
      property TabularFormat : boolean
          read FTabularFormat
         write FTabularFormat
       default False;
      property Constant : double
          read FConstant
         write FConstant;
       {default 9}
      property Area : string
          read FArea
         write FArea;
       {default 'D'}
      property WorksheetFunctions : boolean
          read FWorksheetFunctions
         write FWorksheetFunctions
       default True;
      property XlsType : TCrExportExcelType
          read FXlsType
         write FXlsType
       default Excel5Extended;
   public
     procedure Clear;
     procedure CopyFrom (Source: TCrpeExportExcel);
     constructor Create;
   end; { Class TCrpeExportExcel Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportLotusNotes                                                  }
{------------------------------------------------------------------------------}
   TCrpeExportLotusNotes = class(TPersistent)
   private
     FDBName   : string;
     FFormName : string;
     FComments : string;
   protected
   published
      property DBName : string
          read FDBName
         write FDBName;
      property FormName : string
          read FFormName
         write FFormName;
      property Comments : string
          read FComments
         write FComments;
   public
     procedure Clear;
     procedure CopyFrom (Source: TCrpeExportLotusNotes);
     constructor Create;
   end; { Class TCrpeExportLotusNotes Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExport                                                            }
{------------------------------------------------------------------------------}
   TCrpeExport = class(TPersistent)
   private
      FAppName           : TCrExportAppName;
      FFileName          : TCrExportFileName;
      FFileType          : TCrExportType;
      FDestination       : TCrExportDestination;
      FUseRptNumberFmt   : boolean;
      FUseRptDateFmt     : boolean;
      FCharSepQuote      : Char;
      FCharSepSeparator  : string;
      FLinesPerPage      : Word;
      FEmail             : TCrpeExportEmail;
      FExchange          : TCrpeExportExchange;
      FODBC              : TCrpeExportODBC;
      FExcel             : TCrpeExportExcel;
      FLotusNotes        : TCrpeExportLotusNotes;
      FPromptForOptions  : boolean;
      FPromptOnOverwrite : boolean;
   protected
     procedure SetEmail(const Value: TCrpeExportEmail);
     procedure SetExchange(const Value: TCrpeExportExchange);
     procedure SetODBC(const Value: TCrpeExportODBC);
     procedure SetExcel(const Value: TCrpeExportExcel);
     procedure SetLotusNotes (const Value: TCrpeExportLotusNotes);
   published
      property AppName : TCrExportAppName
          read FAppName
         write FAppName;
      property FileName : TCrExportFileName
          read FFileName
         write FFileName;
      property FileType : TCrExportType
          read FFileType
         write FFileType
       default Ascii;
      property Destination : TCrExportDestination
          read FDestination
         write FDestination
       default toFile;
       {Email}
      property Email : TCrpeExportEmail
          read FEmail
         write SetEmail;
       {Exchange}
      property Exchange : TCrpeExportExchange
          read FExchange
         write SetExchange;
       {ODBC}
      property ODBC : TCrpeExportODBC
          read FODBC
         write SetODBC;
       {Excel}
      property Excel : TCrpeExportExcel
          read FExcel
         write SetExcel;
       {Lotus Notes}
      property LotusNotes : TCrpeExportLotusNotes
          read FLotusNotes
         write SetLotusNotes;
       {Text Exports}
      property UseRptNumberFmt : Boolean
          read FUseRptNumberFmt
         write FUseRptNumberFmt
       default True;
      property UseRptDateFmt : Boolean
          read FUseRptDateFmt
         write FUseRptDateFmt
       default True;
       {CSV}
      property CharSepQuote: Char
          read FCharSepQuote
         write FCharSepQuote;
      property CharSepSeparator: string
          read FCharSepSeparator
         write FCharSepSeparator;
       {PaginatedText}
      property LinesPerPage: Word
          read FLinesPerPage
         write FLinesPerPage
       default 60;
       {Prompt}
      property PromptForOptions: boolean
          read FPromptForOptions
         write FPromptForOptions
       default False;
      property PromptOnOverwrite: boolean
          read FPromptOnOverwrite
         write FPromptOnOverwrite
       default False;
   public
     Cr : TCrpe;
     procedure Clear;
     function  Send : boolean;
     function  GetCrpe : TCrpe;
     procedure CopyFrom (Source: TCrpeExport);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeExport Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpePrinter                                                           }
{------------------------------------------------------------------------------}
   TCrpePrinter = class(TPersistent)
   private
      FName,
      FDriver,
      FPort                : TCrPrinterName;
      FMode                : THandle;
      FPMode               : PDevMode;
      FOrientation         : TCrOrientation;
      FShowDialog          : Boolean;
      FPreserveRptSettings : TCrPreserveRptSettings;
   protected
     procedure SetMode(const Value : THandle);
     procedure SetPMode(Value : PDevMode);
     function  GetPrinterInfoFromName(PrtName: string): boolean;
     function  GetDMPointerFromHandle(xHandle: THandle): PDevMode;
   published
      property Name : TCrPrinterName
          read FName
         write FName;
      property Driver : TCrPrinterName
          read FDriver
         write FDriver;
      property Port : TCrPrinterName
          read FPort
         write FPort;
      property Orientation : TCrOrientation
          read FOrientation
         write FOrientation
       default orDefault;
      property ShowDialog : Boolean
          read FShowDialog
         write FShowDialog
       default False;
      property PreserveRptSettings : TCrPreserveRptSettings
          read FPreserveRptSettings
         write FPreserveRptSettings
       default [];
   public
      Cr : TCrpe;
      property Mode: THandle
          read FMode
         write SetMode;
      property PMode: PDevMode
          read FPMode
         write SetPMode;
     function  Retrieve : boolean;
     function  GetCurrent(PreserveDevMode: boolean) : boolean;
     function  SetCurrent: boolean;
     function  ShowPrintDlg : boolean;
     procedure Clear;
     function  Send : TCrBoolean;
     procedure CopyFrom (Source: TCrpePrinter);
     constructor Create;
   end; { Class TCrpePrinter Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpePrintOptions                                                      }
{------------------------------------------------------------------------------}
   TCrpePrintOptions = class(TPersistent)
   private
      FCollation        : TCrCollation;
      FCopies,
      FStartPage,
      FStopPage         : Word;
      FPromptForOptions : boolean;
      FOutputFileName   : TCrPrintFileName;
   protected
     procedure SetOutputFileName(const Value : TCrPrintFileName);
   published
      property Copies : Word
          read FCopies
         write FCopies
       default 1;
      property Collation : TCrCollation
          read FCollation
         write FCollation
       default DefaultCollation;
      property StartPage : Word
          read FStartPage
         write FStartPage
       default 0;
      property StopPage : Word
          read FStopPage
         write FStopPage
       default 0;
      property PromptForOptions : boolean
          read FPromptForOptions
         write FPromptForOptions
       default False;
      property OutputFileName : TCrPrintFileName
          read FOutputFileName
         write SetOutputFileName;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     function  Send : TCrBoolean;
     procedure Clear;
     procedure CopyFrom (Source: TCrpePrintOptions);
     constructor Create;
   end; { Class TCrpePrintOptions Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeConnect                                                           }
{------------------------------------------------------------------------------}
   TCrpeConnect = class(TPersistent)
   private
     FServerName   : string;
     FUserID       : string;
     FPassword     : string;
     FDatabaseName : string;
     FPropagate    : boolean;
   protected
   published
      property ServerName : string
          read FServerName
         write FServerName;
      property UserID : string
          read FUserID
         write FUserID;
      property Password : string
          read FPassword
         write FPassword;
      property DatabaseName : string
          read FDatabaseName
         write FDatabaseName;
      property Propagate : boolean
          read FPropagate
         write FPropagate
       default False;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     function  Test: boolean;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeConnect);
     constructor Create;
   end; { Class TCrpeConnect Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnServerItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeLogOnServerItem = class(TObject)
   private
     FNumber       : integer;
     FDllName      : string;
     FServerName   : string;
     FUserID       : string;
     FPassword     : string;
     FDatabaseName : string;
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnServer                                                       }
{  - Keeps track of logged-on datasources for LogOn/LogOff Server              }
{------------------------------------------------------------------------------}
   TCrpeLogOnServer = class(TPersistent)
   private
     FList  : TList;
     FIndex : integer;
   protected
     function  GetDLLName : string;
     procedure SetDLLName(const Value: string);
     function  GetServerName : string;
     procedure SetServerName(const Value: string);
     function  GetUserID : string;
     procedure SetUserID(const Value: string);
     function  GetPassword : string;
     procedure SetPassword(const Value: string);
     function  GetDatabaseName : string;
     procedure SetDatabaseName(const Value: string);
     procedure SetIndex (const nIndex: integer);
     function  GetNumber : integer;
     function  GetItem (nIndex: integer) : TCrpeLogOnServer;
     function  ListItem(nIndex: integer): TCrpeLogOnServerItem;
   published
      property DLLName : string
          read GetDLLName
         write SetDLLName;
      property ServerName : string
          read GetServerName
         write SetServerName;
      property UserID : string
          read GetUserID
         write SetUserID;
      property Password : string
          read GetPassword
         write SetPassword;
      property DatabaseName : string
          read GetDatabaseName
         write SetDatabaseName;
   public
     Cr : TCrpe;
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      {Read-only properties}
      property Number : integer
          read GetNumber
       default 0;
      property Item[nIndex: integer]: TCrpeLogOnServer
          read GetItem; default;
     procedure Clear;
     function  LogOn : boolean;
     function  LogOff : boolean;
     function  Add : integer;
     procedure Delete (nIndex : integer);
     function  Count : integer;
     function  Retrieve : boolean;
     function  IndexOfNumber(LogNumber: integer): integer;
     function  IndexOf(Server, User, Database: string): integer;
     procedure CopyFrom (Source: TCrpeLogOnServer);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeLogOnServer Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnInfoItem                                                     }
{------------------------------------------------------------------------------}
   TCrpeLogOnInfoItem = class(TObject)
   private
     FTable           : integer;
     FServerName      : string;
     FUserID          : string;
     FPassword        : string;
     FDatabaseName    : string;
     FDLLName         : string;
     FDescriptiveName : string;
     FTableType       : TCrTableType;
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnInfo                                                         }
{------------------------------------------------------------------------------}
   TCrpeLogOnInfo = class(TPersistent)
   private
     FList            : TList;
     FPromptForLogOn  : boolean;
     FSQLTablesOnly   : boolean;
     FIndex           : integer;
   protected
     function  GetServerName : string;
     procedure SetServerName(const Value: string);
     function  GetUserID : string;
     procedure SetUserID(const Value: string);
     function  GetPassword : string;
     procedure SetPassword(const Value: string);
     function  GetDatabaseName : string;
     procedure SetDatabaseName(const Value: string);
     function  GetTable : TCrLogOnInfoTable;
     procedure SetTable(const Value: TCrLogOnInfoTable);
     procedure SetIndex (const nIndex: integer);
     function  GetDLLName : string;
     function  GetDescriptiveName : string;
     function  GetTableType : TCrTableType;
     function  GetItem(nIndex: integer) : TCrpeLogOnInfo;
     function  ListItem(nIndex: integer) : TCrpeLogOnInfoItem;
   published
      property Table : TCrLogOnInfoTable
          read GetTable
         write SetTable;
      property ServerName : string
          read GetServerName
         write SetServerName;
      property UserID : string
          read GetUserID
         write SetUserID;
      property Password : string
          read GetPassword
         write SetPassword;
      property DatabaseName : string
          read GetDatabaseName
         write SetDatabaseName;
      property PromptForLogOn : boolean
          read FPromptForLogOn
         write FPromptForLogOn
       default False;
      property SQLTablesOnly : boolean
          read FSQLTablesOnly
         write FSQLTablesOnly
       default True;
   public
     Cr : TCrpe;
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      {Read-only properties}
      property Item[nIndex: integer]: TCrpeLogOnInfo
          read GetItem; default;
      property DLLName : string
          read GetDLLName;
      property DescriptiveName : string
          read GetDescriptiveName;
      property TableType : TCrTableType
          read GetTableType;
     function  Retrieve : boolean;
     function  Count : integer;
     function  Add (TableNumber: TCrLogOnInfoTable): integer;
     procedure Delete (nIndex : integer);
     function  Test : boolean;
     procedure Clear;
     function  IndexOf (TableNumber: TCrLogOnInfoTable): integer;
     function  Send : TCrBoolean;
     procedure CopyFrom (Source: TCrpeLogOnInfo);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeLogOnInfo Declaration }

{------------------------------------------------------------------------------}
{ Class TLogOnInfoDlg                                                          }
{  - used for the LogOnInfo.PromptForLogon property                            }
{------------------------------------------------------------------------------}
  TLogOnInfoDlg = class(TForm)
    pnlLogOnInfo1    : TPanel;
    pnlLogOnInfo2    : TPanel;
    lblConnections   : TLabel;
    lbConnections    : TListBox;
    lblServerName    : TLabel;
    lblDatabaseName  : TLabel;
    lblUserID        : TLabel;
    lblPassword      : TLabel;
    editServerName   : TEdit;
    editDatabaseName : TEdit;
    editUserID       : TEdit;
    editPassword     : TEdit;
    btnOk            : TButton;
    btnCancel        : TButton;
    procedure lbConnectionsClick(Sender: TObject);
    procedure editServerNameChange(Sender: TObject);
    procedure editUserIDChange(Sender: TObject);
    procedure editPasswordChange(Sender: TObject);
    procedure editDatabaseNameChange(Sender: TObject);
    procedure btnOkClick(Sender: TObject);
    procedure UpdateLogOn;
    procedure FormShow(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
  private
    { Private declarations }
  public
    { Public declarations }
    slLogInfo      : TStringList;
    slServerName   : TStringList;
    slUserID       : TStringList;
    slPassword     : TStringList;
    slDatabaseName : TStringList;
    slRemainder    : TStringList;
    function GetToken(var s: string; const sDelimiter: string): string;
  end;  { TLogOnInfoDlg }

{------------------------------------------------------------------------------}
{ Class TCrpeTablesItem                                                        }
{------------------------------------------------------------------------------}
  TCrpeTablesItem = class(TObject)
  private
    FNumber          : TCrTableNumber;
    FName            : string;
    FPath            : string;
    FSubName         : string; {for Access MDB table names}
    FConnectBuffer   : string;
    FPassword        : string; {for Paradox tables}
    {TableType}
    FTableType       : TCrTableType;
    FDLLName         : string;
    FDescriptiveName : string;
    {PrivateInfo}
    FBytes           : smallint;
    FTag             : DWord;
    FDataPointer     : Pointer;
  protected
  published
  public
    constructor Create;
    destructor Destroy; override;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeTables                                                            }
{------------------------------------------------------------------------------}
   TCrpeTables = class(TPersistent)
   private
      FList      : TList;
      FPropagate : boolean;
      FIndex     : integer;
   protected
      function  GetNumber : TCrTableNumber;
      procedure SetNumber (const Value: TCrTableNumber);
      function  GetName : string;
      procedure SetName (const Value: string);
      function  GetPath : string;
      procedure SetPath (const Value: string);
      function  GetSubName : string;
      procedure SetSubName (const Value: string);
      function  GetConnectBuffer : string;
      procedure SetConnectBuffer (const Value: string);
      function  GetPassword : string;
      procedure SetPassword (const Value: string);
      function  GetTableType : TCrTableType;
      function  GetDLLName : string;
      function  GetDescriptiveName : string;
      function  GetBytes : smallint;
      procedure SetBytes (const Value: smallint);
      function  GetTag : DWord;
      procedure SetTag (const Value: DWord);
      function  GetDataPointer : Pointer;
      procedure SetDataPointer (const Value: Pointer);
      procedure SetIndex (const nIndex: integer);
      function  GetItem(const nIndex: integer) : TCrpeTables;
      function  ListItem(nIndex: integer): TCrpeTablesItem;
   published
      property Number : TCrTableNumber
          read GetNumber
         write SetNumber;
      property Name : string
          read GetName
         write SetName;
      property Path : string
          read GetPath
         write SetPath;
      property SubName : string
          read GetSubName
         write SetSubName;
      property ConnectBuffer : string
          read GetConnectBuffer
         write SetConnectBuffer;
      property Password : string
          read GetPassword
         write SetPassword;
      property Propagate : boolean
          read FPropagate
         write FPropagate
       default False;
   public
      Cr         : TCrpe;
      property Bytes : smallint
          read GetBytes
         write SetBytes;
      property Tag : DWord
          read GetTag
         write SetTag;
      property DataPointer : Pointer
          read GetDataPointer
         write SetDataPointer;
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      {Read only properties: only for GetNthTable}
      property TableType : TCrTableType
          read GetTableType;
      property DLLName : string
          read GetDLLName;
      property DescriptiveName : string
          read GetDescriptiveName;
      property Item[const nIndex: integer]: TCrpeTables
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count : integer;
     function  Add (TableNumber: TCrTableNumber): integer;
     procedure Delete (nIndex: integer);
     procedure Clear;
     function  Send : boolean;
     function  IndexOf (TableNumber: TCrTableNumber): integer;
     function  IndexOfName (TableName: string): integer;
     procedure CopyFrom (Source: TCrpeTables);
     function  Test : boolean;
     function  CheckDifferences (var DifNums: TStringList; var DifStrings: TStringList): boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeTables }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldInfo                                                    }
{------------------------------------------------------------------------------}
   TCrpeParamFieldInfo = class(TPersistent)
   private
     FAllowNull              : TCrBoolean;
     FAllowEditing           : TCrBoolean;
     FAllowMultipleValues    : TCrBoolean;
     FPartOfGroup            : TCrBoolean;
     FMutuallyExclusiveGroup : TCrBoolean;
     FValueType              : TCrParamInfoValueType;
     FGroupNum               : Smallint;
   protected
     function  GetAllowNull : TCrBoolean;
     procedure SetAllowNull (const Value: TCrBoolean);
     function  GetAllowEditing : TCrBoolean;
     procedure SetAllowEditing (const Value: TCrBoolean);
     function  GetAllowMultipleValues : TCrBoolean;
     procedure SetAllowMultipleValues (const Value: TCrBoolean);
     function  GetValueType : TCrParamInfoValueType;
     procedure SetValueType (const Value: TCrParamInfoValueType);
     function  GetPartOfGroup : TCrBoolean;
     procedure SetPartOfGroup (const Value: TCrBoolean);
     function  GetMutuallyExclusiveGroup : TCrBoolean;
     procedure SetMutuallyExclusiveGroup (const Value: TCrBoolean);
     function  GetGroupNum : smallint;
     procedure SetGroupNum (const Value: smallint);
   published
     property AllowNull : TCrBoolean
         read GetAllowNull
        write SetAllowNull;
     property AllowEditing : TCrBoolean
         read GetAllowEditing
        write SetAllowEditing;
     property AllowMultipleValues : TCrBoolean
         read GetAllowMultipleValues
        write SetAllowMultipleValues;
     property ValueType : TCrParamInfoValueType
         read GetValueType
        write SetValueType;
     property PartOfGroup : TCrBoolean
         read GetPartOfGroup
        write SetPartOfGroup;
     property MutuallyExclusiveGroup : TCrBoolean
         read GetMutuallyExclusiveGroup
        write SetMutuallyExclusiveGroup;
     property GroupNum : smallint
         read GetGroupNum
        write SetGroupNum;
   public
     Cr : TCrpe;
     Pf : TCrpeParamFields;
     procedure Clear;
     function  Retrieve : boolean;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeParamFieldInfo);
     constructor Create;
   end; { Class TCrpeParamFieldInfo }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldRangesItem                                              }
{------------------------------------------------------------------------------}
   TCrpeParamFieldRangesItem = class(TObject)
   private
     FNumber      : TCrRangeNumber;
     FRangeStart  : string;
     FRangeEnd    : string;
     FRangeBounds : TCrRangeBounds;
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldRanges                                                  }
{------------------------------------------------------------------------------}
   TCrpeParamFieldRanges = class(TPersistent)
   private
     FList  : TList;
     FIndex : integer;
   protected
     function  GetNumber : TCrRangeNumber;
     procedure SetNumber (const Value: TCrRangeNumber);
     function  GetRangeStart : string;
     procedure SetRangeStart (const Value: string);
     function  GetRangeEnd : string;
     procedure SetRangeEnd (const Value: string);
     function  GetRangeBounds : TCrRangeBounds;
     procedure SetRangeBounds (const Value: TCrRangeBounds);
     function  GetIndex : integer;
     procedure SetIndex (const nIndex: integer);
     function  GetItem(const nIndex: integer) : TCrpeParamFieldRanges;
     function  ListItem(nIndex: integer): TCrpeParamFieldRangesItem;
   published
      property Number : TCrRangeNumber
          read GetNumber
         write SetNumber;
      property RangeStart : string
          read GetRangeStart
         write SetRangeStart;
      property RangeEnd : string
          read GetRangeEnd
         write SetRangeEnd;
      property RangeBounds : TCrRangeBounds
          read GetRangeBounds
         write SetRangeBounds;
   public
     Cr : TCrpe;
     Pf : TCrpeParamFields;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[const nIndex: integer]: TCrpeParamFieldRanges
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count : integer;
     function  Add (RangeNumber: TCrRangeNumber): integer;
     procedure Delete (nIndex : integer);
     procedure Clear;
     function  IndexOf(RangeNumber: TCrRangeNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeParamFieldRanges);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFieldRanges }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldsItem                                                   }
{------------------------------------------------------------------------------}
  TCrpeParamFieldsItem = class(TObject)
  private
    FNameAndReport       : string;
    FName                : TCrParamFieldName;
    FPrompt              : string;
    FValue               : string;
    FDefaultValue        : string;
    FCurrentValue        : string;
    FShowDialog          : boolean;
    FParamType           : TCrParamFieldType;
    FReportName          : TCrParamFieldReportName;
    FNeedsCurrentValue   : boolean;
    {SCR7+}
    FRanges              : TCrpeParamFieldRanges;
    FDList               : TCrpeString;
    FCList               : TCrpeString;
    FPList               : TCrpeString;
    FInfo                : TCrpeParamFieldInfo;
    FParamSource         : TCrParamFieldSource;
    FValueLimit          : TCrBoolean;
    FValueMin            : string;
    FValueMax            : string;
    FEditMask            : string;
    FPLDescriptionOnly   : TCrBoolean;
    FPLSortMethod        : TCrPickListSortMethod;
    FPLSortByDescription : TCrBoolean;
  protected
  published
  public
    constructor Create;
    destructor Destroy; override;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeParamFields                                                       }
{------------------------------------------------------------------------------}
   TCrpeParamFields = class(TPersistent)
   private
     FList       : TList;
     TempInfo    : TCrpeParamFieldInfo;
     TempRanges  : TCrpeParamFieldRanges;
     sTemp       : TCrpeString;
     FIndex      : integer;
   protected
     function  GetName : TCrParamFieldName;
     procedure SetName (const Value: TCrParamFieldName);
     function  GetPrompt : string;
     procedure SetPrompt (const Value: string);
     function  GetValue : string;
     procedure SetValue (const Value: string);
     function  GetDefaultValue : string;
     procedure SetDefaultValue (const Value: string);
     function  GetCurrentValue : string;
     procedure SetCurrentValue (const Value: string);
     function  GetShowDialog : boolean;
     procedure SetShowDialog (const Value: boolean);
     function  GetParamType : TCrParamFieldType;
     procedure SetParamType (const Value: TCrParamFieldType);
     function  GetIndex : integer;
     procedure SetIndex (const nIndex: integer);
     function  GetReportName : TCrParamFieldReportName;
     function  GetNeedsCurrentValue : boolean;
     {SCR 7+}
     function  GetParamSource : TCrParamFieldSource;
     procedure SetParamSource (const Value: TCrParamFieldSource);
     function  GetValueLimit : TCrBoolean;
     procedure SetValueLimit (const Value: TCrBoolean);
     function  GetValueMin : string;
     procedure SetValueMin (const Value: string);
     function  GetValueMax : string;
     procedure SetValueMax (const Value: string);
     function  GetEditMask : string;
     procedure SetEditMask (const Value: string);
     function  GetInfo : TCrpeParamFieldInfo;
     procedure SetInfo (const Value: TCrpeParamFieldInfo);
     function  GetDefaultValues : TCrpeString;
     procedure SetDefaultValues (const ListVar: TCrpeString);
     function  GetCurrentValues : TCrpeString;
     procedure SetCurrentValues (const ListVar: TCrpeString);
     function  GetRanges : TCrpeParamFieldRanges;
     procedure SetRanges (const Value: TCrpeParamFieldRanges);
     {PickList}
     function  GetPickList : TCrpeString;
     procedure SetPickList (const ListVar: TCrpeString);
     function  GetPLDescriptionOnly : TCrBoolean;
     procedure SetPLDescriptionOnly (const Value: TCrBoolean);
     function  GetPLSortMethod : TCrPickListSortMethod;
     procedure SetPLSortMethod (const Value: TCrPickListSortMethod);
     function  GetPLSortByDescription : TCrBoolean;
     procedure SetPLSortByDescription (const Value: TCrBoolean);
     {public}
     function  GetAsNumber : double;
     procedure SetAsNumber (const Value: double);
     function  GetAsBoolean : boolean;
     procedure SetAsBoolean (const Value: boolean);
     function  GetAsCurrency : currency;
     procedure SetAsCurrency (const Value: currency);
     function  GetAsDate : TDateTime;
     procedure SetAsDate (const Value: TDateTime);
     function  GetAsDateTime : TDateTime;
     procedure SetAsDateTime (const Value: TDateTime);
     function  GetAsTime : TDateTime;
     procedure SetAsTime (const Value: TDateTime);
     function  GetItem(const nIndex: integer) : TCrpeParamFields;
     function  ListItem(nIndex: integer): TCrpeParamFieldsItem;
   published
      property Name : TCrParamFieldName
          read GetName
         write SetName;
      property Prompt : string
          read GetPrompt
         write SetPrompt;
      property Value : string
          read GetValue
         write SetValue;
      property ShowDialog : boolean
          read GetShowDialog
         write SetShowDialog
       default False;
      property ParamType : TCrParamFieldType
          read GetParamType
         write SetParamType;
      {SCR 7+}
      property ParamSource : TCrParamFieldSource
          read GetParamSource
         write SetParamSource;
      property EditMask : string
          read GetEditMask
         write SetEditMask;
      property Info : TCrpeParamFieldInfo
          read GetInfo
         write SetInfo;
      property DefaultValues : TCrpeString
          read GetDefaultValues
         write SetDefaultValues;
      property CurrentValues : TCrpeString
          read GetCurrentValues
         write SetCurrentValues;
      property ValueLimit : TCrBoolean
          read GetValueLimit
         write SetValueLimit;
      property ValueMin : string
          read GetValueMin
         write SetValueMin;
      property ValueMax : string
          read GetValueMax
         write SetValueMax;
      property Ranges : TCrpeParamFieldRanges
          read GetRanges
         write SetRanges;
      property PickList : TCrpeString
          read GetPickList
         write SetPickList;
      property PLDescriptionOnly : TCrBoolean
          read GetPLDescriptionOnly
         write SetPLDescriptionOnly;
      property PLSortMethod : TCrPickListSortMethod
          read GetPLSortMethod
         write SetPLSortMethod;
      property PLSortByDescription : TCrBoolean
          read GetPLSortByDescription
         write SetPLSortByDescription;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[const nIndex: integer]: TCrpeParamFields
          read GetItem; default;
      {Read only properties}
      property ReportName : TCrParamFieldReportName
          read GetReportName;
      property DefaultValue : string
          read GetDefaultValue
         write SetDefaultValue;
      property CurrentValue : string
          read GetCurrentValue
         write SetCurrentValue;
      property NeedsCurrentValue : boolean
          read GetNeedsCurrentValue;
      property AsNumber : double
          read GetAsNumber
         write SetAsNumber;
      property AsCurrency : currency
          read GetAsCurrency
         write SetAsCurrency;
      property AsBoolean : boolean
          read GetAsBoolean
         write SetAsBoolean;
      property AsDate : TDateTime
          read GetAsDate
         write SetAsDate;
      property AsDateTime : TDateTime
          read GetAsDateTime
         write SetAsDateTime;
      property AsTime : TDateTime
          read GetAsTime
         write SetAsTime;
     function  Retrieve : boolean;
     function  Count : integer;
     function  Add (ParameterName: TCrParamFieldName;
       ReportName: TCrParamFieldReportName): integer;
     procedure Delete (nIndex : integer);
     procedure Clear;
     function  Send: boolean;
     function  IndexOf (ParameterName: TCrParamFieldName;
       ReportName: TCrParamFieldReportName): integer;
     function  IndexOfName (ParameterName: TCrParamFieldName): integer;
     procedure CopyFrom (Source: TCrpeParamFields);
     function  RetrieveValues: boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFields }

{------------------------------------------------------------------------------}
{ Class TCrpeStoredProcParamsItem                                              }
{------------------------------------------------------------------------------}
  TCrpeStoredProcParamsItem = class(TObject)
  private
    FName      : TCrStoredProcParamName;
    FValue     : string;
    FParamType : TCrStoredProcParamType;
  protected
  published
  public
    constructor Create;
  end;


{------------------------------------------------------------------------------}
{ Class TCrpeStoredProcParams                                                  }
{------------------------------------------------------------------------------}
  TCrpeStoredProcParams = class(TPersistent)
  private
    FList  : TList;
    FIndex : integer;
  protected
    function  GetName : TCrStoredProcParamName;
    procedure SetName (const Value: TCrStoredProcParamName);
    function  GetParamType : TCrStoredProcParamType;
    procedure SetParamType (const Value: TCrStoredProcParamType);
    function  GetValue : string;
    procedure SetValue (const Value: string);
    function  GetAsDate : TDateTime;
    procedure SetAsDate (const Value: TDateTime);
    function  GetAsDateTime : TDateTime;
    procedure SetAsDateTime (const Value: TDateTime);
    function  GetAsBoolean : boolean;
    procedure SetAsBoolean (const Value: boolean);
    function  GetAsInteger : integer;
    procedure SetAsInteger (const Value: integer);
    function  GetAsFloat : double;
    procedure SetAsFloat (const Value: double);
    function  GetIndex : integer;
    procedure SetIndex (const nIndex: integer);
    function  GetItem(const nIndex: integer) : TCrpeStoredProcParams;
    function  ListItem(nIndex: integer): TCrpeStoredProcParamsItem;
  published
    property Name : TCrStoredProcParamName
        read GetName
       write SetName;
    property ParamType : TCrStoredProcParamType
        read GetParamType
       write SetParamType;
    property Value : string
        read GetValue
       write SetValue;
  public
    Cr : TCrpe;
    property ItemIndex : integer
        read GetIndex
       write SetIndex;
    property AsDate : TDateTime
        read GetAsDate
       write SetAsDate;
    property AsDateTime : TDateTime
        read GetAsDateTime
       write SetAsDateTime;
    property AsBoolean : boolean
        read GetAsBoolean
       write SetAsBoolean;
    property AsInteger : integer
        read GetAsInteger
       write SetAsInteger;
    property AsFloat : double
        read GetAsFloat
       write SetAsFloat;
    {Read only property}
    property Item[const nIndex: integer]: TCrpeStoredProcParams
        read GetItem; default;
    function  Retrieve : boolean;
    function  Count : integer;
    function  Add (ParamName: TCrStoredProcParamName): integer;
    procedure Delete (nIndex: integer);
    procedure Clear;
    function  Send : boolean;
    function  IndexOf (ParamName: TCrStoredProcParamName): integer;
    procedure CopyFrom (Source: TCrpeStoredProcParams);
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeStoredProcParams }

{------------------------------------------------------------------------------}
{ Class TCrpeSQL                                                               }
{------------------------------------------------------------------------------}
   TCrpeSQL = class(TPersistent)
   private
     sQuery       : TCrpeString;
     FParams      : TCrpeStoredProcParams;
     FExpressions : TCrpeSQLExpressions;
   protected
     function  GetQuery : TCrpeString;
     procedure SetQuery (const ListVar: TCrpeString);
     function  GetParams : TCrpeStoredProcParams;
     procedure SetParams (const Value: TCrpeStoredProcParams);
     function  GetExpressions : TCrpeSQLExpressions;
     procedure SetExpressions (const Value: TCrpeSQLExpressions);
   published
      property Query : TCrpeString
          read GetQuery
         write SetQuery;
      property Params : TCrpeStoredProcParams
          read GetParams
         write SetParams;
      property Expressions : TCrpeSQLExpressions
          read GetExpressions
         write SetExpressions;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     procedure Clear;
     function  Send : boolean;
     function  GetCrpe : TCrpe;
     procedure CopyFrom (Source: TCrpeSQL);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSQL Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeSelection                                                         }
{------------------------------------------------------------------------------}
   TCrpeSelection = class(TPersistent)
   private
      FFormula : TCrpeString;
      FReplace : boolean;
   protected
      function  GetFormula : TCrpeString;
      procedure SetFormula (const ListVar: TCrpeString);
      function  GetReplace : boolean;
      procedure SetReplace (const Value: boolean);
   published
      property Formula : TCrpeString
          read GetFormula
         write SetFormula;
      property Replace : boolean
          read GetReplace
         write SetReplace
       default True;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     function  Check : boolean;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeSelection);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSelection }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupSelection                                                    }
{------------------------------------------------------------------------------}
   TCrpeGroupSelection = class(TPersistent)
   private
      FFormula : TCrpeString;
      FReplace : boolean;
   protected
      function  GetFormula : TCrpeString;
      procedure SetFormula (const ListVar: TCrpeString);
      function  GetReplace : boolean;
      procedure SetReplace (const Value: boolean);
   published
      property Formula : TCrpeString
          read GetFormula
         write SetFormula;
      property Replace : boolean
          read GetReplace
         write SetReplace
       default True;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     function  Check : boolean;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGroupSelection);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupSelection }

{------------------------------------------------------------------------------}
{ Class TCrpeFormulasItem                                                      }
{------------------------------------------------------------------------------}
  TCrpeFormulasItem = class(TObject)
  private
    FName    : string;
    FFormula : TCrpeString;
  protected
  published
  public
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeFormulasItem }

{------------------------------------------------------------------------------}
{ Class TCrpeFormulas                                                          }
{------------------------------------------------------------------------------}
  TCrpeFormulas = class(TPersistent)
  private
    FList  : TList;
    sTemp  : TCrpeString;
    FIndex : integer;
  protected
    function  GetName : TCrFormulaName;
    procedure SetName (const Value: TCrFormulaName);
    function  GetFormula : TCrpeString;
    procedure SetFormula (const ListVar: TCrpeString);
    function  GetIndex : integer;
    procedure SetIndex (const nIndex: integer);
    function  GetItem(nIndex: integer) : TCrpeFormulas;
    function  ListItem(nIndex: integer) : TCrpeFormulasItem;
  published
    property Name : TCrFormulaName
        read GetName
       write SetName;
    property Formula : TCrpeString
        read GetFormula
       write SetFormula;
  public
    Cr : TCrpe;
    property ItemIndex : integer
        read GetIndex
       write SetIndex;
    property Item[nIndex: integer]: TCrpeFormulas
        read GetItem; default;
    function  Retrieve : boolean;
    function  Check : boolean;
    function  Count : integer;
    procedure Clear;
    function  Add (FormulaName: TCrFormulaName): integer;
    procedure Delete(nIndex: integer);
    function  Send : boolean;
    function  IndexOf (FormulaName: TCrFormulaName): integer;
    procedure CopyFrom (Source: TCrpeFormulas);
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeFormulas }

{------------------------------------------------------------------------------}
{ Class TCrpeSortFieldsItem                                                    }
{------------------------------------------------------------------------------}
  TCrpeSortFieldsItem = class(TObject)
  private
    FNumber     : TCrSortFieldsNumber;
    FField      : string;
    FDirection  : TCrSortDirection;
    FDeleteSF   : boolean;
  protected
  published
  public
    constructor Create;
  end; { TCrpeSortFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSortFields                                                        }
{------------------------------------------------------------------------------}
   TCrpeSortFields = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrSortFieldsNumber;
      procedure SetNumber (const Value: TCrSortFieldsNumber);
      function  GetField: string;
      procedure SetField (const Value: string);
      function  GetDirection : TCrSortDirection;
      procedure SetDirection (const Value: TCrSortDirection);
      function  GetDelete : boolean;
      procedure SetDelete (const Value: boolean);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSortFields;
      function  ListItem(nIndex: integer) : TCrpeSortFieldsItem;
   published
      property Number : TCrSortFieldsNumber
          read GetNumber
         write SetNumber;
      property Field : string
          read GetField
         write SetField;
      property Direction : TCrSortDirection
          read GetDirection
         write SetDirection
       default sdDefault;
      property DeleteSF : boolean
          read GetDelete
         write SetDelete
       default False;
   public
     Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeSortFields
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (SortFieldNumber: TCrSortFieldsNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (SortFieldNumber: TCrSortFieldsNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeSortFields);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSortFields }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupSortFieldsItem                                               }
{------------------------------------------------------------------------------}
   TCrpeGroupSortFieldsItem = class(TObject)
   private
      FNumber     : TCrGroupSortFieldsNumber;
      FField      : string;
      FDirection  : TCrSortDirection;
      FDeleteGSF  : Boolean;
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeGroupSortFields                                                   }
{------------------------------------------------------------------------------}
   TCrpeGroupSortFields = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGroupSortFieldsNumber;
      procedure SetNumber (const Value: TCrGroupSortFieldsNumber);
      function  GetField : string;
      procedure SetField (const Value: string);
      function  GetDirection : TCrSortDirection;
      procedure SetDirection (const Value: TCrSortDirection);
      function  GetDelete : boolean;
      procedure SetDelete (const Value: boolean);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGroupSortFields;
      function  ListItem(nIndex: integer) : TCrpeGroupSortFieldsItem;
   published
      property Number : TCrGroupSortFieldsNumber
          read GetNumber
         write SetNumber;
      property Field : string
          read GetField
         write SetField;
      property Direction : TCrSortDirection
          read GetDirection
         write SetDirection
       default sdDefault;
      property DeleteGSF : boolean
          read GetDelete
         write SetDelete
       default False;
   public
     Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGroupSortFields
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GroupSortFieldNumber: TCrGroupSortFieldsNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (GroupSortFieldNumber: TCrGroupSortFieldsNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGroupSortFields);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupSortFields }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupConditionItem                                                }
{------------------------------------------------------------------------------}
   TCrpeGroupConditionItem = class(TObject)
   private
      FNumber     : TCrGroupConditionNumber;
      FField      : string;
      FCondition  : TCrGroupCondition;
      FDirection  : TCrGroupDirection;
      FGroupType  : TCrGroupType;
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeGroupCondition                                                    }
{------------------------------------------------------------------------------}
   TCrpeGroupCondition = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGroupConditionNumber;
      procedure SetNumber (const Value: TCrGroupConditionNumber);
      function  GetField : string;
      procedure SetField (const Value: string);
      function  GetGroupType : TCrGroupType;
      procedure SetGroupType (const Value: TCrGroupType);
      function  GetCondition : TCrGroupCondition;
      procedure SetCondition (const Value: TCrGroupCondition);
      function  GetDirection : TCrGroupDirection;
      procedure SetDirection (const Value: TCrGroupDirection);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGroupCondition;
      function  ListItem(nIndex: integer) : TCrpeGroupConditionItem;
   published
      property Number : TCrGroupConditionNumber
          read GetNumber
         write SetNumber;
      property Field : string
          read GetField
         write SetField;
      property Condition : TCrGroupCondition
          read GetCondition
         write SetCondition
       default AnyChange;
      property Direction : TCrGroupDirection
          read GetDirection
         write SetDirection
       default gdDefault;
      property GroupType : TCrGroupType
          read GetGroupType
         write SetGroupType;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGroupCondition
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count: integer;
     procedure Clear;
     function  Add (GroupNumber: TCrGroupConditionNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GroupNumber: TCrGroupConditionNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGroupCondition);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupCondition }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupOptionsItem                                                  }
{------------------------------------------------------------------------------}
  TCrpeGroupOptionsItem = class(TObject)
  private
    FNumber            : TCrGroupOptionsNumber;
    FField             : string;
    FCondition         : TCrGroupCondition;
    FDirection         : TCrGroupDirection;
    FGroupType         : TCrGroupType;
    FRepeatGH          : TCrBoolean;
    FKeepTogether      : TCrBoolean;
    FTopNOptions       : TCrTopNOptions;
    FTopNGroups        : Smallint;
    FTopNSortField     : string;
    FTopNDiscardOthers : TCrBoolean;
  protected
  published
  public
    constructor Create;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeGroupOptions                                                      }
{------------------------------------------------------------------------------}
   TCrpeGroupOptions = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGroupOptionsNumber;
      procedure SetNumber (const Value: TCrGroupOptionsNumber);
      function  GetField : string;
      procedure SetField (const Value: string);
      function  GetGroupType : TCrGroupType;
      procedure SetGroupType (const Value: TCrGroupType);
      function  GetCondition : TCrGroupCondition;
      procedure SetCondition (const Value: TCrGroupCondition);
      function  GetDirection : TCrGroupDirection;
      procedure SetDirection (const Value: TCrGroupDirection);
      function  GetRepeatGH : TCrBoolean;
      procedure SetRepeatGH (const Value: TCrBoolean);
      function  GetKeepTogether : TCrBoolean;
      procedure SetKeepTogether (const Value: TCrBoolean);
      function  GetTopNOptions : TCrTopNOptions;
      procedure SetTopNOptions (const Value: TCrTopNOptions);
      function  GetTopNGroups : smallint;
      procedure SetTopNGroups (const Value: smallint);
      function  GetTopNSortField : string;
      procedure SetTopNSortField (const Value: string);
      function  GetTopNDiscardOthers : TCrBoolean;
      procedure SetTopNDiscardOthers (const Value: TCrBoolean);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGroupOptions;
      function  ListItem(nIndex: integer): TCrpeGroupOptionsItem;
   published
      property Number : TCrGroupOptionsNumber
          read GetNumber
         write SetNumber;
      property Field : string
          read GetField
         write SetField;
      property Condition : TCrGroupCondition
          read GetCondition
         write SetCondition
       default AnyChange;
      property Direction : TCrGroupDirection
          read GetDirection
         write SetDirection
       default gdDefault;
      property GroupType : TCrGroupType
          read GetGroupType
         write SetGroupType;
      property RepeatGH : TCrBoolean
          read GetRepeatGH
         write SetRepeatGH;
      property KeepTogether : TCrBoolean
          read GetKeepTogether
         write SetKeepTogether;
      property TopNOptions : TCrTopNOptions
          read GetTopNOptions
         write SetTopNOptions;
      property TopNGroups : smallint
          read GetTopNGroups
         write SetTopNGroups;
      property TopNSortField : string
          read GetTopNSortField
         write SetTopNSortField;
      property TopNDiscardOthers : TCrBoolean
          read GetTopNDiscardOthers
         write SetTopNDiscardOthers;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGroupOptions
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count: integer;
     procedure Clear;
     function  Add (GroupNumber: TCrGroupOptionsNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GroupNumber : TCrGroupOptionsNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGroupOptions);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupOptions }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormatItem                                                 }
{------------------------------------------------------------------------------}
  TCrpeSectionFormatItem = class(TObject)
  private
    FSection              : TCrSectionFormatSection;
    FSuppress             : TCrBoolean;
    FNewPageBefore        : TCrBoolean;
    FNewPageAfter         : TCrBoolean;
    FKeepTogether         : TCrBoolean;
    FSuppressBlankSection : TCrBoolean;
    FResetPageNAfter      : TCrBoolean;
    FPrintAtBottomOfPage  : TCrBoolean;
    FBackgroundColor      : TColor;
    FUnderlaySection      : TCrBoolean;
    FFreeFormPlacement    : TCrBoolean;
  protected
  published
  public
    constructor Create;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormat                                                     }
{------------------------------------------------------------------------------}
  TCrpeSectionFormat = class(TPersistent)
  private
    FList   : TList;
    FIndex  : integer;
  protected
    function  GetSection : TCrSectionFormatSection;
    procedure SetSection (const Value: TCrSectionFormatSection);
    function  GetSuppress : TCrBoolean;
    procedure SetSuppress (const Value: TCrBoolean);
    function  GetNewPageBefore : TCrBoolean;
    procedure SetNewPageBefore (const Value: TCrBoolean);
    function  GetNewPageAfter : TCrBoolean;
    procedure SetNewPageAfter (const Value: TCrBoolean);
    function  GetKeepTogether : TCrBoolean;
    procedure SetKeepTogether (const Value: TCrBoolean);
    function  GetSuppressBlankSection : TCrBoolean;
    procedure SetSuppressBlankSection (const Value: TCrBoolean);
    function  GetResetPageNAfter : TCrBoolean;
    procedure SetResetPageNAfter (const Value: TCrBoolean);
    function  GetPrintAtBottomOfPage : TCrBoolean;
    procedure SetPrintAtBottomOfPage (const Value: TCrBoolean);
    function  GetBackgroundColor : TColor;
    procedure SetBackgroundColor (const Value: TColor);
    function  GetUnderlaySection : TCrBoolean;
    procedure SetUnderlaySection (const Value: TCrBoolean);
    function  GetFreeFormPlacement : TCrBoolean;
    procedure SetFreeFormPlacement (const Value: TCrBoolean);
    function  GetSectionAsCode : smallint;
    procedure SetSectionAsCode (const Value: smallint);
    function  GetIndex : integer;
    procedure SetIndex (const nIndex: integer);
    function  GetItem(nIndex: integer) : TCrpeSectionFormat;
    function  ListItem(nIndex: integer): TCrpeSectionFormatItem;
  published
    property Section : TCrSectionFormatSection
        read GetSection
       write SetSection;
    property Suppress : TCrBoolean
        read GetSuppress
       write SetSuppress
     default cDefault;
    property NewPageBefore : TCrBoolean
        read GetNewPageBefore
       write SetNewPageBefore
     default cDefault;
    property NewPageAfter : TCrBoolean
        read GetNewPageAfter
       write SetNewPageAfter
     default cDefault;
    property KeepTogether : TCrBoolean
        read GetKeepTogether
       write SetKeepTogether
     default cDefault;
    property SuppressBlankSection : TCrBoolean
        read GetSuppressBlankSection
       write SetSuppressBlankSection
     default cDefault;
    property ResetPageNAfter : TCrBoolean
        read GetResetPageNAfter
       write SetResetPageNAfter
     default cDefault;
    property PrintAtBottomOfPage : TCrBoolean
        read GetPrintAtBottomOfPage
       write SetPrintAtBottomOfPage
     default cDefault;
    property BackgroundColor : TColor
        read GetBackgroundColor
       write SetBackgroundColor
     default -2;
    property UnderlaySection : TCrBoolean
        read GetUnderlaySection
       write SetUnderlaySection
     default cDefault;
    property FreeFormPlacement : TCrBoolean
        read GetFreeFormPlacement
       write SetFreeFormPlacement
     default cDefault;
  public
    Cr : TCrpe;
    property ItemIndex : integer
        read GetIndex
       write SetIndex;
    property Item[nIndex: integer]: TCrpeSectionFormat
        read GetItem; default;
    property SectionAsCode: smallint
        read GetSectionAsCode
       write SetSectionAsCode;
    function  SectionType : string;
    function  Retrieve : boolean;
    function  Count: integer;
    procedure Clear;
    function  Add (SectionName: TCrSectionFormatSection): integer;
    procedure Delete (nIndex: integer);
    function  Send : boolean;
    function  IndexOf (SectionName: TCrSectionFormatSection): integer;
    procedure CopyFrom (Source: TCrpeSectionFormat);
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeSectionFormat }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormatFormulasItem                                         }
{------------------------------------------------------------------------------}
   TCrpeSectionFormatFormulasItem = class(TObject)
   private
      FSection              : TCrSectionFormatFormulasSection;
      FSuppress             : TCrpeString;
      FNewPageBefore        : TCrpeString;
      FNewPageAfter         : TCrpeString;
      FKeepTogether         : TCrpeString;
      FSuppressBlankSection : TCrpeString;
      FResetPageNAfter      : TCrpeString;
      FPrintAtBottomOfPage  : TCrpeString;
      FBackgroundColor      : TCrpeString;
      FUnderlaySection      : TCrpeString;
   protected
   published
   public
     constructor Create;
     destructor Destroy; override;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormatFormulas                                             }
{------------------------------------------------------------------------------}
   TCrpeSectionFormatFormulas = class(TPersistent)
   private
      FList  : TList;
      sTemp  : TCrpeString;
      FIndex : integer;
   protected
      function  GetSection : TCrSectionFormatFormulasSection;
      procedure SetSection (const Value: TCrSectionFormatFormulasSection);
      function  GetSuppress : TCrpeString;
      procedure SetSuppress (const Value: TCrpeString);
      function  GetNewPageBefore : TCrpeString;
      procedure SetNewPageBefore (const Value: TCrpeString);
      function  GetNewPageAfter : TCrpeString;
      procedure SetNewPageAfter (const Value: TCrpeString);
      function  GetKeepTogether : TCrpeString;
      procedure SetKeepTogether (const Value: TCrpeString);
      function  GetSuppressBlankSection : TCrpeString;
      procedure SetSuppressBlankSection (const Value: TCrpeString);
      function  GetResetPageNAfter : TCrpeString;
      procedure SetResetPageNAfter (const Value: TCrpeString);
      function  GetPrintAtBottomOfPage : TCrpeString;
      procedure SetPrintAtBottomOfPage (const Value: TCrpeString);
      function  GetBackgroundColor : TCrpeString;
      procedure SetBackgroundColor (const Value: TCrpeString);
      function  GetUnderlaySection : TCrpeString;
      procedure SetUnderlaySection (const Value: TCrpeString);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSectionFormatFormulas;
      function  ListItem(nIndex: integer) : TCrpeSectionFormatFormulasItem;
   published
      property Section : TCrSectionFormatFormulasSection
          read GetSection
         write SetSection;
      property Suppress : TCrpeString
          read GetSuppress
         write SetSuppress;
      property NewPageBefore : TCrpeString
          read GetNewPageBefore
         write SetNewPageBefore;
      property NewPageAfter : TCrpeString
          read GetNewPageAfter
         write SetNewPageAfter;
      property KeepTogether : TCrpeString
          read GetKeepTogether
         write SetKeepTogether;
      property SuppressBlankSection : TCrpeString
          read GetSuppressBlankSection
         write SetSuppressBlankSection;
      property ResetPageNAfter : TCrpeString
          read GetResetPageNAfter
         write SetResetPageNAfter;
      property PrintAtBottomOfPage : TCrpeString
          read GetPrintAtBottomOfPage
         write SetPrintAtBottomOfPage;
      property BackgroundColor : TCrpeString
          read GetBackgroundColor
         write SetBackgroundColor;
      property UnderlaySection : TCrpeString
          read GetUnderlaySection
         write SetUnderlaySection;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeSectionFormatFormulas
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (SectionName: TCrSectionFormatFormulasSection): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (SectionName: TCrSectionFormatFormulasSection): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeSectionFormatFormulas);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSectionFormatFormulas }

{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormatItem                                                    }
{------------------------------------------------------------------------------}
  TCrpeAreaFormatItem = class(TObject)
  private
    FSection             : TCrAreaFormatSection;
    FHide                : TCrBoolean;
    FNewPageBefore       : TCrBoolean;
    FNewPageAfter        : TCrBoolean;
    FKeepTogether        : TCrBoolean;
    FResetPageNAfter     : TCrBoolean;
    FPrintAtBottomOfPage : TCrBoolean;
    FSuppress            : TCrBoolean;
  protected
  published
  public
    constructor Create;
  end; { Class TCrpeAreaFormatItem }

{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormat                                                        }
{------------------------------------------------------------------------------}
  TCrpeAreaFormat = class(TPersistent)
  private
    FList   : TList;
    FIndex  : integer;
  protected
    function  GetSection : TCrAreaFormatSection;
    procedure SetSection (const Value: TCrAreaFormatSection);
    function  GetHide : TCrBoolean;
    procedure SetHide (const Value: TCrBoolean);
    function  GetNewPageBefore : TCrBoolean;
    procedure SetNewPageBefore (const Value: TCrBoolean);
    function  GetNewPageAfter : TCrBoolean;
    procedure SetNewPageAfter (const Value: TCrBoolean);
    function  GetKeepTogether : TCrBoolean;
    procedure SetKeepTogether (const Value: TCrBoolean);
    function  GetResetPageNAfter : TCrBoolean;
    procedure SetResetPageNAfter (const Value: TCrBoolean);
    function  GetPrintAtBottomOfPage : TCrBoolean;
    procedure SetPrintAtBottomOfPage (const Value: TCrBoolean);
    function  GetSuppress : TCrBoolean;
    procedure SetSuppress (const Value: TCrBoolean);
    function  GetSectionAsCode : smallint;
    procedure SetSectionAsCode (const Value: smallint);
    function  GetIndex : integer;
    procedure SetIndex (const nIndex: integer);
    function  GetItem(nIndex: integer) : TCrpeAreaFormat;
    function  ListItem(nIndex: integer): TCrpeAreaFormatItem;
  published
    property Section : TCrAreaFormatSection
        read GetSection
       write SetSection;
    property Hide : TCrBoolean
        read GetHide
       write SetHide
     default cDefault;
    property NewPageBefore : TCrBoolean
        read GetNewPageBefore
       write SetNewPageBefore
     default cDefault;
    property NewPageAfter : TCrBoolean
        read GetNewPageAfter
       write SetNewPageAfter
     default cDefault;
    property KeepTogether : TCrBoolean
        read GetKeepTogether
       write SetKeepTogether
     default cDefault;
    property ResetPageNAfter : TCrBoolean
        read GetResetPageNAfter
       write SetResetPageNAfter
     default cDefault;
    property PrintAtBottomOfPage : TCrBoolean
        read GetPrintAtBottomOfPage
       write SetPrintAtBottomOfPage
     default cDefault;
    property Suppress : TCrBoolean
        read GetSuppress
       write SetSuppress
     default cDefault;
  public
    Cr : TCrpe;
    property ItemIndex : integer
        read GetIndex
       write SetIndex;
    property Item[nIndex: integer]: TCrpeAreaFormat
        read GetItem; default;
    property SectionAsCode: smallint
        read GetSectionAsCode
       write SetSectionAsCode;
    function  SectionType : string;
    function  Retrieve : boolean;
    function  Count: integer;
    procedure Clear;
    function  Add (SectionName: TCrAreaFormatSection): integer;
    procedure Delete (nIndex: integer);
    function  Send : boolean;
    function  IndexOf (SectionName: TCrAreaFormatSection): integer;
    procedure CopyFrom (Source: TCrpeAreaFormat);
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeAreaFormat }

{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormatFormulasItem                                            }
{------------------------------------------------------------------------------}
  TCrpeAreaFormatFormulasItem = class(TObject)
  private
    FSection             : TCrAreaFormatSection;
    FSuppress            : TCrpeString;
    FHide                : TCrpeString;
    FNewPageBefore       : TCrpeString;
    FNewPageAfter        : TCrpeString;
    FKeepTogether        : TCrpeString;
    FResetPageNAfter     : TCrpeString;
    FPrintAtBottomOfPage : TCrpeString;
  protected
  published
  public
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeAreaFormatFormulasItem }

{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormatFormulas                                                }
{------------------------------------------------------------------------------}
   TCrpeAreaFormatFormulas = class(TPersistent)
   private
      FList  : TList;
      sTemp  : TCrpeString;
      FIndex : integer;
   protected
      function  GetSection : TCrAreaFormatFormulasSection;
      procedure SetSection (const Value: TCrAreaFormatFormulasSection);
      function  GetHide : TCrpeString;
      procedure SetHide (const Value: TCrpeString);
      function  GetNewPageBefore : TCrpeString;
      procedure SetNewPageBefore (const Value: TCrpeString);
      function  GetNewPageAfter : TCrpeString;
      procedure SetNewPageAfter (const Value: TCrpeString);
      function  GetKeepTogether : TCrpeString;
      procedure SetKeepTogether (const Value: TCrpeString);
      function  GetResetPageNAfter : TCrpeString;
      procedure SetResetPageNAfter (const Value: TCrpeString);
      function  GetPrintAtBottomOfPage : TCrpeString;
      procedure SetPrintAtBottomOfPage (const Value: TCrpeString);
      function  GetSuppress : TCrpeString;
      procedure SetSuppress (const Value: TCrpeString);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeAreaFormatFormulas;
      function  ListItem(nIndex: integer) : TCrpeAreaFormatFormulasItem;
   published
      property Section : TCrAreaFormatFormulasSection
          read GetSection
         write SetSection;
      property Hide : TCrpeString
          read GetHide
         write SetHide;
      property NewPageBefore : TCrpeString
          read GetNewPageBefore
         write SetNewPageBefore;
      property NewPageAfter : TCrpeString
          read GetNewPageAfter
         write SetNewPageAfter;
      property KeepTogether : TCrpeString
          read GetKeepTogether
         write SetKeepTogether;
      property ResetPageNAfter : TCrpeString
          read GetResetPageNAfter
         write SetResetPageNAfter;
      property PrintAtBottomOfPage : TCrpeString
          read GetPrintAtBottomOfPage
         write SetPrintAtBottomOfPage;
      property Suppress : TCrpeString
          read GetSuppress
         write SetSuppress;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeAreaFormatFormulas
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (SectionName: TCrAreaFormatFormulasSection): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (SectionName: TCrAreaFormatFormulasSection): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeAreaFormatFormulas);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeAreaFormatFormulas }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFontItem                                                   }
{------------------------------------------------------------------------------}
  TCrpeSectionFontItem = class(TObject)
  private
    FSection       : TCrSectionFontSection;
    FScope         : TCrFontScope;
    FName          : TFontName;
    FPitch         : TFontPitch;
    FFamily        : TCrFontFamily;
    FCharSet       : TCrFontCharSet;
    FSize          : Smallint;
    FItalic        : TCrBoolean;
    FUnderlined    : TCrBoolean;
    FStrikeThrough : TCrBoolean;
    FWeight        : TCrFontWeight;
  protected
  published
  public
    constructor Create;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFont                                                       }
{------------------------------------------------------------------------------}
   TCrpeSectionFont = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetSection : TCrSectionFontSection;
      procedure SetSection (const Value: TCrSectionFontSection);
      function  GetScope : TCrFontScope;
      procedure SetScope (const Value: TCrFontScope);
      function  GetName : TFontName;
      procedure SetName (const Value: TFontName);
      function  GetPitch : TFontPitch;
      procedure SetPitch (const Value: TFontPitch);
      function  GetFamily : TCrFontFamily;
      procedure SetFamily (const Value: TCrFontFamily);
      function  GetCharSet : TCrFontCharSet;
      procedure SetCharSet (const Value: TCrFontCharSet);
      function  GetSize : smallint;
      procedure SetSize (const Value: smallint);
      function  GetItalic : TCrBoolean;
      procedure SetItalic (const Value: TCrBoolean);
      function  GetUnderlined : TCrBoolean;
      procedure SetUnderlined (const Value: TCrBoolean);
      function  GetStrikeThrough : TCrBoolean;
      procedure SetStrikeThrough (const Value: TCrBoolean);
      function  GetWeight : TCrFontWeight;
      procedure SetWeight (const Value: TCrFontWeight);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSectionFont;
      function  ListItem(nIndex: integer): TCrpeSectionFontItem;
   published
      property Section : TCrSectionFontSection
          read GetSection
         write SetSection;
      property Scope : TCrFontScope
          read GetScope
         write SetScope
       default fsBoth;
      property Name  : TFontName
          read GetName
         write SetName;
      property Pitch : TFontPitch
          read GetPitch
         write SetPitch
       default fpDefault;
      property Family : TCrFontFamily
          read GetFamily
         write SetFamily
       default ffDefault;
      property CharSet : TCrFontCharSet
          read GetCharSet
         write SetCharSet
       default fcDefault;
      property Size : smallint
          read GetSize
         write SetSize
       default 0;
      property Italic : TCrBoolean
          read GetItalic
         write SetItalic
       default cDefault;
      property Underlined : TCrBoolean
          read GetUnderlined
         write SetUnderlined
       default cDefault;
      property StrikeThrough : TCrBoolean
          read GetStrikeThrough
         write SetStrikeThrough
       default cDefault;
      property Weight : TCrFontWeight
          read GetWeight
         write SetWeight
       default fwDefault;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeSectionFont
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean; {Gets sections only: no PEGetFont call}
     function  Count: integer;
     procedure Clear;
     function  Add (SectionName: TCrSectionFontSection): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (SectionName: TCrSectionFontSection): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeSectionFont);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSectionFont }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionHeightItem                                                 }
{------------------------------------------------------------------------------}
   TCrpeSectionHeightItem = class(TObject)
   private
      FSection : TCrSectionHeightSection;
      FHeight  : smallint;  {in twips: 1440 twips per inch}
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeSectionHeight                                                     }
{------------------------------------------------------------------------------}
   TCrpeSectionHeight = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetSection : TCrSectionHeightSection;
      procedure SetSection (const Value: TCrSectionHeightSection);
      function  GetHeight : smallint;
      procedure SetHeight (const Value: smallint);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSectionHeight;
      function  ListItem(nIndex: integer) : TCrpeSectionHeightItem;
   published
      property Section : TCrSectionHeightSection
          read GetSection
         write SetSection;
      property Height : smallint
          read GetHeight
         write SetHeight;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeSectionHeight
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count: integer;
     procedure Clear;
     function  Add (SectionName: TCrSectionHeightSection): integer;
     procedure Delete (nIndex: integer);
     function  Send : boolean;
     function  IndexOf (SectionName: TCrSectionHeightSection): integer;
     procedure CopyFrom (Source: TCrpeSectionHeight);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSectionHeight }

{------------------------------------------------------------------------------}
{ Class TCrpeSessionInfoItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeSessionInfoItem = class(TObject)
   private
      FTable         : TCrSessionInfoTable;
      FUserID        : string;
      FDBPassword    : string;
      FUserPassword  : string;
      FHandle        : DWord;
   protected
   published
   public
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeSessionInfo                                                       }
{   - Ms Access Only                                                           }
{------------------------------------------------------------------------------}
   TCrpeSessionInfo = class(TPersistent)
   private
      FList      : TList;
      FPropagate : boolean;
      FIndex     : integer;
   protected
      function  GetTable : TCrSessionInfoTable;
      procedure SetTable (const Value: TCrSessionInfoTable);
      function  GetUserID : string;
      procedure SetUserID (const Value: string);
      function  GetDBPassword : string;
      procedure SetDBPassword (const Value: string);
      function  GetUserPassword : string;
      procedure SetUserPassword (const Value: string);
      function  GetHandle : DWord;
      procedure SetHandle (const Value: DWord);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSessionInfo;
      function  ListItem(nIndex: integer) : TCrpeSessionInfoItem;
   published
      property Table : TCrSessionInfoTable
          read GetTable
         write SetTable;
      property UserID : string
          read GetUserID
         write SetUserID;
      property DBPassword : string
          read GetDBPassword
         write SetDBPassword;
      property UserPassword : string
          read GetUserPassword
         write SetUserPassword;
      property Propagate : boolean
          read FPropagate
         write FPropagate;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Handle : DWord
          read GetHandle
         write SetHandle;
      property Item[nIndex: integer]: TCrpeSessionInfo
          read GetItem; default;
     function  Retrieve : boolean;
     function  Count: integer;
     procedure Clear;
     function  Add (TableNumber: TCrSessionInfoTable): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (TableNumber: TCrSessionInfoTable): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeSessionInfo);
     function  Test : boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSessionInfo }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphTypeItem                                                     }
{------------------------------------------------------------------------------}
  TCrpeGraphTypeItem = class(TObject)
  private
    FNumber           : TCrGraphTypeNumber;
    FSectionGraphNum  : Smallint;
    FSection          : string;
    FStyle            : TCrGraphType;
  protected
  published
  public
    constructor Create;
  end; { TCrpeGraphTypeItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphType                                                         }
{------------------------------------------------------------------------------}
   TCrpeGraphType = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGraphTypeNumber;
      procedure SetNumber (const Value: TCrGraphTypeNumber);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      function  GetStyle : TCrGraphType;
      procedure SetStyle (const Value: TCrGraphType);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetSectionGraphNum : smallint;
      procedure SetSectionGraphNum (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGraphType;
      function  GetGraphType (nGraphType, nSubType: smallint): TCrGraphType;
      procedure GetGraphTypeConst (xGraphType: TCrGraphType;
        var nGraphType: smallint; var nSubType: smallint);
      function  ListItem(nIndex: integer): TCrpeGraphTypeItem;
   published
      property Number : TCrGraphTypeNumber
          read GetNumber
         write SetNumber;
      property Section : string
          read GetSection
         write SetSection;
      property Style : TCrGraphType
          read GetStyle
         write SetStyle;
   public
      Cr : TCrpe;
      property SectionGraphNum : smallint
          read GetSectionGraphNum
         write SetSectionGraphNum;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGraphType
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GraphNumber: TCrGraphTypeNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GraphNumber : TCrGraphTypeNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGraphType);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphType }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphDataItem                                                     }
{------------------------------------------------------------------------------}
  TCrpeGraphDataItem = class(TObject)
  private
    FNumber           : TCrGraphDataNumber;
    FSectionGraphNum  : Smallint;
    FSection          : string;
    FRowGroupN        : Smallint;
    FColGroupN        : Smallint;
    FSummarizedFieldN : Smallint;
    FDirection        : TCrGraphDirection;
  protected
  published
  public
    constructor Create;
  end; { TCrpeGraphDataItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphData                                                         }
{   - for SCR5 & 6                                                             }
{------------------------------------------------------------------------------}
   TCrpeGraphData = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGraphDataNumber;
      procedure SetNumber (const Value: TCrGraphDataNumber);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      function  GetRowGroupN : smallint;
      procedure SetRowGroupN (const Value: smallint);
      function  GetColGroupN : smallint;
      procedure SetColGroupN (const Value: smallint);
      function  GetSummarizedFieldN : smallint;
      procedure SetSummarizedFieldN (const Value: smallint);
      function  GetDirection : TCrGraphDirection;
      procedure SetDirection (const Value: TCrGraphDirection);
      function  GetSectionGraphNum : smallint;
      procedure SetSectionGraphNum (const Value: smallint);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGraphData;
      function  ListItem(nIndex: integer): TCrpeGraphDataItem;
   published
      property Number : TCrGraphDataNumber
          read GetNumber
         write SetNumber;
      property Section : string
          read GetSection
         write SetSection;
      property RowGroupN : smallint
          read GetRowGroupN
         write SetRowGroupN;
      property ColGroupN : smallint
          read GetColGroupN
         write SetColGroupN;
      property SummarizedFieldN : smallint
          read GetSummarizedFieldN
         write SetSummarizedFieldN;
      property Direction : TCrGraphDirection
          read GetDirection
         write SetDirection;
   public
      Cr : TCrpe;
      property SectionGraphNum : smallint
          read GetSectionGraphNum
         write SetSectionGraphNum;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGraphData
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GraphNumber: TCrGraphDataNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GraphNumber: TCrGraphDataNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGraphData);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphData }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphTextItem                                                     }
{------------------------------------------------------------------------------}
  TCrpeGraphTextItem = class(TObject)
  private
    FNumber           : TCrGraphTextNumber;
    FSectionGraphNum  : Smallint;
    FSection          : string;
    FTitle            : TCrGraphTextType;
    FSubTitle         : TCrGraphTextType;
    FFootNote         : TCrGraphTextType;
    FGroupsTitle      : TCrGraphTextType;
    FSeriesTitle      : TCrGraphTextType;
    FXAxisTitle       : TCrGraphTextType;
    FYAxisTitle       : TCrGraphTextType;
    FZAxisTitle       : TCrGraphTextType;
    FTitleFont        : TFont;
    FSubTitleFont     : TFont;
    FFootNoteFont     : TFont;
    FGroupsTitleFont  : TFont;
    FDataTitleFont    : TFont;
    FLegendFont       : TFont;
    FGroupLabelsFont  : TFont;
    FDataLabelsFont   : TFont;
  protected
  published
  public
    constructor Create;
    destructor Destroy; override;
  end; { TCrpeGraphTextItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphText                                                         }
{------------------------------------------------------------------------------}
   TCrpeGraphText = class(TPersistent)
   private
      FList  : TList;
      FFont  : TFont; {temporary font for default}
      FIndex : integer;
   protected
      function GetNumber : TCrGraphTextNumber;
      procedure SetNumber (const Value: TCrGraphTextNumber);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      {Text properties}
      function  GetTitle : TCrGraphTextType;
      procedure SetTitle (const Value: TCrGraphTextType);
      function  GetSubTitle : TCrGraphTextType;
      procedure SetSubTitle (const Value: TCrGraphTextType);
      function  GetFootNote : TCrGraphTextType;
      procedure SetFootNote (const Value: TCrGraphTextType);
      function  GetGroupsTitle : TCrGraphTextType;
      procedure SetGroupsTitle (const Value: TCrGraphTextType);
      function  GetSeriesTitle : TCrGraphTextType;
      procedure SetSeriesTitle (const Value: TCrGraphTextType);
      function  GetXAxisTitle : TCrGraphTextType;
      procedure SetXAxisTitle (const Value: TCrGraphTextType);
      function  GetYAxisTitle : TCrGraphTextType;
      procedure SetYAxisTitle (const Value: TCrGraphTextType);
      function  GetZAxisTitle : TCrGraphTextType;
      procedure SetZAxisTitle (const Value: TCrGraphTextType);
      {Font properties for SCR7+}
      function  GetTitleFont : TFont;
      procedure SetTitleFont (const Value: TFont);
      function  GetSubTitleFont : TFont;
      procedure SetSubTitleFont (const Value: TFont);
      function  GetFootNoteFont : TFont;
      procedure SetFootNoteFont (const Value: TFont);
      function  GetGroupsTitleFont : TFont;
      procedure SetGroupsTitleFont (const Value: TFont);
      function  GetDataTitleFont : TFont;
      procedure SetDataTitleFont (const Value: TFont);
      function  GetLegendFont : TFont;
      procedure SetLegendFont (const Value: TFont);
      function  GetGroupLabelsFont : TFont;
      procedure SetGroupLabelsFont (const Value: TFont);
      function  GetDataLabelsFont : TFont;
      procedure SetDataLabelsFont (const Value: TFont);
      {Others}
      function  GetSectionGraphNum : smallint;
      procedure SetSectionGraphNum (const Value: smallint);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGraphText;
      function  ListItem(nIndex: integer): TCrpeGraphTextItem;
   published
      property Number : TCrGraphTextNumber
          read GetNumber
         write SetNumber;
      property Section : string
          read GetSection
         write SetSection;
      property Title : TCrGraphTextType
          read GetTitle
         write SetTitle;
      property SubTitle : TCrGraphTextType
          read GetSubTitle
         write SetSubTitle;
      property FootNote : TCrGraphTextType
          read GetFootNote
         write SetFootNote;
      property GroupsTitle : TCrGraphTextType
          read GetGroupsTitle
         write SetGroupsTitle;
      property SeriesTitle : TCrGraphTextType
          read GetSeriesTitle
         write SetSeriesTitle;
      property XAxisTitle : TCrGraphTextType
          read GetXAxisTitle
         write SetXAxisTitle;
      property YAxisTitle : TCrGraphTextType
          read GetYAxisTitle
         write SetYAxisTitle;
      property ZAxisTitle : TCrGraphTextType
          read GetZAxisTitle
         write SetZAxisTitle;
      {Font properties for SCR7+}
      property TitleFont : TFont
          read GetTitleFont
         write SetTitleFont;
      property SubTitleFont : TFont
          read GetSubTitleFont
         write SetSubTitleFont;
      property FootNoteFont : TFont
          read GetFootNoteFont
         write SetFootNoteFont;
      property GroupsTitleFont : TFont
          read GetGroupsTitleFont
         write SetGroupsTitleFont;
      property DataTitleFont : TFont
          read GetDataTitleFont
         write SetDataTitleFont;
      property LegendFont : TFont
          read GetLegendFont
         write SetLegendFont;
      property GroupLabelsFont : TFont
          read GetGroupLabelsFont
         write SetGroupLabelsFont;
      property DataLabelsFont : TFont
          read GetDataLabelsFont
         write SetDataLabelsFont;
   public
      Cr : TCrpe;
      property SectionGraphNum : smallint
          read GetSectionGraphNum
         write SetSectionGraphNum;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGraphText
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GraphNumber: TCrGraphTextNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GraphNumber: TCrGraphTextNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGraphText);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphText }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphOptionsItem                                                  }
{------------------------------------------------------------------------------}
  TCrpeGraphOptionsItem = class(TObject)
  private
    FNumber           : TCrGraphOptionsNumber;
    FSectionGraphNum  : Smallint;
    FSection          : string;
    FMax              : double;
    FMin              : double;
    FDataValues       : TCrBoolean;
    FGridLines        : TCrBoolean;
    FLegend           : TCrBoolean;
    FBarDirection     : TCrGraphBarDirection;
    FFont             : TFontName;
  protected
  published
  public
    constructor Create;
  end; { TCrpeGraphOptionsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphOptions                                                      }
{------------------------------------------------------------------------------}
   TCrpeGraphOptions = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGraphOptionsNumber;
      procedure SetNumber (const Value: TCrGraphOptionsNumber);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      function  GetMax : double;
      procedure SetMax (const Value: Double);
      function  GetMin : double;
      procedure SetMin (const Value: Double);
      function  GetDataValues : TCrBoolean;
      procedure SetDataValues (const Value: TCrBoolean);
      function  GetGridLines : TCrBoolean;
      procedure SetGridLines (const Value: TCrBoolean);
      function  GetLegend : TCrBoolean;
      procedure SetLegend (const Value: TCrBoolean);
      function  GetBarDirection : TCrGraphBarDirection;
      procedure SetBarDirection (const Value: TCrGraphBarDirection);
      function  GetFont : TFontName;
      procedure SetFont (const Value: TFontName);
      function  GetSectionGraphNum : smallint;
      procedure SetSectionGraphNum (const Value: smallint);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGraphOptions;
      function  ListItem(nIndex: integer): TCrpeGraphOptionsItem;
   published
      property Number : TCrGraphOptionsNumber
          read GetNumber
         write SetNumber;
      property Section : string
          read GetSection
         write SetSection;
      property Max : double
          read GetMax
         write SetMax;
      property Min : double
          read GetMin
         write SetMin;
      property DataValues : TCrBoolean
          read GetDataValues
         write SetDataValues;
      property GridLines : TCrBoolean
          read GetGridLines
         write SetGridLines;
      property Legend : TCrBoolean
          read GetLegend
         write SetLegend;
      property BarDirection : TCrGraphBarDirection
          read GetBarDirection
         write SetBarDirection;
      property Font : TFontName
          read GetFont
         write SetFont;
   public
      Cr : TCrpe;
      property SectionGraphNum : smallint
          read GetSectionGraphNum
         write SetSectionGraphNum;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGraphOptions
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GraphNumber: TCrGraphOptionsNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GraphNumber: TCrGraphOptionsNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGraphOptions);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphOptions }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphOptionInfoItem                                               }
{------------------------------------------------------------------------------}
  TCrpeGraphOptionInfoItem = class(TObject)
  private
    FNumber           : TCrGraphOptionInfoNumber;
    FSectionGraphNum  : Smallint;
    FSection          : string;
    FColor            : TCrGraphColor;
    FLegend           : TCrGraphLegend; { showLegend and LegendPosition }
    { Pie Charts and Doughut Charts }
    FPieSize          : TCrGraphPieSize;
    FPieSlice         : TCrGraphPieSlice;
    { Bar Chart }
    FBarSize          : TCrGraphBarSize;
    FBarDirection     : TCrGraphBarDirection;
    { Markers (used for line and bar charts) }
    FMarkerSize       : TCrGraphMarkerSize;
    FMarkerShape      : TCrGraphMarkerShape;
    { Data Points }
    FDataPoints       : TCrGraphDataPoints;
    FNumberFormat     : TCrGraphNumberFormat;
    { 3D }
    FViewingAngle     : TCrGraphViewingAngle;
  protected
  published
  public
    constructor Create;
  end; { TCrpeGraphOptionInfoItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphOptionInfo                                                   }
{------------------------------------------------------------------------------}
   TCrpeGraphOptionInfo = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGraphOptionInfoNumber;
      procedure SetNumber (const Value: TCrGraphOptionInfoNumber);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      function  GetColor : TCrGraphColor;
      procedure SetColor (const Value: TCrGraphColor);
      function  GetLegend : TCrGraphLegend;
      procedure SetLegend (const Value: TCrGraphLegend);
      function  GetPieSize : TCrGraphPieSize;
      procedure SetPieSize (const Value: TCrGraphPieSize);
      function  GetPieSlice : TCrGraphPieSlice;
      procedure SetPieSlice (const Value: TCrGraphPieSlice);
      function  GetBarSize : TCrGraphBarSize;
      procedure SetBarSize (const Value: TCrGraphBarSize);
      function  GetBarDirection : TCrGraphBarDirection;
      procedure SetBarDirection (const Value: TCrGraphBarDirection);
      function  GetMarkerSize : TCrGraphMarkerSize;
      procedure SetMarkerSize (const Value: TCrGraphMarkerSize);
      function  GetMarkerShape : TCrGraphMarkerShape;
      procedure SetMarkerShape (const Value: TCrGraphMarkerShape);
      function  GetDataPoints : TCrGraphDataPoints;
      procedure SetDataPoints (const Value: TCrGraphDataPoints);
      function  GetNumberFormat : TCrGraphNumberFormat;
      procedure SetNumberFormat (const Value: TCrGraphNumberFormat);
      function  GetViewingAngle : TCrGraphViewingAngle;
      procedure SetViewingAngle (const Value: TCrGraphViewingAngle);
      function  GetSectionGraphNum : smallint;
      procedure SetSectionGraphNum (const Value: smallint);
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGraphOptionInfo;
      function  ListItem(nIndex: integer): TCrpeGraphOptionInfoItem;
   published
      property Number : TCrGraphOptionInfoNumber
          read GetNumber
         write SetNumber;
      property Section : string
          read GetSection
         write SetSection;
      property Color : TCrGraphColor
          read GetColor
         write SetColor;
      property Legend : TCrGraphLegend
          read GetLegend
         write SetLegend;
      property PieSize : TCrGraphPieSize
          read GetPieSize
         write SetPieSize;
      property PieSlice : TCrGraphPieSlice
          read GetPieSlice
         write SetPieSlice;
      property BarSize : TCrGraphBarSize
          read GetBarSize
         write SetBarSize;
      property BarDirection : TCrGraphBarDirection
          read GetBarDirection
         write SetBarDirection;
      property MarkerSize : TCrGraphMarkerSize
          read GetMarkerSize
         write SetMarkerSize;
      property MarkerShape : TCrGraphMarkerShape
          read GetMarkerShape
         write SetMarkerShape;
      property DataPoints : TCrGraphDataPoints
          read GetDataPoints
         write SetDataPoints;
      property NumberFormat : TCrGraphNumberFormat
          read GetNumberFormat
         write SetNumberFormat;
      property ViewingAngle : TCrGraphViewingAngle
          read GetViewingAngle
         write SetViewingAngle;
   public
      Cr : TCrpe;
      property SectionGraphNum : smallint
          read GetSectionGraphNum
         write SetSectionGraphNum;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGraphOptionInfo
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GraphNumber: TCrGraphOptionInfoNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GraphNumber : TCrGraphOptionInfoNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGraphOptionInfo);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphOptionInfo }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphAxisItem                                                     }
{------------------------------------------------------------------------------}
  TCrpeGraphAxisItem = class(TObject)
  private
    FNumber           : TCrGraphAxisNumber;
    FSectionGraphNum  : Smallint;
    FSection          : string;
    { Grid Lines }
    FGridLineX        : TCrGraphGridLines;
    FGridLineY        : TCrGraphGridLines;
    FGridLineY2       : TCrGraphGridLines;
    FGridLineZ        : TCrGraphGridLines;
    { Auto Range }
    FDataValuesY      : TCrGraphDVType;
    FDataValuesY2     : TCrGraphDVType;
    FDataValuesZ      : TCrGraphDVType;
    { Min/Max Values }
    FMinY             : Double;
    FMaxY             : Double;
    FMinY2            : Double;
    FMaxY2            : Double;
    FMinZ             : Double;
    FMaxZ             : Double;
    { Number Format }
    FNumberFormatY    : TCrGraphNumberFormat;
    FNumberFormatY2   : TCrGraphNumberFormat;
    FNumberFormatZ    : TCrGraphNumberFormat;
    { Automatic Division }
    FDivisionTypeY    : TCrGraphDVType;
    FDivisionTypeY2   : TCrGraphDVType;
    FDivisionTypeZ    : TCrGraphDVType;
    { Manual Division }
    FDivisionsY       : LongInt;
    FDivisionsY2      : LongInt;
    FDivisionsZ       : LongInt;
  protected
  published
  public
    constructor Create;
  end; { TCrpeGraphAxisItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphAxis                                                         }
{------------------------------------------------------------------------------}
   TCrpeGraphAxis = class(TPersistent)
   private
      FList  : TList;
      FIndex : integer;
   protected
      function  GetNumber : TCrGraphAxisNumber;
      procedure SetNumber (const Value: TCrGraphAxisNumber);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      function  GetSectionGraphNum : smallint;
      procedure SetSectionGraphNum (const Value: smallint);
      {GridLines}
      function  GetGridLineX : TCrGraphGridLines;
      procedure SetGridLineX (const Value: TCrGraphGridLines);
      function  GetGridLineY : TCrGraphGridLines;
      procedure SetGridLineY (const Value: TCrGraphGridLines);
      function  GetGridLineY2 : TCrGraphGridLines;
      procedure SetGridLineY2 (const Value: TCrGraphGridLines);
      function  GetGridLineZ : TCrGraphGridLines;
      procedure SetGridLineZ (const Value: TCrGraphGridLines);
      {DataValues - AutoRange}
      function  GetDataValuesY : TCrGraphDVType;
      procedure SetDataValuesY (const Value: TCrGraphDVType);
      function  GetDataValuesY2 : TCrGraphDVType;
      procedure SetDataValuesY2 (const Value: TCrGraphDVType);
      function  GetDataValuesZ : TCrGraphDVType;
      procedure SetDataValuesZ (const Value: TCrGraphDVType);
      {Min/Max}
      function  GetMinY : Double;
      procedure SetMinY (const Value: Double);
      function  GetMaxY : Double;
      procedure SetMaxY (const Value: Double);
      function  GetMinY2 : Double;
      procedure SetMinY2 (const Value: Double);
      function  GetMaxY2 : Double;
      procedure SetMaxY2 (const Value: Double);
      function  GetMinZ : Double;
      procedure SetMinZ (const Value: Double);
      function  GetMaxZ : Double;
      procedure SetMaxZ (const Value: Double);
      {NumberFormat}
      function  GetNumberFormatY : TCrGraphNumberFormat;
      procedure SetNumberFormatY (const Value: TCrGraphNumberFormat);
      function  GetNumberFormatY2 : TCrGraphNumberFormat;
      procedure SetNumberFormatY2 (const Value: TCrGraphNumberFormat);
      function  GetNumberFormatZ : TCrGraphNumberFormat;
      procedure SetNumberFormatZ (const Value: TCrGraphNumberFormat);
      {DivisionType}
      function  GetDivisionTypeY : TCrGraphDVType;
      procedure SetDivisionTypeY (const Value: TCrGraphDVType);
      function  GetDivisionTypeY2 : TCrGraphDVType;
      procedure SetDivisionTypeY2 (const Value: TCrGraphDVType);
      function  GetDivisionTypeZ : TCrGraphDVType;
      procedure SetDivisionTypeZ (const Value: TCrGraphDVType);
      {Divisions}
      function  GetDivisionsY : LongInt;
      procedure SetDivisionsY (const Value: LongInt);
      function  GetDivisionsY2 : LongInt;
      procedure SetDivisionsY2 (const Value: LongInt);
      function  GetDivisionsZ : LongInt;
      procedure SetDivisionsZ (const Value: LongInt);
      {Others}
      function  GetSectionAsCode : smallint;
      procedure SetSectionAsCode (const Value: smallint);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGraphAxis;
      function  ListItem(nIndex: integer): TCrpeGraphAxisItem;
   published
      property Number : TCrGraphAxisNumber
          read GetNumber
         write SetNumber;
      property Section : string
          read GetSection
         write SetSection;
      {GridLines}
      property GridLineX : TCrGraphGridLines
          read GetGridLineX
         write SetGridLineX;
      property GridLineY : TCrGraphGridLines
          read GetGridLineY
         write SetGridLineY;
      property GridLineY2 : TCrGraphGridLines
          read GetGridLineY2
         write SetGridLineY2;
      property GridLineZ : TCrGraphGridLines
          read GetGridLineZ
         write SetGridLineZ;
      {DataValues - AutoRange}
      property DataValuesY : TCrGraphDVType
          read GetDataValuesY
         write SetDataValuesY;
      property DataValuesY2 : TCrGraphDVType
          read GetDataValuesY2
         write SetDataValuesY2;
      property DataValuesZ : TCrGraphDVType
          read GetDataValuesZ
         write SetDataValuesZ;
      {Min/Max}
      property MinY : Double
          read GetMinY
         write SetMinY;
      property MaxY : Double
          read GetMaxY
         write SetMaxY;
      property MinY2 : Double
          read GetMinY2
         write SetMinY2;
      property MaxY2 : Double
          read GetMaxY2
         write SetMaxY2;
      property MinZ : Double
          read GetMinZ
         write SetMinZ;
      property MaxZ : Double
          read GetMaxZ
         write SetMaxZ;
      {NumberFormat}
      property NumberFormatY : TCrGraphNumberFormat
          read GetNumberFormatY
         write SetNumberFormatY;
      property NumberFormatY2 : TCrGraphNumberFormat
          read GetNumberFormatY2
         write SetNumberFormatY2;
      property NumberFormatZ : TCrGraphNumberFormat
          read GetNumberFormatZ
         write SetNumberFormatZ;
      {DivisionType}
      property DivisionTypeY : TCrGraphDVType
          read GetDivisionTypeY
         write SetDivisionTypeY;
      property DivisionTypeY2 : TCrGraphDVType
          read GetDivisionTypeY2
         write SetDivisionTypeY2;
      property DivisionTypeZ : TCrGraphDVType
          read GetDivisionTypeZ
         write SetDivisionTypeZ;
      {Divisions}
      property DivisionsY : LongInt
          read GetDivisionsY
         write SetDivisionsY;
      property DivisionsY2 : LongInt
          read GetDivisionsY2
         write SetDivisionsY2;
      property DivisionsZ : LongInt
          read GetDivisionsZ
         write SetDivisionsZ;
   public
      Cr : TCrpe;
      property SectionGraphNum : smallint
          read GetSectionGraphNum
         write SetSectionGraphNum;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeGraphAxis
          read GetItem; default;
      property SectionAsCode: smallint
          read GetSectionAsCode
         write SetSectionAsCode;
     function  SectionType : string;
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (GraphNumber: TCrGraphAxisNumber): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf(GraphNumber: TCrGraphAxisNumber): integer;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeGraphAxis);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphAxis }

{------------------------------------------------------------------------------}
{ Class TCrpeSubreportsItem                                                    }
{------------------------------------------------------------------------------}
  TCrpeSubreportsItem = class(TObject)
  private
    {Subreport specific variables}
    FName                  : TCrSubreportName;
    FSection               : string;
    FNLinks                : Smallint;
    FOnDemand              : Boolean;
    {General variables shared by Main and Subreports}
    FPrintJob              : Smallint;
    FReportTitle           : string;
    FDetailCopies          : Smallint;
    FFieldMapping          : TCrFieldMappingType;
    {General Classes shared by Main and Subreports}
    FReportOptions         : TCrpeReportOptions;
    FMargins               : TCrpeMargins;
    FConnect               : TCrpeConnect;
    FLogOnInfo             : TCrpeLogonInfo;
    FSectionFont           : TCrpeSectionFont;
    FSectionFormat         : TCrpeSectionFormat;
    FSectionFormatFormulas : TCrpeSectionFormatFormulas;
    FAreaFormat            : TCrpeAreaFormat;
    FAreaFormatFormulas    : TCrpeAreaFormatFormulas;
    FSectionHeight         : TCrpeSectionHeight;
    FSelection             : TCrpeSelection;
    FGroupSelection        : TCrpeGroupSelection;
    FSortFields            : TCrpeSortFields;
    FGroupSortFields       : TCrpeGroupSortFields;
    FGroupCondition        : TCrpeGroupCondition;
    FGroupOptions          : TCrpeGroupOptions;
    FSQL                   : TCrpeSQL;
    FFormulas              : TCrpeFormulas;
    FTables                : TCrpeTables;
    FParamFields           : TCrpeParamFields;
    FSessionInfo           : TCrpeSessionInfo;
    FGraphType             : TCrpeGraphType;
    FGraphText             : TCrpeGraphText;
    FGraphData             : TCrpeGraphData;
    FGraphOptions          : TCrpeGraphOptions;
    FGraphOptionInfo       : TCrpeGraphOptionInfo;
    FGraphAxis             : TCrpeGraphAxis;
  protected
  published
  public
    Cr : TCrpe;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  { TCrpeSubreportsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSubreports                                                        }
{------------------------------------------------------------------------------}
   TCrpeSubreports = class(TPersistent)
   private
      FList       : TList;
      FSubExecute : boolean;
      FIndex      : integer;
   protected
      function  GetName : TCrSubreportName;
      procedure SetName (const Value: TCrSubreportName);
      function  GetSection : string;
      procedure SetSection (const Value: string);
      function  GetNLinks : smallint;
      procedure SetNLinks (const Value: smallint);
      function  GetOnDemand : boolean;
      procedure SetOnDemand (const Value: boolean);
      function  GetDetailCopies: Smallint;
      procedure SetDetailCopies(const Value: Smallint);
      function  GetFieldMapping : TCrFieldMappingType;
      procedure SetFieldMapping(const Value: TCrFieldMappingType);
      function  GetReportTitle: string;
      procedure SetReportTitle(const Value: string);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSubreports;
      function  ListItem(nIndex: integer): TCrpeSubreportsItem;
   published
      property Name : TCrSubreportName
          read GetName
         write SetName;
      property Section : string
          read GetSection
         write SetSection;
      property NLinks : smallint
          read GetNLinks
         write SetNLinks;
      property OnDemand : boolean
          read GetOnDemand
         write SetOnDemand;
      property SubExecute : boolean
          read FSubExecute
         write FSubExecute
       default False;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeSubreports
          read GetItem; default;
      {These are duplicates from the main Crpe class
       so that Crpe1.Subreports.ReportTitle syntax is valid}
      property ReportTitle : string
          read GetReportTitle
         write SetReportTitle;
      property DetailCopies : Smallint
          read GetDetailCopies
         write SetDetailCopies;
      property FieldMapping : TCrFieldMappingType
          read GetFieldMapping
         write SetFieldMapping;
     {Reference Methods: variables}
     function  PrintJob     : Smallint;
     {Reference Methods: classes}
     function  ReportOptions         : TCrpeReportOptions;
     function  Margins               : TCrpeMargins;
     function  Connect               : TCrpeConnect;
     function  LogOnInfo             : TCrpeLogonInfo;
     function  SectionFont           : TCrpeSectionFont;
     function  SectionFormat         : TCrpeSectionFormat;
     function  SectionFormatFormulas : TCrpeSectionFormatFormulas;
     function  AreaFormat            : TCrpeAreaFormat;
     function  AreaFormatFormulas    : TCrpeAreaFormatFormulas;
     function  SectionHeight         : TCrpeSectionHeight;
     function  Selection             : TCrpeSelection;
     function  GroupSelection        : TCrpeGroupSelection;
     function  SortFields            : TCrpeSortFields;
     function  GroupSortFields       : TCrpeGroupSortFields;
     function  GroupCondition        : TCrpeGroupCondition;
     function  GroupOptions          : TCrpeGroupOptions;
     function  SQL                   : TCrpeSQL;
     function  Formulas              : TCrpeFormulas;
     function  Tables                : TCrpeTables;
     function  ParamFields           : TCrpeParamFields;
     function  SessionInfo           : TCrpeSessionInfo;
     function  GraphType             : TCrpeGraphType;
     function  GraphText             : TCrpeGraphText;
     function  GraphData             : TCrpeGraphData;
     function  GraphOptions          : TCrpeGraphOptions;
     function  GraphOptionInfo       : TCrpeGraphOptionInfo;
     function  GraphAxis             : TCrpeGraphAxis;
     {Methods}
     function  Retrieve : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (SubName: TCrSubreportName): integer;
     procedure Delete (nIndex: integer);
     function  IndexOf (SubName: TCrSubreportName): integer;
     procedure CopyFrom (Source: TCrpeSubreports);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSubreports }

{------------------------------------------------------------------------------}
{ Class TCrpeReportOptions                                                     }
{------------------------------------------------------------------------------}
   TCrpeReportOptions = class(TPersistent)
   private
      FSaveDataWithReport,
      FSaveSummariesWithReport,
      FUseIndexForSpeed,
      FTranslateDOSStrings,
      FTranslateDOSMemos,
      FConvertNullFieldToDefault,
      FPrintEngineErrorMessages,
      FCaseInsensitiveSQLData,
      FVerifyOnEveryPrint,
      FCreateGroupTree,
      FNoDataForHiddenObjects,
      FPerformGroupingOnServer          : TCrBoolean;
      FConvertDateTimeType              : TCrDateTimeType;
      FZoomMode                         : TCrZoomPreview;
      FAsyncQuery                       : TCrBoolean;
   protected
   published
      property SaveDataWithReport : TCrBoolean
          read FSaveDataWithReport
         write FSaveDataWithReport
       default cDefault;
      property SaveSummariesWithReport : TCrBoolean
          read FSaveSummariesWithReport
         write FSaveSummariesWithReport
       default cDefault;
      property UseIndexForSpeed : TCrBoolean
          read FUseIndexForSpeed
         write FUseIndexForSpeed
       default cDefault;
      property TranslateDOSStrings : TCrBoolean
          read FTranslateDOSStrings
         write FTranslateDOSStrings
       default cDefault;
      property TranslateDOSMemos : TCrBoolean
          read FTranslateDOSMemos
         write FTranslateDOSMemos
       default cDefault;
      property ConvertNullFieldToDefault : TCrBoolean
          read FConvertNullFieldToDefault
         write FConvertNullFieldToDefault
       default cDefault;
      property PrintEngineErrorMessages : TCrBoolean
          read FPrintEngineErrorMessages
         write FPrintEngineErrorMessages
       default cDefault;
      property CaseInsensitiveSQLData : TCrBoolean
          read FCaseInsensitiveSQLData
         write FCaseInsensitiveSQLData
       default cDefault;
      property VerifyOnEveryPrint : TCrBoolean
          read FVerifyOnEveryPrint
         write FVerifyOnEveryPrint
       default cDefault;
      property CreateGroupTree : TCrBoolean
          read FCreateGroupTree
         write FCreateGroupTree
       default cDefault;
      property NoDataForHiddenObjects : TCrBoolean
          read FNoDataForHiddenObjects
         write FNoDataForHiddenObjects
       default cDefault;
      property PerformGroupingOnServer : TCrBoolean
          read FPerformGroupingOnServer
         write FPerformGroupingOnServer
       default cDefault;
      property ConvertDateTimeType : TCrDateTimeType
          read FConvertDateTimeType
         write FConvertDateTimeType
       default dtDefault;
      property ZoomMode : TCrZoomPreview
          read FZoomMode
         write FZoomMode
       default pwDefault;
      property AsyncQuery : TCrBoolean
          read FAsyncQuery
         write FAsyncQuery
       default cDefault;
   public
     Cr : TCrpe;
     function  Retrieve : boolean;
     procedure Clear;
     function  Send : boolean;
     procedure CopyFrom (Source: TCrpeReportOptions);
     constructor Create;
   end; { Class TCrpeReportOptions }

{------------------------------------------------------------------------------}
{ Class TCrpeSQLExpressionsItem                                                }
{------------------------------------------------------------------------------}
  TCrpeSQLExpressionsItem = class(TObject)
  private
    FName       : string;
    FExpression : TCrpeString;
  protected
  published
  public
    constructor Create;
    destructor Destroy; override;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeSQLExpressions                                                    }
{------------------------------------------------------------------------------}
   TCrpeSQLExpressions = class(TPersistent)
   private
      FList  : TList;
      sTemp  : TCrpeString;
      FIndex : integer;
   protected
      function  GetName : TCrExpressionName;
      procedure SetName (const Value: TCrExpressionName);
      function  GetExpression : TCrpeString;
      procedure SetExpression (const ListVar: TCrpeString);
      function  GetIndex : integer;
      procedure SetIndex (const nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeSQLExpressions;
      function  ListItem(nIndex: integer) : TCrpeSQLExpressionsItem;
   published
      property Name : TCrExpressionName
          read GetName
         write SetName;
      property Expression : TCrpeString
          read GetExpression
         write SetExpression;
   public
      Cr : TCrpe;
      property ItemIndex : integer
          read GetIndex
         write SetIndex;
      property Item[nIndex: integer]: TCrpeSQLExpressions
          read GetItem; default;
     function  Retrieve : boolean;
     function  Check : boolean;
     function  Count : integer;
     procedure Clear;
     function  Add (ExpressionName: TCrExpressionName): integer;
     procedure Delete(nIndex: integer);
     function  Send : boolean;
     function  IndexOf(ExpressionName: TCrExpressionName): integer;
     procedure CopyFrom (Source: TCrpeSQLExpressions);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSQLExpressions }

(*
{------------------------------------------------------------------------------}
{ Class TCrpeFax                                                               }
{------------------------------------------------------------------------------}
   TCrFaxType = (ftBlackIce);
   TCrFaxPhone = string[32];

   TCrpeFax = class(TPersistent)
   private
      FFaxType     : TCrFaxType;
      FPhoneNumber : TCrFaxPhone;
   protected
     function  GetFaxType : TCrFaxType;
     procedure SetFaxType(const Value: TCrFaxType);
     function  GetPhoneNumber : TCrFaxPhone;
     procedure SetPhoneNumber(const Value: TCrFaxPhone);
   published
      property FaxType : TCrFaxType
          read GetFaxType
         write SetFaxType;
      property PhoneNumber : TCrFaxPhone
          read GetPhoneNumber
         write SetPhoneNumber;
   public
     Cr : TCrpe;
     procedure Clear;
     procedure CopyFrom (Source: TCrpeFax);
     constructor Create;
   end; { Class TCrpeFax Declaration }
*)

  TLogEvent = procedure(VCLCallStr: string; JobNum: smallint;
    param1: Pointer; param2: Pointer; param3: Pointer; param4: Pointer;
    param5: Pointer; param6: Pointer; param7: Pointer; param8: Pointer;
    param9: Pointer; param10: Pointer; param11: Pointer) of object;
  TLogResult = procedure(VCLCallStr: string; boolResult: Bool;
    intResult: Smallint) of object;

{Utility}
function  StrToTCrBoolean (const sValue: string): TCrBoolean;
function  TCrBooleanToStr (const crbValue: TCrBoolean): string;


implementation

{Resource Files}
{$R URLogOn.DFM}   {LogOnInfo Prompt Dialog}

uses
  Dialogs, Winspool, Printers, ShellApi, Registry;

const
  TCRPE_PRINTENGINE = 'CRPE32.DLL';
  TCRPE_REQ_MAJOR_VERSION = 5;  {Crystal Eng Version Min}
  TCRPE_REQ_MINOR_VERSION = 108;

 {Error Constants}
  {General}
   ECRPE_OPEN_ENGINE           = '100:Error loading library: CRPE32.DLL';
   ECRPE_NOT_LOADED            = '101:CRPE32.DLL is not loaded';
   ECRPE_VERSION               = '102:Incompatible CRPE version: requires 5.x.x.108 or higher';
   ECRPE_VERSION_INFO          = '103:Failed to obtain Version Information from CRPE32.DLL';
   ECRPE_LOAD_DLL_FUNCTION     = '104:Failed to load function from CRPE32.DLL';
   ECRPE_DLL_NOT_FOUND         = '105:Could not find CRPE32.DLL';
   ECRPE_LOAD_DLL              = '106:Print Engine could not be loaded';
   ECRPE_FREE_DLL              = '109:Error freeing library: CRPE32.DLL';
   ECRPE_ALLOCATE_MEMORY       = '110:Could not Allocate Memory for Internal Variables';
   ECRPE_NO_NAME               = '112:No ReportName assigned';
   ECRPE_REPORT_NOT_FOUND      = '114:Report not found';
   ECRPE_SUBSCRIPT             = '116:Subscript out of range';
   ECRPE_ITEM_ALREADY_EXISTS   = '118:Item already exists';
   ECRPE_NOT_FOUND             = '120:Lookup item not found';
   ECRPE_FAILED_GETTING_ERROR  = '130:Failed to Retrieve Error Message from Print Engine';
   ECRPE_UNDEFINED             = '140:Undefined Print Engine Error';

   {Window}
   ECRPE_INVALID_MAGNIFICATION = '150:Invalid Magnification Value.  Use -1 for Default, ' + chr(10) +
     '0,1,2 for ZoomPreview constants, or 25-400 for Zoom values';
   {Printer}
   ECRPE_PRINTER_NAME          = '170:Printer Name has not been set';
   ECRPE_PRINTER_INFO          = '175:Failed to obtain Printer Information';
   {Fax}
   {ECRPE_FAX_UNAVAILABLE       = '180:Output to Fax requires CRPE32 version 7.0 or higher';}
   {Subreports}
   ECRPE_SUBREPORT_NAME    = '200:Subreport Name not found.' + chr(10) +
                             'Use "Add" to add a Subreport Name, ' + chr(10) +
                             'or "Retrieve" to obtain the Subreport Names from the Report';
   ECRPE_DELETE_SUBREPORTS    = '205:Cannot Delete Subreports[0]; this is the Main Report';
   ECRPE_SUBREPORT_NOT_FOUND  = '210:Error: Subreport Name not found in Report';
   {LogOnInfo}
   ECRPE_BAD_LOGON_TABLENUM   = '250:Invalid Table Number';
   {SessionInfo}
   ECRPE_SESSIONINFO_NUMBER   = '260:Invalid Table Number';
   {SQL Params}
   ECRPE_PARAM_NAME           = '270:Invalid Param Name';
   ECRPE_GET_AS_DATE          = '280:Value could not be converted to Date';
   ECRPE_GET_AS_DATETIME      = '282:Value could not be converted to DateTime';
   ECRPE_GET_AS_TIME          = '284:Value could not be converted to Time';
   {Parameter Fields}
   ECRPE_PARAMETER_NAME       = '290:Invalid Parameter Name';
   ECRPE_PARAMETER_NUMBER     = '292:Invalid Number Value';
   ECRPE_PARAMETER_CURRENCY   = '293:Invalid Currency Value';
   ECRPE_PARAMETER_BOOLEAN    = '294:Invalid Boolean Value (Proper format: True/False)';
   ECRPE_PARAMETER_DATE       = '296:Invalid Date Value (Proper format: YYYY,MM,DD)';
   ECRPE_PARAMETER_STRING     = '297:Invalid String Value';
   ECRPE_PARAMETER_DATETIME   = '298:Invalid DateTime Value (Proper format: YYYY,MM,DD HH:MM:SS)';
   ECRPE_PARAMETER_TIME       = '299:Invalid Time Value (Proper format: HH:MM:SS)';
   ECRPE_STR2VALUEINFO        = '305:Error converting string to ValueInfo';

   {Tables}
   ECRPE_BAD_TABLE_NUMBER     = '320:Invalid Table Number';
   ECRPE_ALIAS_NAME           = '322:Invalid BDE Alias Name';
   {SortFields}
   ECRPE_SORTFIELD_NUMBER     = '330:Invalid SortFields Number';
   ECRPE_SORTFIELD_DIRECTION  = '332:Invalid SortFields Direction';
   {GroupSortFields}
   ECRPE_GROUPSORT_NUMBER     = '340:Invalid GroupSortFields Number';
   ECRPE_GROUPSORT_DIRECTION  = '342:Invalid GroupSortFields Direction';
   {GroupCondition/GroupOptions}
   ECRPE_GROUP_CONDITION      = '350:Invalid GroupCondition Number';
   ECRPE_GROUP_OPTIONS        = '352:Invalid GroupOptions Number';
   ECRPE_GROUP_TYPE           = '354:GroupType and Condition do not match';
   {Sections}
   ECRPE_SECTION_CODE         = '360:Invalid Section Code or String';
   ECRPE_SECTION_AS_CODE      = '362:Invalid SectionAsCode Value (Value must be > 0)';
   ECRPE_SECTION_FORMULA      = '364:Formula is not available for PH/PF Section: ';
   ECRPE_AREA_FORMULA         = '366:Formula is not available for PH/PF(or RH/RF) Section: ';
   ECRPE_COLOR                = '368:Invalid Color Value';
   ECRPE_SECTION_HEIGHT       = '370:Invalid SectionHeight Height value';
   {Graphs}
   ECRPE_GRAPH_TYPE_NUM       = '380:Invalid GraphType Number';
   ECRPE_GRAPH_OPTIONS_NUM    = '382:Invalid GraphOptions Number';
   ECRPE_GRAPH_OPTIONINFO_NUM = '383:Invalid GraphOptionInfo Number';
   ECRPE_GRAPH_TEXT_NUM       = '384:Invalid GraphText Number';
   ECRPE_GRAPH_AXIS_NUM       = '385:Invalid GraphAxis Number';
   ECRPE_GRAPH_DATA_NUM       = '386:Invalid GraphData Number';
   ECRPE_GRAPH_DATA_DIRECTION = '388:Invalid GraphData Bar Direction';
   {SummaryInfo}
   ECRPE_SUMINFO_COMMENTS     = '400:SummaryInfo Comments cannot be greater than 512 characters';


{******************************************************************************}
{ TCrpe Class Definition                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ LogEvent Method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpe.LogEvent(VCLCallStr: string; JobNum: smallint;
  param1: Pointer; param2: Pointer; param3: Pointer; param4: Pointer;
  param5: Pointer; param6: Pointer; param7: Pointer; param8: Pointer;
  param9: Pointer; param10: Pointer; param11: Pointer);
var
  Event : TMethod;
begin
  if (FLog <> nil) then
  begin
    if FLog.ClassName = 'TCrpeLog' then
    begin
      {Use MethodAddress so we don't have to include UCrpeLog}
      Event.Data := FLog;
      Event.Code := FLog.MethodAddress('LogEvent');
      TLogEvent(Event)(VCLCallStr, JobNum, param1, param2, param3,
        param4, param5, param6, param7, param8, param9,
        param10, param11);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ LogResult Method                                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.LogResult(VCLCallStr: string; boolResult: Bool;
  intResult: Smallint);
var
  Event : TMethod;
begin
  if (FLog <> nil) then
  begin
    if FLog.ClassName = 'TCrpeLog' then
    begin
      {Use MethodAddress so we don't have to include UCrpeLog}
      Event.Data := FLog;
      Event.Code := FLog.MethodAddress('LogResult');
      TLogResult(Event)(VCLCallStr, boolResult, intResult);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpe.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
  hDLL := 0;
  FEngineOpened := False;
  if AOwner is TForm then
  begin
    with AOWner as TForm do
      FParentFormHandle := Handle;
  end
  else
    FParentFormHandle := 0;
  {General}
  FAbout := 'Version and Credits...';
  FReportName := '';
  FCrpePath := '';
  FPrintJob := 0;
  FLoadEngineOnUse := False;
  FOutput := toWindow;
  {FMultiThread := False;}
  FCanCloseEngine := True;
  FConnectMethod := useConnect;
  FCrpeState := crsSetup;
  FDesignControls := 'Design-Time Window Controls';
  FDiscardSavedData := False;
  FHasSavedData := False;
  FIsJobFinished := True;
  FProgressDialog := True;
  FSendOnExecute := True;
  FWindowEvents := False;
  FLog := nil;

  {Version}
  FVersion := TCrpeVersion.Create;
  FVersion.Cr := Self;
  {PrintDate}
  FPrintDate := TCrpePrintDate.Create;
  FPrintDate.Cr := Self;
  {SQL}
  FLogOnServer := TCrpeLogOnServer.Create;
  FLogOnServer.Cr := Self;
  {Printer}
  FPrinter := TCrpePrinter.Create;
  FPrinter.Cr := Self;
  FPrintOptions := TCrpePrintOptions.Create;
  FPrintOptions.Cr := Self;
  {Fax}
  {FFax := TCrpeFax.Create;
  FFax.Cr := Self;}
  {Window}
  FWindowState := wsNormal;
  FWindowParent := nil;
  FDialogParent := nil;
  {WindowZoom}
  FWindowZoom := TCrpeWindowZoom.Create;
  FWindowZoom.Cr := Self;
  {WindowStyle}
  FWindowStyle := TCrpeWindowStyle.Create;
  FWindowStyle.Cr := Self;
  {WindowSize}
  FWindowSize := TCrpeWindowSize.Create;
  FWindowSize.Cr := Self;
  {Window Buttons: for Crystal 6.0 & up}
  FWindowButtonBar := TCrpeWindowButtonBar.Create;
  FWindowButtonBar.Cr := Self;
  {Window Cursors: for Crystal 6.0 & up}
  FWindowCursor := TCrpeWindowCursor.Create;
  FWindowCursor.Cr := Self;
  {Records}
  FRecords := TCrpeRecords.Create;
  FRecords.Cr := Self;
  {Pages}
  FPages := TCrpePages.Create;
  FPages.Cr := Self;
  {ExportOptions}
  FExport := TCrpeExport.Create;
  FExport.Cr := Self;
  {SummaryInfo}
  FSummaryInfo := TCrpeSummaryInfo.Create;
  FSummaryInfo.Cr := Self;
  {ReportOptions}
  FReportOptions := TCrpeReportOptions.Create;
  FReportOptions.Cr := Self;

  {Subreports}
  FSubreports := TCrpeSubreports.Create;
  FSubreports.Cr := Self;
  {Add blank for Main Report}
  FSubreports.Add('');

  {OnCreate Event}
  if Assigned(FOnCreate) then
    FOnCreate(Self);
end; { Constructor Create }

{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpe.Destroy;
begin
  {Clear the Subreport Info structures}
  Clear;
  {Free the non-Subreport SubClasses}
  FPrintDate.Free;
  FVersion.Free;
  FLog := nil;
  FLogOnServer.Free;
  FWindowZoom.Free;
  FWindowSize.Free;
  {Free the MDIForm if it exists}
  if FWindowStyle.FMDIForm <> nil then
    FWindowStyle.FMDIForm.Free;
  FWindowStyle.Free;
  FWindowButtonBar.Free;
  FWindowCursor.Free;
  FRecords.Free;
  FPages.Free;
  FReportOptions.Free;
  FSummaryInfo.Free;
  FExport.Free;
  FPrinter.Free;
  FPrintOptions.Free;
  {FFax.Free;}
  {FDesignControls.Free;}
  FSubreports.Free;
  {Close the Print Engine}
  if hDLL > 0 then
    ClosePrintEngine;
  inherited Destroy;
end; { Destructor Destroy }

{------------------------------------------------------------------------------}
{  Member procedure Loaded.                                                    }
{   Checks the LoadEngineOnUse property during Loading.                        }
{------------------------------------------------------------------------------}
procedure TCrpe.Loaded;
begin
  inherited Loaded;
  if not (csDesigning in ComponentState) then
  begin
    if not FLoadEngineOnUse then
      OpenPrintEngine;
    {Set the Log Component for the Print Engine Header file: CRDynamic}
    if (FLog <> nil) then
    begin
      if (FLog is TComponent) then
      begin
        if (FLog.ClassName = 'TCrpeLog') then
          CRDLog := FLog;
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.Clear;
begin
  {** Clear Subreports information **}
  FSubreports.Clear;
  {** Clear SubClasses for Main Report **}
  FSubreports.ListItem(0).Clear;
  {Clear the Main Report classes}
  FPrintDate.Clear;
  FLogOnServer.Clear;
  FExport.Clear;
  FPrinter.Clear;
  FPrintOptions.Clear;
  {FFax.Clear;}
  FWindowZoom.Clear;
  FWindowStyle.Clear;
  FWindowSize.Clear;
  FWindowButtonBar.Clear;
  FWindowCursor.Clear;
  FSummaryInfo.Clear;
  FReportOptions.Clear;
  {** Set Component Defaults **}
  {General}
  FReportName := '';
  FCrpePath := '';
  FLoadEngineOnUse := False;
  FLastErrorNumber := 0;
  FLastErrorString := '';
  FSubreports.ListItem(0).FReportTitle := '';
  FSubreports.ListItem(0).FDetailCopies := 1;
  FSubreports.ListItem(0).FFieldMapping := fmAuto;
  {FMultiThread := False;}
  FOutput := toWindow;
  FSendOnExecute := True;
  FCanCloseEngine := True;
  FConnectMethod := useConnect;
  FDiscardSavedData := False;
  FHasSavedData := False;
  FIsJobFinished := True;
  FProgressDialog := True;
  FWindowEvents := False;
  FWindowState := wsNormal;
  {Close PrintJob}
  ClosePrintJob;
  FSubreports.SetIndex(0);
end; { Clear }

{------------------------------------------------------------------------------}
{ CopyFrom function                                                            }
{------------------------------------------------------------------------------}
procedure TCrpe.CopyFrom(Source: TCrpe);
var
  cnt    : integer;
  n1, n2 : integer;
begin
  Clear;
  n1 := Subreports.ItemIndex;
  n2 := Source.Subreports.ItemIndex;
  for cnt := 0 to Source.Subreports.Count - 1 do
  begin
    Subreports[cnt];
    if cnt = 0 then
    begin
      {General}
      FReportName := Source.FReportName;
      FCrpePath := Source.FCrpePath;
      FLog := Source.FLog;
      FLoadEngineOnUse := Source.FLoadEngineOnUse;
      FOutput := Source.FOutput;
      FPrintJob := Source.FPrintJob;
      FConnectMethod := Source.FConnectMethod;
      FDiscardSavedData := Source.FDiscardSavedData;
      FHasSavedData := Source.FHasSavedData;
      FProgressDialog := Source.FProgressDialog;
      FSendOnExecute := Source.FSendOnExecute;
      FWindowEvents := Source.FWindowEvents;
      FWindowState := Source.FWindowState;
      {SubClasses}
      FPrintDate.CopyFrom(Source.FPrintDate);
      FExport.CopyFrom(Source.FExport);
      {FFax.CopyFrom(Source.FFax);}
      FLogOnServer.CopyFrom(Source.FLogOnServer);
      FPrinter.CopyFrom(Source.FPrinter);
      FPrintOptions.CopyFrom(Source.FPrintOptions);
      FReportOptions.CopyFrom(Source.FReportOptions);
      FSummaryInfo.CopyFrom(Source.FSummaryInfo);
      FWindowButtonBar.CopyFrom(Source.FWindowButtonBar);
      FWindowCursor.CopyFrom(Source.FWindowCursor);
      FWindowSize.CopyFrom(Source.FWindowSize);
      FWindowStyle.CopyFrom(Source.FWindowStyle);
      FWindowZoom.CopyFrom(Source.FWindowZoom);
    end
    else if cnt > 0 then
    begin
      Subreports.Add(Source.Subreports[cnt].Name);
      Subreports.CopyFrom(Source.Subreports);
    end;
  {These are not included: Crpe/Report specific}
(*  FParentFormHandle := Source.FParentFormHandle;
    FCrpeState := Source.FCrpeState;
    FDesignControls := Source.FDesignControls;
    FCanCloseEngine := Source.FCanCloseEngine;
    FIsJobFinished := Source.FIsJobFinished; *)
  end;
  Subreports.SetIndex(n1);
  Source.Subreports.SetIndex(n2);
end;

{------------------------------------------------------------------------------}
{  GetCRPEVersion procedure                                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.GetCRPEVersion;
var
  sFile    : string;
  sEngine  : string;
  s1,s2,s3 : string;
  x        : char;
  n        : integer;
  nMajor   : integer;
  nMinor   : integer;
  dwError  : DWord;
begin
  {Load the CRPE32.DLL}
  sFile := AddBackSlash(FCrpePath);
  sEngine := TCRPE_PRINTENGINE;
  {If there is no path, or it is invalid, search without a path}
  if FileExists(sFile + sEngine) then
    sFile := sFile + sEngine
  else
    sFile := sEngine;

  {Get CRPE FileVersion}
  dwError := GetVersionInfo(sFile,'FileVersion', s1);
  if dwError <> 0 then
  begin
    s2 := SysErrorMessage(GetLastError);
    if Trim(s2) = '' then
      s1 := 'GetCrpeVersion <GetVersionInfo>' + Chr(10) +
        'Windows Error Number: ' + IntToStr(dwError)
    else
      s1 := 'GetCrpeVersion <GetVersionInfo>' + Chr(10) +
        'Windows Error Number: ' + IntToStr(dwError) + ' - ' + Trim(s2);
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_VERSION_INFO, s1) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  FVersion.FFileVersion := s1;

  x := 'x';
  if FVersion.FFileVersion <> '7,0,0,0' then
  begin
    s1 := FVersion.FFileVersion;
    if Length(s1) > 0 then
    begin
      if Pos(',', s1) > 0 then
        x := ','
      else if Pos('.', s1) > 0 then
        x := '.';
    end;
    if x <> 'x' then
    begin
      {Get First (major) Version Number: only take numbers}
      s2 := GetToken(s1, x);
      s3 := '';
      for n := 1 to Length(s2) do
      begin
        if (Ord(s2[n]) > 47) and (Ord(s2[n]) < 58) then
          s3 := s3 + s2[n];
      end;
      FVersion.FMajor := StrToInt(s3);
      {Get Second Version Number}
      s2 := GetToken(s1, x);
      {Get Third Version Number}
      s2 := GetToken(s1, x);
      {Get Fourth (minor) Version Number: only take numbers}
      s2 := '';
      for n := 1 to Length(s1) do
      begin
        if (Ord(s1[n]) > 47) and (Ord(s1[n]) < 58) then
          s2 := s2 + s1[n];
      end;
      FVersion.FMinor := StrToInt(s2);
    end;
  end;

  {If version wasn't obtained, default to 7.0}
  if x = 'x' then
  begin
    FVersion.FMajor := 7;
    FVersion.FMinor := 0;
  end;

  {OnGetVersion event: let the user over-ride major/minor}
  nMajor := FVersion.FMajor;
  nMinor := FVersion.FMinor;
  if Assigned(FOnGetVersion) then
  begin
    FOnGetVersion(Self, nMajor, nMinor);
    FVersion.FMajor := nMajor;
    FVersion.FMinor := nMinor;
  end;
  {Update the CRDynamic variables}
  CRDVerMajor := FVersion.FMajor;
  CRDVerMinor := FVersion.FMinor;
end;

{------------------------------------------------------------------------------}
{ OpenPrintEngine procedure                                                    }
{------------------------------------------------------------------------------}
function TCrpe.OpenPrintEngine : boolean;
var
  {EngineOptions      : PEEngineOptions;}
  IsEngineCompatible : boolean;
  sEngine            : string;
  bLoaded            : boolean;
  ErrString          : string;
begin
  Result := True;
  {If the DLL is not loaded...}
  if (hDLL = 0) then
  begin
    {Get CRPE DLL version}
    GetCRPEVersion;
    {If the engine is not 5.x.x.108 or greater...}
    IsEngineCompatible := (FVersion.FMajor > TCRPE_REQ_MAJOR_VERSION)
      or ((FVersion.FMajor = TCRPE_REQ_MAJOR_VERSION) and
          (FVersion.FMinor >= TCRPE_REQ_MINOR_VERSION));
    if not IsEngineCompatible then
    begin
      FLastErrorNumber := GetErrorNum(ECRPE_VERSION);
      ErrString := GetErrorStr(ECRPE_VERSION);
      FLastErrorString := ErrString + chr(10) +
        TCRPE_PRINTENGINE + ' :: ' + FVersion.FFileVersion;
      raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
    {Load the CRPE32.DLL}
    sEngine := AddBackslash(FCrpePath);
    bLoaded := True;
    if (Length(sEngine) > 0) and FileExists(sEngine + TCRPE_PRINTENGINE) then
    begin
      LogEvent('OpenPrintEngine',0,@sEngine,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil);
      if not PELoadCrpeDll(sEngine) then
        bLoaded := False
      else
        hDLL := CRDEngine;
    end;
    {If there is no path, or the first attempt failed, search without a path}
    if (Length(sEngine) = 0) or (bLoaded = False) then
    begin
      LogEvent('OpenPrintEngine',0,@sEngine,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil);
      if not PELoadCrpeDll('') then
        bLoaded := False
      else
        hDLL := CRDEngine;
      {If an error was encountered...}
      if not bLoaded then
      begin
        Result := False;
        case GetErrorMsg(0,errNoOption,errVCL,ECRPE_LOAD_DLL,'') of
          cFalse   : Exit;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
    end;
    {Retrieve the Engine/DLL version}
    FVersion.Retrieve;
  end;
  {Open the Print Engine: Multi Threaded}
  (*if (FVersion.FMajor > 6) and (FMultiThread = True) then
  begin
    EngineOptions.openEngineType := PE_OE_MULTI_THREADED;
    {If an error occured during opening...}
    if not PEOpenEngineEx(EngineOptions) then
    begin
      Result := False;
      ClosePrintEngine;
      case GetErrorMsg(0,0,errEngine,'','OpenPrintEngineEx <PEOpenEngineEx>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end
  else
  begin
  *)
  {Attemp to Open the Engine...}
  if not FEngineOpened then
  begin
    SetDLLHandle;
    FEngineOpened := PEOpenEngine;
    if not FEngineOpened then
    begin
      Result := False;
      case GetErrorMsg(0,errNoOption,errEngine,'',
          'OpenPrintEngine <PEOpenEngine>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end; { OpenPrintEngine }
{------------------------------------------------------------------------------}
{ Member function OpenEngine                                                   }
{------------------------------------------------------------------------------}
function TCrpe.OpenEngine;
begin
  Result := OpenPrintEngine;
end;
{------------------------------------------------------------------------------}
{ Member procedure CloseEngine                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.CloseEngine;
begin
  ClosePrintJob;
  ClosePrintEngine;
end;

{------------------------------------------------------------------------------}
{ Member procedure ClosePrintEngine                                            }
{------------------------------------------------------------------------------}
procedure TCrpe.ClosePrintEngine;
begin
  SetDLLHandle;
  PECloseEngine;
  PEUnloadCrpeDLL;
  hDLL := 0;
  FEngineOpened := False;
end; { ClosePrintEngine }

{------------------------------------------------------------------------------}
{ OpenPrintJob function                                                        }
{------------------------------------------------------------------------------}
function TCrpe.OpenPrintJob: Boolean;
var
  nIndex          : integer;
  sTmp            : string;
  RptIndex        : integer;
begin
  Result := True;
  {If ReportName is blank raise error}
  if FReportName = '' then
  begin
    Result := False;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_NO_NAME,'') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  {If ReportName doesn't exist raise error}
  if not FileExists(FReportName) then
  begin
    Result := False;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_REPORT_NOT_FOUND,'') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  {Make sure the Engine is Open}
  if not OpenPrintEngine then
  begin
    Result := False;
    Exit;
  end;

  {Store current Report index}
  RptIndex := FSubreports.FIndex;

  {Loop through Reports}
  for nIndex := 0 to (FSubreports.Count - 1) do
  begin
    {Update Report index}
    FSubreports.SetIndex(nIndex);
    {Main Report}
    if (nIndex = 0) then
    begin
      {Open Main report if needed}
      if (FPrintJob = 0) then
      begin
        SetDLLHandle;
        {Open the Main PrintJob}
        FPrintJob := PEOpenPrintJob(PChar(FReportName));
        FSubreports.ListItem(FIndex).FPrintJob := FPrintJob;
        {If PrintJob is zero, generate error}
        if FPrintJob = 0 then
        begin
          Result := False;
          case GetErrorMsg(0,errNoOption,errEngine,'',
              'OpenPrintJob <PEOpenPrintJob>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        if Assigned(FOnJobOpened) then
          FOnJobOpened(Self, FPrintJob);
      end;
    end
    {Subreport}
    else
    begin
      {Open the Subreport PrintJob}
      if (FPrintJob = 0) then
      begin
        SetDLLHandle;
        sTmp := Trim(FSubreports.ListItem(nIndex).FName);
        FPrintJob := PEOpenSubreport(FSubreports.ListItem(0).FPrintJob, PChar(sTmp));
        FSubreports.ListItem(nIndex).FPrintJob := FPrintJob;
        {If PrintJob is zero, generate error}
        if FPrintJob = 0 then
        begin
          Result := False;
          case GetErrorMsg(0,errNoOption,errEngine,'',
              'OpenPrintJob <PEOpenSubreport>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
      end;
    end;
  end;
  {Restore current Report index}
  FSubreports.SetIndex(RptIndex);
end; { OpenPrintJob }
{------------------------------------------------------------------------------}
{  ClosePrintJob procedure                                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.ClosePrintJob;
begin
  {Set Main Report}
  FSubreports.SetIndex(0);
  if (FPrintJob <> 0) then
  begin
    {Clear and Close the Subreports}
    FSubreports.Clear;
    {Clear Main Report Report-specific classes}
    FSubreports.ListItem(0).Clear;
    SetDLLHandle;
    {Close the Main report}
    if not PEClosePrintJob(FPrintJob) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'ClosePrintJob <PEClosePrintJob>') of
        cFalse   : {Ignore};
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    FSubreports.ListItem(FIndex).FPrintJob := 0;
    FPrintJob := 0;
  end;
end; { ClosePrintJob }

{------------------------------------------------------------------------------}
{ Member function OpenJob                                                      }
{------------------------------------------------------------------------------}
function TCrpe.OpenJob: boolean;
begin
  Result := OpenPrintJob;
end;
{------------------------------------------------------------------------------}
{ Member procedure CloseJob                                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.CloseJob;
begin
  ClosePrintJob;
end;

{------------------------------------------------------------------------------}
{  GetErrorMsg function : Get Errors generated by VCL or CRPE engine           }
{    - nJob is the PrintJob number(only for Engine errors)                     }
{    - Option is error variation: regular, formula, or paging (Engine only)    }
{    - ErrType is errVCL or errEngine                                          }
{    - ErrString contains the VCL error constant string (if applicable)        }
{------------------------------------------------------------------------------}
function TCrpe.GetErrorMsg(const nJob: Word; const Option: TCrErrorOption;
  const ErrType: TCrError; const ErrConst: string; const ErrString: string): TCrBoolean;
var
  hTextHandle       : hWnd;
  nTextLen          : Smallint;
  pErrorText        : PChar;
  sErrorText        : string;
  bIgnoreError      : TCrBoolean;
  Job1,Job2         : Smallint;

  function VCLError(ErrorConstant: string; ErrorString: string): TCrBoolean;
  begin
    Result := cDefault;
    {Get Error Number and Error String}
    FLastErrorNumber := GetErrorNum(ErrorConstant);
    FLastErrorString := GetErrorStr(ErrorConstant);
    if ErrorString <> '' then
      FLastErrorString := FLastErrorString + ' :: ' + ErrorString;
    {If in Design state, show dialog}
    if (csDesigning in ComponentState) then
    begin
      MessageDlg('Error: ' + IntToStr(FLastErrorNumber) +
        Chr(10) + FLastErrorString, mtError, [mbOk], 0);
      Result := cFalse;
    end
    else
    begin
      {Check the OnError event}
      bIgnoreError := cDefault;
      if Assigned(FOnError) then
      begin
        FOnError(Self, FLastErrorNumber, FLastErrorString, bIgnoreError);
        case bIgnoreError of
          cFalse   : Result := cTrue;    {Silent Exception: assume user dialog}
          cTrue    : Result := cFalse;   {Ignore Error}
          cDefault : Result := cDefault; {Use built-in Exception & dialog}
        end;
      end;
    end;
  end;

begin
  FLastErrorNumber := 0;
  FLastErrorString := '';
  Result := cDefault;
  {cDefault : process Error with built-in Exception}
  {cTrue    : process the Error with silent Exception(Abort)}
  {cFalse   : ignore the Error}

  Job1 := nJob;

  case ErrType of
    {VCL Error}
    errVCL: Result := VCLError(ErrConst, ErrString);

    {Print Engine Error}
    errEngine:
      begin
        {If there was an error in CRDynamic, show it}
        if CRDErrorStr <> '' then
        begin
          sErrorText := Copy(CRDErrorStr, 1, 2);
          if UpperCase(sErrorText) = 'PE' then
            VCLError(ECRPE_LOAD_DLL_FUNCTION, CRDErrorStr)
          else
          begin
            if CRDErrorStr = CRD_ERROR_LOADING then
              VCLError(ECRPE_LOAD_DLL, '')
            else if CRDErrorStr = CRD_ERROR_FREEING then
              VCLError(ECRPE_FREE_DLL, '')
            else if CRDErrorStr = CRD_ENGINE_NOT_LOADED then
              VCLError(ECRPE_NOT_LOADED, '')
            else
              VCLError(ECRPE_UNDEFINED, CRDErrorStr);
          end;
        end
        {Regular Print Engine Error}
        else
        begin
          SetDLLHandle;
          {Get ErrorNumber}
          FLastErrorNumber := PEGetErrorCode(Job1);
          if FLastErrorNumber = -1 then
          begin
            {Failed to Retrieve Error from Print Engine}
            FLastErrorNumber := GetErrorNum(ECRPE_FAILED_GETTING_ERROR);
            FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
          end
          else
          begin
            {Error Number is zero: undefined}
            if FLastErrorNumber = 0 then
            begin
              SetDLLHandle;
              {Try using the Main Report Job Number}
              Job2 := FSubreports.ListItem(0).FPrintJob;
              FLastErrorNumber := PEGetErrorCode(Job2);
              if FLastErrorNumber <> 0 then
                Job1 := Job2;
            end;
            if FLastErrorNumber = 0 then
            begin
              SetDLLHandle;
              {Try using zero as the Job Number}
              Job2 := 0;
              FLastErrorNumber := PEGetErrorCode(Job2);
              if FLastErrorNumber <> 0 then
                Job1 := Job2;
            end;
            {If all fails, raise error 140: Undefined}
            if FLastErrorNumber = 0 then
            begin
              {Get Undefined Error Number and Error String}
              FLastErrorNumber := GetErrorNum(ECRPE_UNDEFINED);
              FLastErrorString := GetErrorStr(ECRPE_UNDEFINED);
              FLastErrorString := FLastErrorString + chr(10) + ErrString;
            end;

            {Error Number is valid}
            if FLastErrorNumber <> GetErrorNum(ECRPE_UNDEFINED) then
            begin
              SetDLLHandle;
              {Get ErrorString}
              if not PEGetErrorText(Job1, hTextHandle, nTextLen) then
              begin
                {Failed to Retrieve Error from Print Engine}
                //FLastErrorNumber := GetErrorNum(ECRPE_FAILED_GETTING_ERROR);
                FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
              end
              else
              begin
                SetDLLHandle;
                pErrorText := StrAlloc(nTextLen);
                if not PEGetHandleString(hTextHandle, pErrorText, nTextLen) then
                begin
                  StrDispose(pErrorText);
                  {Failed to Retrieve Error from Print Engine}
                  FLastErrorNumber := GetErrorNum(ECRPE_FAILED_GETTING_ERROR);
                  FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
                end
                else
                begin
                  sErrorText := String(pErrorText);
                  {Remove the Period if it exists}
                  if Pos('.', sErrorText) > 0 then
                    sErrorText := Copy(sErrorText, 1, Pos('.', sErrorText) - 1);
                  FLastErrorString := sErrorText + Chr(10) + ErrString;
                  StrDispose(pErrorText);
                end;
              end;
            end;
          end;

          {Check Error Option Flag}
          case Option of
            errNoOption : {Regular error, no options};
            {Formula error}
            errFormula  : FLastErrorString := FLastErrorString + Chr(10) + ErrString;
            {Paging error: trap a ShowNext or ShowPrevious page
             error when on the last or first page}
            errPaging   :
              begin
                if ((FLastErrorNumber = 542) or (FLastErrorNumber = 543)) then
                  Result := cFalse;
              end;
            {Export/Print Error: trap the Cancel error on Export dialog,
             PrintOptions dialog, PrintWindow/ExportWindow, VerifyDatabase}
            errCancelDialog :
              begin
                if (FLastErrorNumber = 545)       {Cancelled}
                or (FLastErrorNumber = 505)       {No destination}
                or (FLastErrorNumber = 524) then  {PrintJob busy}
                  Result := cFalse;
              end;
            {SectionFormatFormulas/AreaFormatFormulas - trap the bad
             formula name error when trying to retrieve Formulas}
            errFormatFormulaName :
              begin
                if (FLastErrorNumber = 510) then
                  Result := cFalse;
              end;
            {ParamFields - trap the error when trying to clear current values
             on a linked Parameter}
            errLinkedParameter :
              begin
                if (FLastErrorNumber = 656) then
                  Result := cFalse;
              end;
          end;

          {If we are not to ignore the error, handle it...}
          if Result = cDefault then
          begin
            {In Design state, show dialog}
            if (csDesigning in ComponentState) then
            begin
              MessageDlg('Error: ' + IntToStr(FLastErrorNumber) +
                Chr(10) + FLastErrorString, mtWarning, [mbOk], 0);
              Result := cFalse;
            end
            {In Runtime state, check OnError event}
            else
            begin
              bIgnoreError := cDefault;
              if Assigned(FOnError) then
              begin
                FOnError(Self, FLastErrorNumber, FLastErrorString, bIgnoreError);
                case bIgnoreError of
                  cFalse   : Result := cTrue;    {Silent Exception: assume user dialog}
                  cTrue    : Result := cFalse;   {Ignore Error}
                  cDefault : Result := cDefault; {Use built-in Exception & dialog}
                end;
              end;
            end;
          end;
        end;
      end;
  end;
end; {GetErrorMsg}

{------------------------------------------------------------------------------}
{ function SubItem                                                             }
{  - Returns a class pointer to the current Subreports Item                    }
{------------------------------------------------------------------------------}
function TCrpe.SubItem : TCrpeSubreportsItem;
begin
  Result := FSubreports.ListItem(FIndex)
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnError                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetOnError : TCrpeErrorEvent;
begin
  Result := FOnError;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnError                                            }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnError (const Value : TCrpeErrorEvent);
begin
  FOnError := Value;
end;

{------------------------------------------------------------------------------}
{ Member procedure SendOutput                                                  }
{------------------------------------------------------------------------------}
function TCrpe.SendOutput : boolean;
var
  {FaxOptions        : PEFaxOptions;}
  {fType             : smallint;}
  nLeft, nTop,
  nWidth, nHeight : DWord;
  xHandle         : hWnd;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;

  case FOutput of
    toWindow :
      begin
        {Left}
        if FWindowSize.FLeft = -1 then
          nLeft := CW_USEDEFAULT
        else
          nLeft := FWindowSize.FLeft;
        {Top}
        if FWindowSize.FTop = -1 then
          nTop := CW_USEDEFAULT
        else
          nTop := FWindowSize.FTop;
        {Width}
        if FWindowSize.FWidth = -1 then
          nWidth := CW_USEDEFAULT
        else
          nWidth := FWindowSize.FWidth;
        {Height}
        if FWindowSize.FHeight = -1 then
          nHeight := CW_USEDEFAULT
        else
          nHeight := FWindowSize.FHeight;
        {Title}
        if LowerCase(FWindowStyle.FTitle) = CrEmptyStr then
          FWindowStyle.FTitle := '';
        {WindowHandle}
        GetWindowParent;
        if FWindowParent = nil then
          xHandle := 0
        else
        begin
          xHandle := FWindowParent.Handle;

          {Check MDIChild}
          if (FWindowParent is TForm) then
          begin
            if TForm(FWindowParent).FormStyle = fsMDIForm then
            begin
              FWindowStyle.FMDIForm := TForm.Create(Self);
              FWindowStyle.FMDIForm.FormStyle := fsMDIChild;
              FWindowStyle.FMDIForm.Caption := FWindowStyle.FTitle;
              FWindowStyle.FMDIForm.OnResize := FWindowStyle.OnMDIResize;
              FWindowStyle.FMDIForm.OnClose := FWindowStyle.OnMDIClose;
              xHandle := FWindowStyle.FMDIForm.Handle;
            end;
          end;
        end;
        SetDLLHandle;
        {Send Output}
        if not PEOutPutToWindow(FPrintJob, PChar(FWindowStyle.FTitle),
          nLeft, nTop, nWidth, nHeight, PreviewWindowStyle, xHandle) then
        begin
          case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
              'SendOutput <PEOutputToWindow>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        Result := True;
      end; {toWindow}

    toPrinter:
      begin
        SetDLLHandle;
        if not PEOutPutToPrinter(FPrintJob, FPrintOptions.Copies) then
        begin
          case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
              'SendOutput <PEOutputToPrinter>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        Result := True;
      end; {toPrinter}
(*
    toFax:
      begin
        {Fax is only available in SCR 7+}
        if FVersion.FMajor < 7 then
        begin
          case GetErrorMsg(0,errNoOption,errVCL,ECRPE_FAX_UNAVAILABLE) of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        SetDLLHandle;
        StrPCopy(FaxOptions.phoneNumber, FFax.FPhoneNumber);
        fType := Ord(FFax.FFaxType);
        if not PEOutPutToFax(FPrintJob, fType, FaxOptions) then
        begin
          case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
              'SendOutput <PEOutputToFax>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        Result := True;
      end; {toFax}
*)
    toExport:
      begin
        if FExport.Send then
          Result := True;
      end;
  end; {Case Output}
end;

{------------------------------------------------------------------------------}
{ Member function PreviewWindowStyle                                           }
{------------------------------------------------------------------------------}
function TCrpe.PreviewWindowStyle: Integer;
var
  xBorderStyle : TCrFormBorderStyle;
begin
  xBorderStyle := FWindowStyle.FBorderStyle;
  Result := WS_VISIBLE;  {Window is always visible anyway?}
  {Check WindowParent}
  if (FWindowParent <> nil) then
  begin
    Result := Result or (WS_CLIPSIBLINGS or WS_CLIPCHILDREN);
    if (FWindowParent is TForm) then
    begin
      if TForm(FWindowParent).FormStyle = fsMDIForm then
        xBorderStyle := bsNone;
    end;
  end;

  {Check BorderStyle}
  case xBorderStyle of
    {No Sizeable Frame, No Buttons, No SystemMenu, No TitleBar}
    bsNone:
      begin
        Result := Result and (not WS_SYSMENU);
        Result := Result and (not WS_MAXIMIZEBOX);
        Result := Result and (not WS_MINIMIZEBOX);
      end;
    {No Sizeable Frame}
    bsSingle:
      Result := Result or (WS_CAPTION or WS_BORDER);
    {Sizeable Frame}
    bsSizeable:
      Result := Result or (WS_CAPTION or WS_THICKFRAME);
    {No Sizeable Frame, No Min/Max buttons}
    bsDialog:
      begin
        Result := Result or (WS_CAPTION or WS_DLGFRAME);
        Result := Result or WS_SYSMENU;
        Result := Result and (not WS_MAXIMIZEBOX);
        Result := Result and (not WS_MINIMIZEBOX);
      end;
  end;

  {Single and Sizeable can be minimized/maximized or have these control buttons}
  if xBorderStyle in [bsSingle, bsSizeable] then
  begin
    if (FWindowStyle.FSystemMenu = True) then
    begin
      if (FWindowStyle.FMinButton = True) then
        Result := Result or WS_MINIMIZEBOX;
      if (FWindowStyle.FMaxButton = True) then
        Result := Result or WS_MAXIMIZEBOX;
    end;
    if FWindowState = wsMinimized then
      Result := Result or WS_MINIMIZE
    else if FWindowState = wsMaximized then
      Result := Result or WS_MAXIMIZE;
  end
  else
    FWindowState := wsNormal;

  {System Menu}
  if xBorderStyle <> bsNone then
  begin
    if FWindowStyle.FSystemMenu = True then
      Result := Result or WS_SYSMENU;
  end;

  {Disabled}
  if FWindowStyle.FDisabled = True then
    Result := Result or WS_DISABLED;
end;

{------------------------------------------------------------------------------}
{ Read Access method GetWindowState                                            }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowState : TWindowState;
begin
  Result := FWindowState;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetWindowState                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowState(const Value : TWindowState);
const
  ShowCommands: array[TWindowState] of Integer =
    (SW_SHOWNORMAL, SW_MINIMIZE, SW_SHOWMAXIMIZED);
begin
  FWindowState := Value;
  if ReportWindowHandle > 0 then
    Windows.ShowWindow(ReportWindowHandle, ShowCommands[Value]);
end;
{------------------------------------------------------------------------------}
{ Member procedure RetrieveWindowState                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.RetrieveWindowState;
begin
  if ReportWindowHandle > 0 then
  begin
    if IsIconic(ReportWindowHandle) then
      FWindowState := wsMinimized
    else if IsZoomed(ReportWindowHandle) then
      FWindowState := wsMaximized
    else
      FWindowState := wsNormal;
  end;
end; { RetrieveWindowState }

{------------------------------------------------------------------------------}
{ Member function Execute                                                      }
{------------------------------------------------------------------------------}
function TCrpe.Execute: Boolean;
var
  IsCanceled  : Boolean;
  EventInfo   : PEEnableEventInfo;
  nIndex      : integer;
  nSub        : integer;
  nRpt        : integer;
  xJob        : Word;
  RunMain     : boolean;
  sAppName    : string;
  sFileName   : string;
  pAppName    : PChar;
  pFileName   : PChar;
  bLogged     : TCrBoolean;

  {Local procedure WindowCallback}
  function WindowCallback(eventID: smallint;
    pEvent: pointer; Cr: TCrpe): LongBool stdcall;
  var
    Cancel           : boolean;
    GeneralInfo      : PEGeneralPrintWindowEventInfo;
    ZoomInfo         : PEZoomLevelChangingEventInfo;
    GroupTreeInfo    : PEGroupTreeButtonClickedEventInfo;
    CloseButtonInfo  : PECloseButtonClickedEventInfo;
    SearchButtonInfo : PESearchButtonClickedEventInfo;
    ShowGroupInfo    : PEShowGroupEventInfo;
    DrillGroupInfo   : PEDrillOnGroupEventInfo;
    DrillDetailInfo  : PEDrillOnDetailEventInfo;
    ReadingInfo      : PEReadingRecordsEventInfo;
    StartInfo        : PEStartEventInfo;
    StopInfo         : PEStopEventInfo;
    MouseClickInfo   : PEMouseClickEventInfo;
    MouseInfo        : TCrMouseInfo;
    FieldType        : TCrParamFieldType;
    sTmp             : string;
    sCode            : string;
    bTmp1, bTmp2     : boolean;
    Destination      : TCrStartEventDestination;
    JobStatus        : TCrStopEventJobStatus;
    slGroups         : TStringList;
    slFieldNames     : TStringList;
    slFieldValues    : TStringList;
    DrillType        : TCrDrillDownType;
    FieldValueInfo   : PEFieldValueInfo;
    cnt1             : integer;
  begin
    Result := True;
    Cancel := False;
    Cr.FCrpeState := crsInit;

    case eventID of
      PE_CLOSE_PRINT_WINDOW_EVENT :
        begin
          if Assigned(Cr.FwOnCloseWindow) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
              Cr.FwOnCloseWindow(GeneralInfo.windowHandle, Cancel);
            Result := not Cancel;
          end;
        end;
      PE_ACTIVATE_PRINT_WINDOW_EVENT :
        begin
          if Assigned(Cr.FwOnActivateWindow) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnActivateWindow(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_DEACTIVATE_PRINT_WINDOW_EVENT :
        begin
          if Assigned(Cr.FwOnDeActivateWindow) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnDeActivateWindow(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_PRINT_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnPrintBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnPrintBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_EXPORT_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnExportBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnExportBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_ZOOM_CONTROL_SELECTED_EVENT :
        begin
          if Assigned(Cr.FwOnZoomLevelChange) then
          begin
            ZoomInfo := PEZoomLevelChangingEventInfo(pEvent^);
            if (ZoomInfo.structSize = SizeOf(PEZoomLevelChangingEventInfo)) then
            begin
              Cr.FwOnZoomLevelChange(ZoomInfo.windowHandle,
                ZoomInfo.zoomLevel, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_FIRST_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnFirstPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnFirstPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_PREVIOUS_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnPreviousPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnPreviousPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_NEXT_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnNextPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnNextPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_LAST_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnLastPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnLastPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_CANCEL_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnCancelBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnCancelBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_CLOSE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnCloseBtnClick) then
          begin
            CloseButtonInfo := PECloseButtonClickedEventInfo(pEvent^);
            if (CloseButtonInfo.structSize = SizeOf(PECloseButtonClickedEventInfo)) then
            begin
              Cr.FwOnCloseBtnClick(CloseButtonInfo.windowHandle,
                CloseButtonInfo.viewIndex, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_SEARCH_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnSearchBtnClick) then
          begin
            SearchButtonInfo := PESearchButtonClickedEventInfo(pEvent^);
            if (SearchButtonInfo.structSize = SizeOf(PESearchButtonClickedEventInfo)) then
            begin
              sTmp := String(PESearchStringType(SearchButtonInfo.searchString));
              Cr.FwOnSearchBtnClick(SearchButtonInfo.windowHandle,
                sTmp, Cancel);
              if not Cancel then
                StrCopy(PESearchStringType(SearchButtonInfo.searchString), PChar(sTmp));
              Result := not Cancel;
            end;
          end;
        end;
      PE_GROUPTREE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnGroupTreeBtnClick) then
          begin
            GroupTreeInfo := PEGroupTreeButtonClickedEventInfo(pEvent^);
            if (GroupTreeInfo.structSize = SizeOf(PEGroupTreeButtonClickedEventInfo)) then
            begin
              bTmp1 := False;
              case GroupTreeInfo.visible of
                0: bTmp1 := False;
                1: bTmp1 := True;
              end;
              Cr.FwOnGroupTreeBtnClick(GroupTreeInfo.windowHandle,
                bTmp1, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_PRINT_SETUP_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnPrintSetupBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnPrintSetupBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_REFRESH_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnRefreshBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnRefreshBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_SHOW_GROUP_EVENT :
        begin
          if Assigned(Cr.FwOnShowGroup) then
          begin
            ShowGroupInfo := PEShowGroupEventInfo(pEvent^);
            if (ShowGroupInfo.structSize = SizeOf(PEShowGroupEventInfo)) then
            begin
              slGroups := TStringList.Create;
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              for cnt1 := 0 to ShowGroupInfo.groupLevel - 1 do
              begin
                slGroups.Add(String(ShowGroupInfo.groupList^[cnt1]));
              end;
              {$IFDEF CKRANGE}
                {$UNDEF CKRANGE}
                {$R+}
              {$ENDIF}
              Cr.FwOnShowGroup(ShowGroupInfo.windowHandle, ShowGroupInfo.groupLevel,
                slGroups, Cancel);
              slGroups.Free;
              Result := not Cancel;
            end;
          end;
        end;
      PE_DRILL_ON_GROUP_EVENT :
        begin
          if Assigned(Cr.FwOnDrillGroup) then
          begin
            DrillGroupInfo := PEDrillOnGroupEventInfo(pEvent^);
            if (DrillGroupInfo.structSize = SizeOf(PEDrillOnGroupEventInfo)) then
            begin
              slGroups := TStringList.Create;
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              for cnt1 := 0 to DrillGroupInfo.groupLevel - 1 do
              begin
                slGroups.Add(String(DrillGroupInfo.groupList^[cnt1]));
              end;
              {$IFDEF CKRANGE}
                {$UNDEF CKRANGE}
                {$R+}
              {$ENDIF}
              DrillType := TCrDrillDownType(DrillGroupInfo.drillType);
              Cr.FwOnDrillGroup(DrillGroupInfo.windowHandle,
                DrillGroupInfo.groupLevel, DrillType, slGroups, Cancel);
              slGroups.Free;
              Result := not Cancel;
            end;
          end;
        end;
      PE_DRILL_ON_DETAIL_EVENT :
        begin
          if Assigned(Cr.FwOnDrillDetail) then
          begin
            DrillDetailInfo := PEDrillOnDetailEventInfo(pEvent^);
            if (DrillDetailInfo.structSize = SizeOf(PEDrillOnDetailEventInfo)) then
            begin
              slFieldNames := TStringList.Create;
              slFieldValues := TStringList.Create;
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              if DrillDetailInfo.selectedFieldIndex <> -1 then
              begin
                for cnt1 := 0 to (DrillDetailInfo.nFieldValue - 1) do
                begin
                  FieldValueInfo := (DrillDetailInfo.fieldValueList^[cnt1])^;
                  if FieldValueInfo.structSize = SizeOf(PEFieldValueInfo) then
                  begin
                    slFieldNames.Add(String(FieldValueInfo.fieldName));
                    with FieldValueInfo.fieldValue do
                    begin
                      case valueType of
                        PE_VI_NUMBER   : begin
                                           Str(viNumber:0:2, sTmp);
                                           slFieldValues.Add(sTmp);
                                         end;
                        PE_VI_CURRENCY : begin
                                           Str(viCurrency:0:2, sTmp);
                                           slFieldValues.Add(sTmp);
                                         end;
                        PE_VI_BOOLEAN  : slFieldValues.Add(CrBooleanToStr(viBoolean, False));
                        PE_VI_DATE     : slFieldValues.Add(IntToStr(viDate[0]) + ',' +
                                           IntToStr(viDate[1]) + ',' + IntToStr(viDate[2]));
                        PE_VI_STRING   : slFieldValues.Add(viString);
                        PE_VI_DATETIME : slFieldValues.Add(IntToStr(viDateTime[0]) + ',' +
                                           IntToStr(viDateTime[1]) + ',' + IntToStr(viDateTime[2]) + ' ' +
                                           IntToStr(viDateTime[3]) + ':' + IntToStr(viDateTime[4]) + ':' +
                                           IntToStr(viDateTime[5]));
                        PE_VI_TIME     : slFieldValues.Add(IntToStr(viTime[0]) + ':' +
                                           IntToStr(viTime[1]) + ':' + IntToStr(viTime[2]));
                        PE_VI_INTEGER  : slFieldValues.Add(IntToStr(viInteger));
                        PE_VI_COLOR    : slFieldValues.Add(IntToStr(viColor));
                        PE_VI_CHAR     : slFieldValues.Add(viC);
                        PE_VI_LONG     : slFieldValues.Add(IntToStr(viLong));
                        PE_VI_NOVALUE  : slFieldValues.Add('');
                      end;
                    end;
                  end;
                end;
              end;
              {$IFDEF CKRANGE}
                {$UNDEF CKRANGE}
                {$R+}
              {$ENDIF}
              Cr.FwOnDrillDetail(DrillDetailInfo.windowHandle,
                DrillDetailInfo.selectedFieldIndex, DrillDetailInfo.nFieldValue,
                slFieldNames, slFieldValues, Cancel);
              slFieldNames.Free;
              slFieldValues.Free;
              Result := not Cancel;
            end;
          end;
        end;
      PE_READING_RECORDS_EVENT :
        begin
          if Assigned(Cr.FwOnReadingRecords) then
          begin
            ReadingInfo := PEReadingRecordsEventInfo(pEvent^);
            if (ReadingInfo.structSize = SizeOf(PEReadingRecordsEventInfo)) then
            begin
              bTmp1 := False;
              bTmp2 := False;
              case ReadingInfo.cancelled of
                0: bTmp1 := False;
                1: bTmp1 := True;
              end;
              case ReadingInfo.done of
                0: bTmp2 := False;
                1: bTmp2 := True;
              end;
              Cr.FwOnReadingRecords(bTmp1, ReadingInfo.recordsRead,
                ReadingInfo.recordsSelected, bTmp2, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_START_EVENT :
        begin
          if Assigned(Cr.FwOnStartEvent) then
          begin
            StartInfo := PEStartEventInfo(pEvent^);
            if (StartInfo.structSize = SizeOf(PEStartEventInfo)) then
            begin
              Destination := TCrStartEventDestination(StartInfo.destination);
              Cr.FwOnStartEvent(Destination, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_STOP_EVENT :
        begin
          if Assigned(Cr.FwOnStopEvent) then
          begin
            StopInfo := PEStopEventInfo(pEvent^);
            if (StopInfo.structSize = SizeOf(PEStopEventInfo)) then
            begin
              Destination := TCrStartEventDestination(StopInfo.destination);
              JobStatus := TCrStopEventJobStatus(StopInfo.jobStatus);
              Cr.FwOnStopEvent(Destination, JobStatus, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_RIGHT_CLICK_EVENT,
      PE_LEFT_CLICK_EVENT,
      PE_MIDDLE_CLICK_EVENT:
        begin
          if Assigned(Cr.FwOnMouseClick) then
          begin
            MouseClickInfo := PEMouseClickEventInfo(pEvent^);
            if (MouseClickInfo.structSize = SizeOf(PEMouseClickEventInfo)) then
            begin
              MouseInfo.Action := TCrMouseClickAction(MouseClickInfo.clickAction);
              if (MouseClickInfo.clickFlags and PE_CF_NONE) = PE_CF_NONE then
              begin
                MouseInfo.ShiftKey := False;
                MouseInfo.ControlKey := False;
                MouseInfo.Button := mcNone;
              end;
              if (MouseClickInfo.clickFlags and PE_CF_SHIFTKEY) = PE_CF_SHIFTKEY then
                MouseInfo.ShiftKey := True;
              if (MouseClickInfo.clickFlags and PE_CF_CONTROLKEY) = PE_CF_CONTROLKEY then
                MouseInfo.ControlKey := True;
              if (MouseClickInfo.clickFlags and PE_CF_LBUTTON) = PE_CF_LBUTTON then
                MouseInfo.Button := mcLeft;
              if (MouseClickInfo.clickFlags and PE_CF_RBUTTON) = PE_CF_RBUTTON then
                MouseInfo.Button := mcRight;
              if (MouseClickInfo.clickFlags and PE_CF_MBUTTON) = PE_CF_MBUTTON then
                MouseInfo.Button := mcMiddle;
              MouseInfo.x := MouseClickInfo.xOffset;
              MouseInfo.y := MouseClickInfo.yOffset;
              sTmp := ValueInfoToStr(MouseClickInfo.fieldValue);
              if MouseClickInfo.fieldValue.valueType = PE_VI_NOVALUE then
                FieldType := pfNoValue
              else
                FieldType := TCrParamFieldType(MouseClickInfo.fieldValue.valueType);
              {Convert Section Code to String, 'GH1a', etc.}
              sCode := SectionCodeToStr(MouseClickInfo.sectionCode);
              {Do the OnMouseClick event}
              Cr.FwOnMouseClick(MouseClickInfo.windowHandle, MouseInfo,
                sTmp, FieldType, sCode, MouseClickInfo.objectHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
    end; //CASE eventID
    Cr.FCrpeState := crsSetup;
  end;

{Main procedure: TCrpe.Execute}
begin
  Result := False;
  {Check the Init State}
  if (FCrpeState = crsInit) then
    Exit;

  {Check the PromptOnOverwrite property}
  if (FOutput = toExport) and
     (FExport.FPromptOnOverwrite = True) and
     (FExport.FFileType <> ODBCTable) and
     ((FExport.FDestination = toFile) or (FExport.FDestination = toApplication)) then
  begin
    if FileExists(FExport.FFileName) then
    begin
      if MessageBox(0, 'Export FileName already exists.  Overwrite?', 'Export Warning',
      mb_OKCancel + mb_DefButton1 + mb_IconQuestion + mb_TaskModal) <> IDOK then
        Exit;
    end;
  end;

  {Check that the PrintJob is open}
  if not OpenPrintJob then
    Exit;

  {Store current Report Number}
  nSub := FSubreports.FIndex;
  {Determine if a Subreport is being executed}
  RunMain := True;
  if (nSub > 0) and (FSubreports.FSubExecute = True) then
    RunMain := False;

  IsCanceled := False;
  {Do the OnExecute event}
  if not (csDesigning in ComponentState) then
  begin
    FCrpeState := crsInit;
    if Assigned(FOnExecuteBegin) then
      FOnExecuteBegin(Self, IsCanceled);
    FCrpeState := crsSetup;
    if IsCanceled then
      Result := False;
  end;

  if not IsCanceled then
  begin
    {If SubExecute is set to False}
    if RunMain then
    begin
      {Start with Main Report}
      FSubreports.SetIndex(0);
      if FSubreports.Count = 1 then
        FSubreports.Retrieve;
      nRpt := (FSubreports.Count - 1);
    end
    else
      nRpt := 0;

    if FSendOnExecute then
    begin
      for nIndex := nRpt downto 0 do
      begin
        {Update the Report Info pointer}
        if RunMain then
          FSubreports.SetIndex(nIndex);

        {DiscardSavedData}
        if (nIndex = 0) and (FDiscardSavedData = True) then
          DiscardData;
        {ReportOptions}
        SubItem.FReportOptions.Send;

        {Send LogOn: either Connect or LogOnInfo}
        case FConnectMethod of
          useConnect   : SubItem.FConnect.Send;
          useLogOnInfo :
            begin
              if RunMain and (nIndex <> 0) and
                (FSubreports.ListItem(0).FLogOnInfo.FPromptForLogOn = True) then
                {skip LogOn}
              else
              begin
                bLogged := SubItem.FLogOnInfo.Send;
                if (bLogged = cFalse) and (SubItem.FLogOnInfo.FPromptForLogOn = True) then
                begin
                  FSubreports.SetIndex(nSub);
                  Exit;
                end;
              end;
            end;
        end;

        SubItem.FTables.Send;
        SubItem.FSessionInfo.Send;
        SubItem.FSQL.FParams.Send;
        SubItem.FParamFields.Send;
        SubItem.FSQL.FExpressions.Send;
        SubItem.FSQL.Send;  {SQL Query}

        {Remapping fields could affect other calls: Do it first!}
        {Only applies to SCR7+}
        if FVersion.FMajor > 6 then
        begin
          if SubItem.FFieldMapping <> fmAuto then
          begin
            if not VerifyDatabase then
            begin
              FSubreports.SetIndex(nSub);
              Exit;
            end;
          end;
        end;

        SubItem.FFormulas.Send;
        SubItem.FSortFields.Send;
        SubItem.FGroupSortFields.Send;
        SubItem.FGroupCondition.Send;
        SubItem.FGroupOptions.Send;
        SubItem.FSelection.Send;
        SubItem.FGroupSelection.Send;
        SubItem.FSectionHeight.Send;
        SubItem.FSectionFont.Send;
        SubItem.FSectionFormat.Send;
        SubItem.FSectionFormatFormulas.Send;
        SubItem.FAreaFormat.Send;
        SubItem.FAreaFormatFormulas.Send;
        SubItem.FGraphType.Send;
        SubItem.FGraphText.Send;
        SubItem.FGraphOptions.Send;
        SubItem.FGraphOptionInfo.Send;
        SubItem.FGraphData.Send;
        SubItem.FGraphAxis.Send;
        SubItem.FMargins.Send;
        SendDetailCopies;

        {These properties are set for the Main Report only,
         or for the Subreport if SubExecute is True}
        if nIndex = 0 then
        begin
          FPrintDate.Send;
          FSummaryInfo.Send;
          {PrintOptions}
          if FPrintOptions.Send = cFalse then
          begin
            FSubreports.SetIndex(nSub);
            Exit;
          end;
          {Printer}
          if FPrinter.Send = cFalse then
          begin
            FSubreports.SetIndex(nSub);
            Exit;
          end;
          {DialogParent}
          SendDialogParent;
          {WindowButtonBar}
          if (FOutput = toWindow) then
          begin
            FWindowButtonBar.Send;
            FWindowCursor.Send;
          end
          else
          begin
            {ProgressDialog}
            SendProgressDialog;
          end;
          {Output}
          if not SendOutput then
          begin
            FSubreports.SetIndex(nSub);
            Exit;
          end;
        end;
      end;
      {Send ReportTitle after, since it could affect
       Subreport Names and ParamFields}
      for nIndex := nRpt downto 0 do
      begin
        {Update the Report Info pointer}
        if RunMain then
          FSubreports.SetIndex(nIndex);
        SendReportTitle;
      end;
    end;

    if not (csDesigning in ComponentState) then
    begin
      {Check the OnExecuteDoneSend Event}
      FCrpeState := crsInit;
      if Assigned(FOnExecuteDoneSend) then
        FOnExecuteDoneSend(Self, IsCanceled);
      FCrpeState := crsSetup;
      if IsCanceled then
      begin
        if (FPrintJob > 0) then
          FSubreports.SetIndex(nSub);
        Exit;
      end;
    end;

    {Enable WindowEvents}
    if (FOutput = toWindow) and (FWindowEvents = True) and
       (FVersion.FMajor > 5) then
    begin
      {Set EventInfo items off}
      EventInfo.startStopEvent := 0;
      EventInfo.readingRecordEvent := 0;
      EventInfo.printWindowButtonEvent := 0;
      EventInfo.drillEvent := 0;
      EventInfo.closePrintWindowEvent := 0;
      EventInfo.activatePrintWindowEvent := 0;
      EventInfo.fieldMappingEvent := 0;
      EventInfo.mouseClickEvent := 0;

      {Set applicable EventInfo items on}
      if Assigned(FwOnCloseWindow) then
      begin
        EventInfo.closePrintWindowEvent := 1;
        EventInfo.activatePrintWindowEvent := 1;
      end;
      if Assigned(FwOnActivateWindow) or
         Assigned(FwOnDeActivateWindow) then
      begin
        EventInfo.activatePrintWindowEvent := 1;
      end;
      if Assigned(FwOnPrintBtnClick) or
         Assigned(FwOnExportBtnClick) or
         Assigned(FwOnExportBtnClick) or
         Assigned(FwOnFirstPageBtnClick) or
         Assigned(FwOnPreviousPageBtnClick) or
         Assigned(FwOnNextPageBtnClick) or
         Assigned(FwOnLastPageBtnClick) or
         Assigned(FwOnCancelBtnClick) or
         Assigned(FwOnSearchBtnClick) or
         Assigned(FwOnGroupTreeBtnClick) or
         Assigned(FwOnRefreshBtnClick) then
      begin
        EventInfo.startStopEvent := 1;
        EventInfo.printWindowButtonEvent := 1;
      end;
      if Assigned(FwOnZoomLevelChange) or
         Assigned(FwOnCloseBtnClick) or
         Assigned(FwOnPrintSetupBtnClick) then
      begin
        EventInfo.printWindowButtonEvent := 1;
      end;
      if Assigned(FwOnShowGroup) or
         Assigned(FwOnDrillGroup) then
      begin
        EventInfo.startStopEvent := 1;
        EventInfo.drillEvent := 1;
      end;
      if Assigned(FwOnDrillDetail) then
        EventInfo.drillEvent := 1;
      if Assigned(FwOnReadingRecords) then
        EventInfo.readingRecordEvent := 1;
      if Assigned(FwOnStartEvent) or
         Assigned(FwOnStopEvent) then
      begin
        EventInfo.startStopEvent := 1;
      end;
      if Assigned(FwOnMouseClick) then
        EventInfo.mouseClickEvent := 1;

      SetDLLHandle;
      {Enable Events}
      if not PEEnableEvent(FPrintJob, EventInfo) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'Execute <PEEnableEvent>') of
          cFalse   : {Ignore};
          cTrue    : begin
              if FPrintJob > 0 then
                FSubreports.SetIndex(nSub);
              Abort;
            end;
          cDefault : begin
              if FPrintJob > 0 then
                FSubreports.SetIndex(nSub);
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;

      SetDLLHandle;
      {Set Event Callback function}
      if not PESetEventCallback(FPrintJob, @WindowCallback, Self) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'Execute <PESetEventCallback>') of
          cFalse   : {Ignore};
          cTrue    : begin
              if FPrintJob > 0 then
                FSubreports.SetIndex(nSub);
              Abort;
            end;
          cDefault : begin
              if FPrintJob > 0 then
                FSubreports.SetIndex(nSub);
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
    end;

    SetDLLHandle;
    {StartPrintJob}
    if not PEStartPrintJob(FPrintJob, True) then
    begin
      xJob := FPrintJob;
      if FPrintJob > 0 then
        FSubreports.SetIndex(nSub);
      case GetErrorMsg(xJob,errCancelDialog,errEngine,'',
          'Execute <PEStartPrintJob>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    Result := True;

    {WindowZoom}
    if FSendOnExecute then
    begin
      if (FOutput = toWindow) then
        FWindowZoom.Send;
    end;

    if not (csDesigning in ComponentState) then
    begin
      {Check the OnExecuteEnd Event}
      FCrpeState := crsInit;
      if Assigned(FOnExecuteEnd) then
        FOnExecuteEnd(Self);
      FCrpeState := crsSetup;

      {Check the OnPrintEnded Event}
      if Assigned(FOnPrintEnded) then
      begin
        if FOutput <> toWindow then
        begin
          while not PrintEnded do
            Application.ProcessMessages;
          FCrpeState := crsInit;
          FOnPrintEnded(Self);
          FCrpeState := crsSetup;
        end;
      end;

      {Check the OnWindowClose Event}
      if Assigned(FOnWindowClose) then
      begin
        if ReportWindowHandle > 0 then
        begin
          while ReportWindowHandle > 0 do
            Application.ProcessMessages;
          FCrpeState := crsInit;
          FOnWindowClose(Self);
          FCrpeState := crsSetup;
        end;
      end;
    end;

    {Export to Application}
    if (FOutput = toExport) and (FExport.FDestination = toApplication) then
    begin
      {If SCR 7+, and AppName is not defined,
       StartPrintJob already handled the process}
      if not (IsStrEmpty(FExport.FAppName) and (FVersion.FMajor > 6)) then
      begin
        sAppName := Trim(FExport.FAppName);
        sFileName := Trim(FExport.FFileName);
        {Copy the AppName to PChar}
        pAppName := PChar(sAppName);
        {Copy the Export FileName to PChar}
        pFileName := PChar(sFileName);
        {Make sure Report is finished processing}
        while not PrintEnded do
          Application.ProcessMessages;
        {Run Application}
        ShellExecute(0, 'open', pAppName, pFileName, nil, SW_SHOWNORMAL);
      end;
    end;
  end;
  {Reset Subreport Index: making sure the number is still valid,
   ie., CloseJob wasn't called in an event}
  if (FPrintJob > 0) and (nSub < FSubreports.Count) then
    FSubreports.SetIndex(nSub);
  FCrpeState := crsSetup;
end; { Member Execute }

{------------------------------------------------------------------------------}
{ Member procedure CancelJob                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.CancelJob;
begin
  if (FPrintJob = 0) then
    Exit;
  SetDLLHandle;
  PECancelPrintJob(FPrintJob);
end;

{------------------------------------------------------------------------------}
{ Read access method GetCanCloseEngine                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetCanCloseEngine : boolean;
begin
  Result := True;
  if (hDLL = 0) then
    Exit;
  SetDLLHandle;
  Result := PECanCloseEngine;
end;

{------------------------------------------------------------------------------}
{ Read access method GetIsJobFinished                                          }
{------------------------------------------------------------------------------}
function TCrpe.GetIsJobFinished : boolean;
begin
  Result := True;
  if (FPrintJob = 0) then
    Exit;
  SetDLLHandle;
  Result := PEIsPrintJobFinished(FPrintJob);
end;

{------------------------------------------------------------------------------}
{ Access method GetStatus                                                      }
{------------------------------------------------------------------------------}
function TCrpe.GetStatus: Integer;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  FPrintEnded := True;
  if FPrintJob = 0 then
    Exit;
  SetDLLHandle;
  {Get the Status}
  Result := PEGetJobStatus(FPrintJob, JobInfo);
  if Result = -1 then
    Result := 0
  else
    FPrintEnded := JobInfo.PrintEnded;
end;

{------------------------------------------------------------------------------}
{ Access method GetPrintEnded                                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetPrintEnded: Boolean;
begin
  GetStatus;
  Result := FPrintEnded;
end;

{------------------------------------------------------------------------------}
{ Member function LogOnPrivateInfo                                             }
{------------------------------------------------------------------------------}
function TCrpe.LogOnPrivateInfo(DllName: string; PrivateInfo: pointer): boolean;
begin
  Result := False;
  if not OpenPrintEngine then
    Exit;
  SetDLLHandle;
  Result := PELogOnSQLServerWithPrivateInfo(PChar(DllName), PrivateInfo);
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnCreate                                             }
{------------------------------------------------------------------------------}
function TCrpe.GetOnCreate: TNotifyEvent;
begin
  Result := FOnCreate;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnCreate                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnCreate(const Value: TNotifyEvent);
begin
  FOnCreate := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnJobOpened                                          }
{------------------------------------------------------------------------------}
function TCrpe.GetOnJobOpened: TCrpeJobNumEvent;
begin
  Result := FOnJobOpened;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnJobOpened                                        }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnJobOpened(const Value: TCrpeJobNumEvent);
begin
  FOnJobOpened := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnExecuteBegin                                       }
{------------------------------------------------------------------------------}
function TCrpe.GetOnExecuteBegin : TCrpeCancelEvent;
begin
  Result := FOnExecuteBegin;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnExecuteBegin                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnExecuteBegin(const Value: TCrpeCancelEvent);
begin
  FOnExecuteBegin := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnExecuteDoneSend                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetOnExecuteDoneSend : TCrpeCancelEvent;
begin
  Result := FOnExecuteDoneSend;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnExecuteDoneSend                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnExecuteDoneSend(const Value: TCrpeCancelEvent);
begin
  FOnExecuteDoneSend := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnExecuteEnd                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetOnExecuteEnd : TNotifyEvent;
begin
  Result := FOnExecuteEnd;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnExecuteEnd                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnExecuteEnd(const Value: TNotifyEvent);
begin
  FOnExecuteEnd := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnWindowClose                                        }
{------------------------------------------------------------------------------}
function TCrpe.GetOnWindowClose : TNotifyEvent;
begin
  Result := FOnWindowClose;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnWindowClose                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnWindowClose(const Value: TNotifyEvent);
begin
  FOnWindowClose := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnPrintEnded                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetOnPrintEnded : TNotifyEvent;
begin
  Result := FOnPrintEnded;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnPrintEnded                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnPrintEnded(const Value: TNotifyEvent);
begin
  FOnPrintEnded := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnPrinterSend                                        }
{------------------------------------------------------------------------------}
function TCrpe.GetOnPrinterSend : TCrpePrinterEvent;
begin
  Result := FOnPrinterSend;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnPrinterSend                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnPrinterSend(const Value: TCrpePrinterEvent);
begin
  FOnPrinterSend := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnGetVersion                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetOnGetVersion : TCrpeVersionEvent;
begin
  Result := FOnGetVersion;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnGetVersion                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnGetVersion(const Value: TCrpeVersionEvent);
begin
  FOnGetVersion := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetWindowEvents                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowEvents : boolean;
begin
  Result := FWindowEvents;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindowEvents                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowEvents (const Value: boolean);
begin
  FWindowEvents := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnCloseWindow                                       }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnCloseWindow : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnCloseWindow;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnCloseWindow                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnCloseWindow (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnCloseWindow := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnPrintBtnClick                                     }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnPrintBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnPrintBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnPrintBtnClick                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnPrintBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnPrintBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnExportBtnClick                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnExportBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnExportBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnExportBtnClick                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnExportBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnExportBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnFirstPageBtnClick                                 }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnFirstPageBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnFirstPageBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnFirstPageBtnClick                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnFirstPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnFirstPageBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnPreviousPageBtnClick                              }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnPreviousPageBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnPreviousPageBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnPreviousPageBtnClick                            }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnPreviousPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnPreviousPageBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnNextPageBtnClick                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnNextPageBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnNextPageBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnNextPageBtnClick                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnNextPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnNextPageBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnLastPageBtnClick                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnLastPageBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnLastPageBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnLastPageBtnClick                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnLastPageBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnLastPageBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnCancelBtnClick                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnCancelBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnCancelBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnCancelBtnClick                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnCancelBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnCancelBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnActivateWindow                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnActivateWindow : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnActivateWindow;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnActivateWindow                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnActivateWindow (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnActivateWindow := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnDeActivateWindow                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnDeActivateWindow : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnDeActivateWindow;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnDeActivateWindow                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnDeActivateWindow (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnDeActivateWindow := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnPrintSetupBtnClick                                }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnPrintSetupBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnPrintSetupBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnPrintSetupBtnClick                              }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnPrintSetupBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnPrintSetupBtnClick := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetwOnRefreshBtnClick                                   }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnRefreshBtnClick : TCrpeGeneralPrintWindowEvent;
begin
  Result := FwOnRefreshBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnRefreshBtnClick                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnRefreshBtnClick (const Value: TCrpeGeneralPrintWindowEvent);
begin
  FwOnRefreshBtnClick := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnZoomLevelChange                                   }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnZoomLevelChange : TCrpeZoomLevelChangingEvent;
begin
  Result := FwOnZoomLevelChange;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnZoomLevelChange                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnZoomLevelChange (const Value: TCrpeZoomLevelChangingEvent);
begin
  FwOnZoomLevelChange := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnCloseBtnClick                                     }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnCloseBtnClick : TCrpeCloseButtonClickedEvent;
begin
  Result := FwOnCloseBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnCloseBtnClick                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnCloseBtnClick (const Value: TCrpeCloseButtonClickedEvent);
begin
  FwOnCloseBtnClick := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnSearchBtnClick                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnSearchBtnClick : TCrpeSearchButtonClickedEvent;
begin
  Result := FwOnSearchBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnSearchBtnClick                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnSearchBtnClick (const Value: TCrpeSearchButtonClickedEvent);
begin
  FwOnSearchBtnClick := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnGroupTreeBtnClick                                 }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnGroupTreeBtnClick : TCrpeGroupTreeButtonClickedEvent;
begin
  Result := FwOnGroupTreeBtnClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnGroupTreeBtnClick                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnGroupTreeBtnClick (const Value: TCrpeGroupTreeButtonClickedEvent);
begin
  FwOnGroupTreeBtnClick := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnReadingRecords                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnReadingRecords : TCrpeReadingRecordsEvent;
begin
  Result := FwOnReadingRecords;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnReadingRecords                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnReadingRecords (const Value: TCrpeReadingRecordsEvent);
begin
  FwOnReadingRecords := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnStartEvent                                        }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnStartEvent : TCrpeStartEvent;
begin
  Result := FwOnStartEvent;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnStartEvent                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnStartEvent (const Value: TCrpeStartEvent);
begin
  FwOnStartEvent := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnStopEvent                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnStopEvent : TCrpeStopEvent;
begin
  Result := FwOnStopEvent;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnStopEvent                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnStopEvent (const Value: TCrpeStopEvent);
begin
  FwOnStopEvent := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnShowGroup                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnShowGroup : TCrpeShowGroupEvent;
begin
  Result := FwOnShowGroup;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnShowGroup                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnShowGroup (const Value: TCrpeShowGroupEvent);
begin
  FwOnShowGroup := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnDrillGroup                                        }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnDrillGroup : TCrpeDrillOnGroupEvent;
begin
  Result := FwOnDrillGroup;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnDrillGroup                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnDrillGroup (const Value: TCrpeDrillOnGroupEvent);
begin
  FwOnDrillGroup := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnDrillDetail                                       }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnDrillDetail : TCrpeDrillOnDetailEvent;
begin
  Result := FwOnDrillDetail;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnDrillDetail                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnDrillDetail (const Value: TCrpeDrillOnDetailEvent);
begin
  FwOnDrillDetail := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetOnFieldMapping                                       }
{------------------------------------------------------------------------------}
function TCrpe.GetOnFieldMapping : TCrpeFieldMappingEvent;
begin
  Result := FOnFieldMapping;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetOnFieldMapping                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOnFieldMapping (const Value: TCrpeFieldMappingEvent);
begin
  FOnFieldMapping := Value;
end;

{------------------------------------------------------------------------------}
{ Read member function GetwOnMouseClick                                        }
{------------------------------------------------------------------------------}
function TCrpe.GetwOnMouseClick : TCrpeMouseClickEvent;
begin
  Result := FwOnMouseClick;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetwOnMouseClick                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetwOnMouseClick (const Value: TCrpeMouseClickEvent);
begin
  FwOnMouseClick := Value;
end;

{------------------------------------------------------------------------------}
{ Member function GetJobNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpe.GetJobNumber : Smallint;
begin
  Result := FPrintJob;
end;

(*
{------------------------------------------------------------------------------}
{ Member function GetMultiThread                                               }
{------------------------------------------------------------------------------}
function TCrpe.GetMultiThread : boolean;
begin
  Result := FMultiThread;
end;
{------------------------------------------------------------------------------}
{  Member access method SetMultiThread                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetMultiThread(const Value: boolean);
begin
  FMultiThread := Value;
end;
*)

{------------------------------------------------------------------------------}
{ Member function GetReportName                                                }
{------------------------------------------------------------------------------}
function TCrpe.GetReportName : TCrReportName;
begin
  Result := FReportName;
end;
{------------------------------------------------------------------------------}
{  Member access method SetReportName.                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetReportName(NewName: TCrReportName);
begin
  if CompareText(NewName, FReportName) <> 0 then
  begin
    ClosePrintJob;
    FReportName := NewName;
  end;
end;

{------------------------------------------------------------------------------}
{ SetDLLHandle procedure                                                       }
{  - This is necessary since the CRDynamic handle is global.  If we have more  }
{    than one TCrpe open, we need to differentiate between handles, else       }
{    destroying one TCrpe will set the global CRDEngine var to zero.           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDLLHandle;
begin
  CRDEngine := hDLL;
end;

{------------------------------------------------------------------------------}
{ Write access method SetAbout                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.SetAbout(const Value: TCrAboutBox);
begin
  FAbout := 'Version and Credits...';
end;

{------------------------------------------------------------------------------}
{ Write access method SetDesignControls                                        }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDesignControls (const Value: TCrDesignControls);
begin
  FDesignControls := 'Design-Time Window Controls';
end;

{------------------------------------------------------------------------------}
{ GetLog method                                                                }
{------------------------------------------------------------------------------}
function TCrpe.GetLog: TCrpeLog;
begin
  if (FLog <> nil) then
  begin
    if (FLog is TComponent) then
    begin
      if FLog.ClassName <> 'TCrpeLog' then
      begin
        FLog := nil;
        CRDLog := nil;
      end;
    end
    else
    begin
      FLog := nil;
      CRDLog := nil;
    end;
  end;
  Result := FLog;
end;
{------------------------------------------------------------------------------}
{ SetLog method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetLog (const Value: TCrpeLog);
begin
  if Value <> FLog then
  begin
    FLog := Value;
    {Update the CRDynamic variable}
    CRDLog := Value;
  end;
end;

{------------------------------------------------------------------------------}
{ Read access method GetOutput                                                 }
{------------------------------------------------------------------------------}
function TCrpe.GetOutput : TCrOutput;
begin
  Result := FOutput;
end;
{------------------------------------------------------------------------------}
{ Write access method SetOutput                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetOutput(const Value: TCrOutput);
begin
  FOutput := Value;
end;

{------------------------------------------------------------------------------}
{ Read access method GetDiscardSavedData                                       }
{------------------------------------------------------------------------------}
function TCrpe.GetDiscardSavedData : boolean;
begin
  Result := FDiscardSavedData;
end;
{------------------------------------------------------------------------------}
{ Write access method SetDiscardSavedData                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDiscardSavedData(const Value: boolean);
begin
  FDiscardSavedData := Value;
end;

{------------------------------------------------------------------------------}
{ Read access method GetExport                                                 }
{------------------------------------------------------------------------------}
function TCrpe.GetExport : TCrpeExport;
begin
  Result := FExport;
end;
{------------------------------------------------------------------------------}
{ Write access method SetExport                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetExport(const Value: TCrpeExport);
begin
  FExport.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read access method GetCrpePrinter                                            }
{------------------------------------------------------------------------------}
function TCrpe.GetCrpePrinter : TCrpePrinter;
begin
  Result := FPrinter;
end;
{------------------------------------------------------------------------------}
{ Write access method SetCrpePrinter                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetCrpePrinter(const Value: TCrpePrinter);
begin
  FPrinter.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read access method GetPrintOptions                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetPrintOptions : TCrpePrintOptions;
begin
  Result := FPrintOptions;
end;
{------------------------------------------------------------------------------}
{ Write access method SetPrintOptions                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetPrintOptions(const Value: TCrpePrintOptions);
begin
  FPrintOptions.Assign(Value);
end;

(*
{------------------------------------------------------------------------------}
{ Read access method GetFax                                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetFax : TCrpeFax;
begin
  Result := FFax;
end;
{------------------------------------------------------------------------------}
{ Write access method SetFax                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetFax(const Value: TCrpeFax);
begin
  FFax.Assign(Value);
end;
*)

{------------------------------------------------------------------------------}
{ Read access method GetSendOnExecute                                          }
{------------------------------------------------------------------------------}
function TCrpe.GetSendOnExecute : boolean;
begin
  Result := FSendOnExecute;
end;
{------------------------------------------------------------------------------}
{ Write access method SetSendOnExecute                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSendOnExecute(const Value: boolean);
begin
  FSendOnExecute := Value;
end;

{------------------------------------------------------------------------------}
{ Read access method GetProgressDialog                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetProgressDialog : boolean;
begin
  Result := FProgressDialog;
end;
{------------------------------------------------------------------------------}
{ Write access method SetProgressDialog                                        }
{------------------------------------------------------------------------------}
procedure TCrpe.SetProgressDialog(const Value: boolean);
begin
  FProgressDialog := Value;
end;

{------------------------------------------------------------------------------}
{ Read access method GetLoadEngineOnUse                                        }
{------------------------------------------------------------------------------}
function TCrpe.GetLoadEngineOnUse : boolean;
begin
  Result := FLoadEngineOnUse;
end;
{------------------------------------------------------------------------------}
{ Write access method SetLoadEngineOnUse                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetLoadEngineOnUse(const Value: boolean);
begin
  FLoadEngineOnUse := Value;
end;

{------------------------------------------------------------------------------}
{ Read access method GetFieldMapping                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetFieldMapping : TCrFieldMappingType;
begin
  Result := SubItem.FFieldMapping;
end;
{------------------------------------------------------------------------------}
{ Write access method SetFieldMapping                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetFieldMapping(const Value: TCrFieldMappingType);
begin
  SubItem.FFieldMapping := Value;
end;
{------------------------------------------------------------------------------}
{ RetrieveFieldMapping method                                                  }
{------------------------------------------------------------------------------}
function TCrpe.RetrieveFieldMapping : boolean;
var
  wFieldMapping : Word;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;
  {Need SCR 7+ to do FieldMapping}
  if FVersion.FMajor < 7 then
    Exit;
  wFieldMapping := PE_FM_AUTO_FLD_MAP;

  SetDLLHandle;
  if not PEGetFieldMappingType(FPrintJob, wFieldMapping) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'RetrieveFieldMapping <PEGetFieldMappingType>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  case wFieldMapping of
    PE_FM_AUTO_FLD_MAP          : SubItem.FFieldMapping := fmAuto;
    PE_FM_CRPE_PROMPT_FLD_MAP   : SubItem.FFieldMapping := fmPrompt;
    PE_FM_EVENT_DEFINED_FLD_MAP : SubItem.FFieldMapping := fmEvent;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Member procedure SendFieldMapping                                            }
{------------------------------------------------------------------------------}
function TCrpe.SendFieldMapping : boolean;
var
  wFieldMapping   : Word;
  rptFieldMapping : TCrFieldMappingType;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;
  {Need SCR 7+ to do FieldMapping}
  if FVersion.FMajor < 7 then
    Exit;
  rptFieldMapping := fmAuto;

  SetDLLHandle;
  {Get FieldMapping from Report}
  if not PEGetFieldMappingType(FPrintJob, wFieldMapping) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'SendFieldMapping <PEGetFieldMappingType>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  case wFieldMapping of
    PE_FM_AUTO_FLD_MAP          : rptFieldMapping := fmAuto;
    PE_FM_CRPE_PROMPT_FLD_MAP   : rptFieldMapping := fmPrompt;
    PE_FM_EVENT_DEFINED_FLD_MAP : rptFieldMapping := fmEvent;
  end;

  {Send FieldMapping to Report}
  if SubItem.FFieldMapping <> rptFieldMapping then
  begin
    case SubItem.FFieldMapping of
      fmAuto   : wFieldMapping := PE_FM_AUTO_FLD_MAP;
      fmPrompt : wFieldMapping := PE_FM_CRPE_PROMPT_FLD_MAP;
      fmEvent  : wFieldMapping := PE_FM_EVENT_DEFINED_FLD_MAP;
    end;
    SetDLLHandle;
    if not PESetFieldMappingType(FPrintJob, wFieldMapping) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SendFieldMapping <PESetFieldMappingType>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    Result := True;
  end;
end;

{------------------------------------------------------------------------------}
{ Method VerifyDatabase                                                        }
{------------------------------------------------------------------------------}
function TCrpe.VerifyDatabase : boolean;
var
  EventInfo : PEEnableEventInfo;

  {Local procedure WindowCallback}
  function WindowCallback(eventID: smallint;
    pEvent: Pointer; Cr: TCrpe): LongBool stdcall;
  var
    Cancel           : boolean;
    FieldMappingInfo : PEFieldMappingEventInfo;
    ReportFields     : TList;
    DatabaseFields   : TList;
    RptFields        : TCrFieldMappingInfo;
    DBFields         : TCrFieldMappingInfo;
    cnt1             : integer;
  begin
    Result := True;
    Cancel := False;
    case eventID of
      PE_MAPPING_FIELD_EVENT:
        begin
          if Assigned(Cr.FOnFieldMapping) then
          begin
            FieldMappingInfo := PEFieldMappingEventInfo(pEvent^);
            if (FieldMappingInfo.structSize = SizeOf(PEFieldMappingEventInfo)) then
            begin
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              {Get Report Fields}
              ReportFields := TList.Create;
              for cnt1 := 0 to FieldMappingInfo.nReportFields - 1 do
              begin
                ReportFields.Add(nil);
                ReportFields[cnt1] := TCrFieldMappingInfo.Create;
                RptFields := TCrFieldMappingInfo(ReportFields[cnt1]);
                RptFields.TableName := String(FieldMappingInfo.ReportFields^[cnt1].tableAliasName);
                RptFields.FieldName := String(FieldMappingInfo.ReportFields^[cnt1].databaseFieldName);
                if FieldMappingInfo.ReportFields^[cnt1].valueType = PE_FVT_UNKNOWNFIELD then
                   RptFields.FieldType := fvUnknown
                else
                   RptFields.FieldType := TCrFieldValueType(FieldMappingInfo.ReportFields^[cnt1].valueType);
                RptFields.MapTo := FieldMappingInfo.ReportFields^[cnt1].mappingTo;
              end;
              {Get Database Fields}
              DatabaseFields := TList.Create;
              for cnt1 := 0 to FieldMappingInfo.nDatabaseFields - 1 do
              begin
                DatabaseFields.Add(nil);
                DatabaseFields[cnt1] := TCrFieldMappingInfo.Create;
                DBFields := TCrFieldMappingInfo(DatabaseFields[cnt1]);
                DBFields.TableName := String(FieldMappingInfo.DatabaseFields^[cnt1].tableAliasName);
                DBFields.FieldName := String(FieldMappingInfo.DatabaseFields^[cnt1].databaseFieldName);
                if FieldMappingInfo.DatabaseFields^[cnt1].valueType = PE_FVT_UNKNOWNFIELD then
                   DBFields.FieldType := fvUnknown
                else
                   DBFields.FieldType := TCrFieldValueType(FieldMappingInfo.DatabaseFields^[cnt1].valueType);
                DBFields.MapTo := FieldMappingInfo.DatabaseFields^[cnt1].mappingTo;
              end;
              Cr.FOnFieldMapping(ReportFields, DatabaseFields, Cancel);
              Result := not Cancel;
              {Write back the information}
              if not Cancel then
              begin
                for cnt1 := 0 to FieldMappingInfo.nReportFields - 1 do
                begin
                  if cnt1 < ReportFields.Count then
                  begin
                    RptFields := TCrFieldMappingInfo(ReportFields[cnt1]);
                    StrCopy(FieldMappingInfo.ReportFields^[cnt1].tableAliasName, PChar(RptFields.TableName));
                    StrCopy(FieldMappingInfo.ReportFields^[cnt1].databaseFieldName, PChar(RptFields.FieldName));
                    if RptFields.FieldType = fvUnknown then
                      FieldMappingInfo.ReportFields^[cnt1].valueType := PE_FVT_UNKNOWNFIELD
                    else
                      FieldMappingInfo.ReportFields^[cnt1].valueType := Ord(RptFields.FieldType);
                    FieldMappingInfo.ReportFields^[cnt1].mappingTo := RptFields.MapTo;
                  end;
                end;
                for cnt1 := 0 to FieldMappingInfo.nDatabaseFields - 1 do
                begin
                  if cnt1 < DatabaseFields.Count then
                  begin
                    DBFields := TCrFieldMappingInfo(DatabaseFields[cnt1]);
                    StrCopy(FieldMappingInfo.DatabaseFields^[cnt1].tableAliasName, PChar(DBFields.TableName));
                    StrCopy(FieldMappingInfo.DatabaseFields^[cnt1].databaseFieldName, PChar(DBFields.FieldName));
                    if DBFields.FieldType = fvUnknown then
                      FieldMappingInfo.DatabaseFields^[cnt1].valueType := PE_FVT_UNKNOWNFIELD
                    else
                      FieldMappingInfo.DatabaseFields^[cnt1].valueType := Ord(DBFields.FieldType);
                    FieldMappingInfo.DatabaseFields^[cnt1].mappingTo := DBFields.MapTo;
                  end;
                end;
                {$IFDEF CKRANGE}
                  {$UNDEF CKRANGE}
                  {$R+}
                {$ENDIF}
              end;
              {Free the TLists}
              for cnt1 := (ReportFields.Count - 1) downto 0 do
              begin
                TCrFieldMappingInfo(ReportFields[cnt1]).Free;
                ReportFields.Delete(cnt1);
              end;
              ReportFields.Free;
              for cnt1 := (DatabaseFields.Count - 1) downto 0 do
              begin
                TCrFieldMappingInfo(DatabaseFields[cnt1]).Free;
                DatabaseFields.Delete(cnt1);
              end;
              DatabaseFields.Free;
            end;
          end;
        end;
    end;
  end;

{Main VerifyDatabase function}
begin
  Result := False;
  if not OpenPrintJob then
    Exit;
  {Need SCR 7+ to do VerifyDatabase}
  if FVersion.FMajor < 7 then
    Exit;

  SendFieldMapping;
  {Mapping by Event}
  if SubItem.FFieldMapping = fmEvent then
  begin
    if Assigned(FOnFieldMapping) then
      EventInfo.fieldMappingEvent := 1;
    {Enable Event}
    SetDLLHandle;
    if not PEEnableEvent(FPrintJob, EventInfo) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SendFieldMapping <PEEnableEvent>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    {Set Event Callback function}
    SetDLLHandle;
    if not PESetEventCallback(FPrintJob, @WindowCallback, Self) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'Execute <PESetEventCallback>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
  {Verify Database}
  SetDLLHandle;
  if not PEVerifyDatabase(FPrintJob) then
  begin
    case GetErrorMsg(FPrintJob,errCancelDialog,errEngine,'',
        'VerifyDatabase <PEVerifyDatabase>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end
  else
    Result := True;
end;

{------------------------------------------------------------------------------}
{ Read access method GetVersion                                                }
{------------------------------------------------------------------------------}
function TCrpe.GetVersion : TCrpeVersion;
begin
  Result := FVersion;
end;
{------------------------------------------------------------------------------}
{ Write access method SetVersion                                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetVersion(const Value: TCrpeVersion);
begin
  FVersion.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read access method GetSummaryInfo                                            }
{------------------------------------------------------------------------------}
function TCrpe.GetSummaryInfo : TCrpeSummaryInfo;
begin
  Result := FSummaryInfo;
end;
{------------------------------------------------------------------------------}
{ Write access method SetSummaryInfo                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSummaryInfo(const Value : TCrpeSummaryInfo);
begin
  FSummaryInfo.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read access method GetReportOptions                                          }
{------------------------------------------------------------------------------}
function TCrpe.GetReportOptions : TCrpeReportOptions;
begin
  Result := SubItem.FReportOptions;
end;
{------------------------------------------------------------------------------}
{ Write access method SetReportOptions                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetReportOptions(const Value : TCrpeReportOptions);
begin
  SubItem.FReportOptions.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read access method GetPrintDate                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetPrintDate : TCrpePrintDate;
begin
  Result := FPrintDate;
end;
{------------------------------------------------------------------------------}
{ Write access method SetPrintDate                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetPrintDate(const Value: TCrpePrintDate);
begin
  FPrintDate.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Method GetHasSavedData                                                       }
{------------------------------------------------------------------------------}
function TCrpe.GetHasSavedData : Boolean;
var
  bSavedData : Bool;
begin
  {Use True as default: assume Rpt has Saved Data}
  Result := True;
  if not OpenPrintJob then
    Exit;

  SetDLLHandle;
  if not PEHasSavedData(FPrintJob, bSavedData) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'GetHasSavedData <PEHasSavedData>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := Boolean(bSavedData);
end;

{------------------------------------------------------------------------------}
{ Read access method GetSubreports                                             }
{------------------------------------------------------------------------------}
function TCrpe.GetSubreports : TCrpeSubreports;
begin
  Result := FSubreports;
end;
{------------------------------------------------------------------------------}
{ Write access method SetSubreports                                            }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSubreports (const Value: TCrpeSubreports);
begin
  FSubreports.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetPages                                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetPages : TCrpePages;
begin
  Result := FPages;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetPages                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.SetPages(const Value: TCrpePages);
begin
  FPages.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetRecords                                                }
{------------------------------------------------------------------------------}
function TCrpe.GetRecords : TCrpeRecords;
begin
  Result := FRecords;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetRecords                                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetRecords(const Value: TCrpeRecords);
begin
  FRecords.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Access method GetTables                                                      }
{------------------------------------------------------------------------------}
function TCrpe.GetTables: TCrpeTables;
begin
  Result := SubItem.FTables;
end; { GetTables }
{------------------------------------------------------------------------------}
{ Access method SetTables                                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.SetTables(const Value: TCrpeTables);
begin
  SubItem.FTables.Assign(Value);
end; { SetTables }

{------------------------------------------------------------------------------}
{ Access method GetParamField                                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetParamField: TCrpeParamFields;
begin
  Result := SubItem.FParamFields;
end; { GetParamField }
{------------------------------------------------------------------------------}
{ Access method SetParamField                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetParamField(const Value: TCrpeParamFields);
begin
  SubItem.FParamFields.Assign(Value);
end; { SetParamField }

{------------------------------------------------------------------------------}
{ Access method GetFormulas                                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetFormulas : TCrpeFormulas;
begin
  Result := SubItem.FFormulas;
end; { GetFormulas }
{------------------------------------------------------------------------------}
{ Access method SetFormulas                                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.SetFormulas(const Value: TCrpeFormulas);
begin
  SubItem.FFormulas.Assign(Value);
end; { SetFormulas }

{------------------------------------------------------------------------------}
{ Access method GetSelection                                                   }
{------------------------------------------------------------------------------}
function TCrpe.GetSelection : TCrpeSelection;
begin
  Result := SubItem.FSelection;
end;
{------------------------------------------------------------------------------}
{ Access method SetSelection                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSelection(Value: TCrpeSelection);
begin
  SubItem.FSelection.Assign(Value);
end; { SetSelection }

{------------------------------------------------------------------------------}
{ Access method GetGroupSelection                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetGroupSelection : TCrpeGroupSelection;
begin
  Result := SubItem.FGroupSelection;
end;
{------------------------------------------------------------------------------}
{ Access method SetGroupSelection                                              }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGroupSelection(Value : TCrpeGroupSelection);
begin
  SubItem.FGroupSelection.Assign(Value);
end; { SetGroupSelectionFormula }

{------------------------------------------------------------------------------}
{ Read Access method GetSQL                                                    }
{------------------------------------------------------------------------------}
function TCrpe.GetSQL : TCrpeSQL;
begin
  Result := SubItem.FSQL;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSQL                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSQL(const Value: TCrpeSQL);
begin
  SubItem.FSQL.Assign(Value);
end; { SetSQL }

{------------------------------------------------------------------------------}
{ Access method GetSortFields                                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetSortFields : TCrpeSortFields;
begin
  Result := SubItem.FSortFields;
end; { GetSortFields }
{------------------------------------------------------------------------------}
{ Access method SetSortFields                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSortFields(const Value: TCrpeSortFields);
begin
  SubItem.FSortFields.Assign(Value);
end; { SetSortFields }

{------------------------------------------------------------------------------}
{ Access method GetGroupSortFields                                             }
{------------------------------------------------------------------------------}
function TCrpe.GetGroupSortFields : TCrpeGroupSortFields;
begin
  Result := SubItem.FGroupSortFields;
end; { GetGroupSortFields }
{------------------------------------------------------------------------------}
{ Access method SetGroupSortFields                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGroupSortFields(const Value: TCrpeGroupSortFields);
begin
  SubItem.FGroupSortFields.Assign(Value);
end; { SetGroupSortFields }

{------------------------------------------------------------------------------}
{ Access method GetGroupCondition                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetGroupCondition: TCrpeGroupCondition;
begin
  Result := SubItem.FGroupCondition;
end; { GetGroupCondition }
{------------------------------------------------------------------------------}
{ Access method SetGroupCondition                                              }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGroupCondition(const Value: TCrpeGroupCondition);
begin
  SubItem.FGroupCondition.Assign(Value);
end; { SetGroupCondition }

{------------------------------------------------------------------------------}
{ Access method GetGroupOptions                                                }
{------------------------------------------------------------------------------}
function TCrpe.GetGroupOptions: TCrpeGroupOptions;
begin
  Result := SubItem.FGroupOptions;
end; { GetGroupOptions }
{------------------------------------------------------------------------------}
{ Access method SetGroupOptions                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGroupOptions(const Value: TCrpeGroupOptions);
begin
  SubItem.FGroupOptions.Assign(Value);
end; { SetGroupOptions }


{------------------------------------------------------------------------------}
{ Member function ReportWindowHandle                                           }
{------------------------------------------------------------------------------}
function TCrpe.ReportWindowHandle: hWnd;
begin
  Result := 0;
  if not FEngineOpened then
    Exit;
  SetDLLHandle;
  Result := PEGetWindowHandle(FPrintJob);
end; { ReportWindowHandle }

{------------------------------------------------------------------------------}
{ Member procedure CloseWindow                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.CloseWindow;
begin
  SetDLLHandle;
  if ReportWindowHandle > 0 then
    PECloseWindow(FPrintJob);
end; { CloseWindow }

{------------------------------------------------------------------------------}
{ Member procedure HideWindow                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.HideWindow;
begin
  if ReportWindowHandle > 0 then
    Windows.ShowWindow(ReportWindowHandle, SW_HIDE);
end; { HideWindow }

{------------------------------------------------------------------------------}
{ Member procedure ShowWindow                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.ShowWindow;
begin
  if ReportWindowHandle > 0 then
    Windows.ShowWindow(ReportWindowHandle, SW_SHOWNORMAL);
end; { ShowWindow }

{------------------------------------------------------------------------------}
{ Member function Focused                                                      }
{------------------------------------------------------------------------------}
function TCrpe.Focused: Boolean;
begin
  Result := False;
  if GetActiveWindow = ReportWindowHandle then
    Result := True;
end; { Focused }

{------------------------------------------------------------------------------}
{ Member procedure SetFocus                                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.SetFocus;
begin
  if ReportWindowHandle > 0 then
    Windows.SetFocus(ReportWindowHandle);
end; { SetFocus }

{------------------------------------------------------------------------------}
{ Member procedure PrintWindow                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.PrintWindow;
var
  bWait: Bool;
begin
  if ReportWindowHandle > 0 then
  begin
    SetDLLHandle;
    bWait := True;
    if not PEPrintWindow(FPrintJob, bWait) then
    begin
      case GetErrorMsg(FPrintJob,errCancelDialog,errEngine,'',
          'PrintWindow <PEPrintWindow>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end; { PrintWindow }

{------------------------------------------------------------------------------}
{ Member procedure ExportWindow                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.ExportWindow(const bMail: Boolean);
begin
  if ReportWindowHandle > 0 then
  begin
    SetDLLHandle;
    if not PEExportPrintWindow(FPrintJob, BOOL(bMail), True) then
    begin
      case GetErrorMsg(FPrintJob,errCancelDialog,errEngine,'',
          'ExportWindow <PEExportPrintWindow>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end; { ExportWindow }

{------------------------------------------------------------------------------}
{ Read access method GetWindowParent                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowParent : TCrWinControl;
begin
  if FWindowParent <> nil then
  begin
    try
      if not IsWindow(FWindowParent.Handle) then
        FWindowParent := nil;
    except
      FWindowParent := nil;
    end;
  end;
  Result := FWindowParent;
end;
{------------------------------------------------------------------------------}
{ Write access method SetWindowParent                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowParent (const Value: TCrWinControl);
begin
  if Value <> FWindowParent then
  begin
    FWindowParent := Value;
    if Value <> nil then Value.FreeNotification(Self);
  end;
end;

{------------------------------------------------------------------------------}
{ Read access method GetDialogParent                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetDialogParent: TCrWinControl;
begin
  if FDialogParent <> nil then
  begin
    try
      if not IsWindow(FDialogParent.Handle) then
        FDialogParent := nil;
    except
      FDialogParent := nil;
    end;
  end;
  Result := FDialogParent;
end;
{------------------------------------------------------------------------------}
{ Write access method SetDialogParent                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDialogParent (const Value: TCrWinControl);
begin
  if Value <> FDialogParent then
  begin
    FDialogParent := Value;
    if Value <> nil then Value.FreeNotification(Self);
  end;
end;
{------------------------------------------------------------------------------}
{ Member function SendDialogParent                                             }
{------------------------------------------------------------------------------}
function TCrpe.SendDialogParent : boolean;
var
  xHandle : HWnd;
begin
  Result := False;
  if FPrintJob = 0 then
    Exit;

  {Update DialogParent in case value is invalid}
  GetDialogParent;
  {Assign xHandle}
  if FDialogParent <> nil then
  begin
    xHandle := FDialogParent.Handle;
    {Send the Dialog handle}
    SetDLLHandle;
    if not PESetDialogParentWindow(FPrintJob, xHandle) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SendDialogParent <PESetDialogParentWindow>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    Result := True;
  end;
end;

{------------------------------------------------------------------------------}
{ Member procedure SendProgressDialog                                          }
{------------------------------------------------------------------------------}
function TCrpe.SendProgressDialog : boolean;
begin
  Result := False;
  if (FPrintJob = 0) then
    Exit;

  {Send ProgressDialog setting}
  SetDLLHandle;
  if not PEEnableProgressDialog(FPrintJob, FProgressDialog) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
         'SendProgressDialog <PEEnableProgressDialog>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := True;
end;

{------------------------------------------------------------------------------}
{ function DiscardData                                                         }
{------------------------------------------------------------------------------}
function TCrpe.DiscardData : boolean;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;
  SetDLLHandle;
  if not PEDiscardSavedData(FPrintJob) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'DiscardData <PEDiscardSavedData>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := True;
end;


{------------------------------------------------------------------------------}
{ Read Access method GetReportTitle                                            }
{------------------------------------------------------------------------------}
function TCrpe.GetReportTitle: string;
begin
  Result := SubItem.FReportTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetReportTitle                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetReportTitle(const Value: string);
begin
  SubItem.FReportTitle := Value;
end;
{------------------------------------------------------------------------------}
{ RetrieveReportTitle method                                                   }
{------------------------------------------------------------------------------}
function TCrpe.RetrieveReportTitle : boolean;
var
  hTitle : HWnd;
  nTitle : Smallint;
  pTitle : PChar;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;

  {Get ReportTitle}
  SetDLLHandle;
  if not PEGetReportTitle(FPrintJob, hTitle, nTitle) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'RetrieveReportTitle <PEGetReportTitle>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  SetDLLHandle;
  {Get the ReportTitle text}
  pTitle := StrAlloc(nTitle);
  if not PEGetHandleString(hTitle, pTitle, nTitle) then
  begin
    StrDispose(pTitle);
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
         'RetrieveReportTitle <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  SubItem.FReportTitle := String(pTitle);
  StrDispose(pTitle);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Member procedure SendReportTitle                                             }
{------------------------------------------------------------------------------}
function TCrpe.SendReportTitle : boolean;
var
  hTitle : HWnd;
  nTitle : Smallint;
  pTitle : PChar;
  sTitle : string;
begin
  Result := False;
  if SubItem.FReportTitle = '' then
    Exit;
  if not OpenPrintJob then
    Exit;

  {Convert CrEmptyStr}
  if LowerCase(SubItem.FReportTitle) = CrEmptyStr then
    SubItem.FReportTitle := '';

  SetDLLHandle;
  {Get ReportTitle}
  if not PEGetReportTitle(FPrintJob, hTitle, nTitle) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'RetrieveReportTitle <PEGetReportTitle>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  SetDLLHandle;
  {Get the ReportTitle text}
  pTitle := StrAlloc(nTitle);
  if not PEGetHandleString(hTitle, pTitle, nTitle) then
  begin
    StrDispose(pTitle);
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
         'SendReportTitle <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  sTitle := String(pTitle);
  StrDispose(pTitle);

  SetDLLHandle;
  {Set ReportTitle}
  if CompareStr(SubItem.FReportTitle, sTitle) <> 0 then
  begin
    if not PESetReportTitle(FPrintJob, PChar(SubItem.FReportTitle)) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SendReportTitle <PESetReportTitle>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    Result := True;
  end;
end;

{------------------------------------------------------------------------------}
{ Read Access method GetDetailCopies                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetDetailCopies : Smallint;
begin
  Result := SubItem.FDetailCopies;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDetailCopies                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDetailCopies(const Value: Smallint);
begin
  SubItem.FDetailCopies := Value;
end;
{------------------------------------------------------------------------------}
{ RetrieveDetailCopies method                                                  }
{------------------------------------------------------------------------------}
function TCrpe.RetrieveDetailCopies : boolean;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;

  SetDLLHandle;
  if not PEGetNDetailCopies(FPrintJob, SubItem.FDetailCopies) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'RetrieveDetailCopies <PEGetNDetailCopies>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member procedure SendDetailCopies                                            }
{------------------------------------------------------------------------------}
function TCrpe.SendDetailCopies : boolean;
var
  rptDCopies : Smallint;
begin
  Result := False;
  if not OpenPrintJob then
    Exit;

  SetDLLHandle;
  {Get DetailCopies from Report}
  if not PEGetNDetailCopies(FPrintJob, rptDCopies) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
       'SendDetailCopies <PEGetNDetailCopies>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  {Send DetailCopies to Report}
  if SubItem.FDetailCopies <> rptDCopies then
  begin
    SetDLLHandle;
    if not PESetNDetailCopies(FPrintJob, SubItem.FDetailCopies) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
         'SendDetailCopies <PESetNDetailCopies>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    Result := True;
  end;
end;

{------------------------------------------------------------------------------}
{ Access method GetMargins                                                     }
{------------------------------------------------------------------------------}
function TCrpe.GetMargins : TCrpeMargins;
begin
  Result := SubItem.FMargins;
end;
{------------------------------------------------------------------------------}
{ Access method SetMargins                                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.SetMargins(const Value: TCrpeMargins);
begin
  SubItem.FMargins.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetConnectMethod                                          }
{------------------------------------------------------------------------------}
function TCrpe.GetConnectMethod : TCrConnectMethod;
begin
  Result := FConnectMethod;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetConnectMethod                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetConnectMethod(const Value: TCrConnectMethod);
begin
  FConnectMethod := Value;
end;

{------------------------------------------------------------------------------}
{ Read Access method GetConnect                                                }
{------------------------------------------------------------------------------}
function TCrpe.GetConnect : TCrpeConnect;
begin
  Result := SubItem.FConnect;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetConnect                                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetConnect(const Value: TCrpeConnect);
begin
  SubItem.FConnect.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetLogOnInfo                                               }
{------------------------------------------------------------------------------}
function  TCrpe.GetLogOnInfo: TCrpeLogOnInfo;
begin
  Result := SubItem.FLogOnInfo;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetLogOnInfo                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetLogOnInfo(const Value: TCrpeLogOnInfo);
begin
  SubItem.FLogOnInfo.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetLogOnServer                                            }
{------------------------------------------------------------------------------}
function TCrpe.GetLogOnServer : TCrpeLogOnServer;
begin
  Result := FLogOnServer;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetLogOnServer                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetLogOnServer (const Value: TCrpeLogOnServer);
begin
  FLogOnServer.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetGraphType                                              }
{------------------------------------------------------------------------------}
function  TCrpe.GetGraphType : TCrpeGraphType;
begin
  Result := SubItem.FGraphType;
end; { GetGraphType }
{------------------------------------------------------------------------------}
{ Write Access method SetGraphType                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGraphType(const Value: TCrpeGraphType);
begin
  SubItem.FGraphType.Assign(Value);
end; { SetGraphType }

{------------------------------------------------------------------------------}
{ Access method SetGraphText                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGraphText(const Value: TCrpeGraphText);
begin
  SubItem.FGraphText.Assign(Value);
end; { SetGraphText }
{------------------------------------------------------------------------------}
{ Access method GetGraphText                                                   }
{------------------------------------------------------------------------------}
function  TCrpe.GetGraphText : TCrpeGraphText;
begin
  Result := SubItem.FGraphText;
end; { GetGraphText }

{------------------------------------------------------------------------------}
{ Access method SetGraphOptions                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGraphOptions(const Value: TCrpeGraphOptions);
begin
  SubItem.FGraphOptions.Assign(Value);
end; { SetGraphOptions }
{------------------------------------------------------------------------------}
{ Access method GetGraphOptions                                                }
{------------------------------------------------------------------------------}
function  TCrpe.GetGraphOptions : TCrpeGraphOptions;
begin
  Result := SubItem.FGraphOptions;
end; { GetGraphOptions }

{------------------------------------------------------------------------------}
{ Access method SetGraphOptionInfo                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGraphOptionInfo(const Value: TCrpeGraphOptionInfo);
begin
  SubItem.FGraphOptionInfo.Assign(Value);
end; { SetGraphOptionInfo }
{------------------------------------------------------------------------------}
{ Access method GetGraphOptionInfo                                             }
{------------------------------------------------------------------------------}
function TCrpe.GetGraphOptionInfo : TCrpeGraphOptionInfo;
begin
  Result := SubItem.FGraphOptionInfo;
end; { GetGraphOptionInfo }

{------------------------------------------------------------------------------}
{ Access method SetGraphAxis                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGraphAxis(const Value: TCrpeGraphAxis);
begin
  SubItem.FGraphAxis.Assign(Value);
end; { SetGraphAxis }
{------------------------------------------------------------------------------}
{ Access method GetGraphAxis                                                   }
{------------------------------------------------------------------------------}
function TCrpe.GetGraphAxis : TCrpeGraphAxis;
begin
  Result := SubItem.FGraphAxis;
end; { GetGraphAxis }

{------------------------------------------------------------------------------}
{ Read Access method GetGraphData                                              }
{------------------------------------------------------------------------------}
function  TCrpe.GetGraphData : TCrpeGraphData;
begin
  Result := SubItem.FGraphData;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGraphData                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetGraphData(const Value: TCrpeGraphData);
begin
  SubItem.FGraphData.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetSectionFormat                                          }
{------------------------------------------------------------------------------}
function  TCrpe.GetSectionFormat : TCrpeSectionFormat;
begin
  Result := SubItem.FSectionFormat;
end; { GetSectionFormat }
{------------------------------------------------------------------------------}
{ Write Access method SetSectionFormat                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSectionFormat(const Value: TCrpeSectionFormat);
begin
  SubItem.FSectionFormat.Assign(Value);
end; { SetSectionFormat }

{------------------------------------------------------------------------------}
{ Read Access method GetSectionFormatFormulas                                  }
{------------------------------------------------------------------------------}
function  TCrpe.GetSectionFormatFormulas : TCrpeSectionFormatFormulas;
begin
  Result := SubItem.FSectionFormatFormulas;
end; { GetSectionFormatFormulas }
{------------------------------------------------------------------------------}
{ Write Access method SetSectionFormatFormulas                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSectionFormatFormulas (const Value: TCrpeSectionFormatFormulas);
begin
  SubItem.FSectionFormatFormulas.Assign(Value);
end; { SetSectionFormatFormulas }

{------------------------------------------------------------------------------}
{ Read Access method GetAreaFormat                                             }
{------------------------------------------------------------------------------}
function TCrpe.GetAreaFormat : TCrpeAreaFormat;
begin
  Result := SubItem.FAreaFormat;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetAreaFormat                                            }
{------------------------------------------------------------------------------}
procedure TCrpe.SetAreaFormat(const Value : TCrpeAreaFormat);
begin
  SubItem.FAreaFormat.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetAreaFormatFormulas                                     }
{------------------------------------------------------------------------------}
function TCrpe.GetAreaFormatFormulas : TCrpeAreaFormatFormulas;
begin
  Result := SubItem.FAreaFormatFormulas;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetAreaFormatFormulas                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.SetAreaFormatFormulas (const Value : TCrpeAreaFormatFormulas);
begin
  SubItem.FAreaFormatFormulas.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read Access method GetSectionFont                                            }
{------------------------------------------------------------------------------}
function  TCrpe.GetSectionFont : TCrpeSectionFont;
begin
  Result := SubItem.FSectionFont;
end; { GetSectionFont }
{------------------------------------------------------------------------------}
{ Write Access method SetSectionFont                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSectionFont(const Value: TCrpeSectionFont);
begin
  SubItem.FSectionFont.Assign(Value);
end; { SetSectionFont }

{------------------------------------------------------------------------------}
{ Read Access method GetSectionHeight                                          }
{------------------------------------------------------------------------------}
function  TCrpe.GetSectionHeight : TCrpeSectionHeight;
begin
  Result := SubItem.FSectionHeight;
end; { GetSectionHeight }
{------------------------------------------------------------------------------}
{ Write Access method SetSectionHeight                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSectionHeight(const Value: TCrpeSectionHeight);
begin
  SubItem.FSectionHeight.Assign(Value);
end; { SetSectionHeight }

{------------------------------------------------------------------------------}
{ GetSectionCodes                                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetSectionCodes(var slNCodes: TStringList; var slSCodes: TStringList;
  var nSections: smallint; bArea: boolean): boolean;
const
  sCode : array[0..39] of string = ('a','b','c','d','e','f','g','h',
     'i','j', 'k','l','m','n','o','p','q','r','s','t','u','v','w',
     'x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj',
     'ak','al','am','an');
var
  nCntGF, nMaxGF   : integer;
  nIndex           : smallint;
  nCode            : smallint;
  slRH, slPH, slGH,
  slD, slGF, slPF,
  slRF             : TStringList;
  slNew            : TStringList;
  cnt1,cnt2,cnt3   : smallint;
  nSecType,
  nGroupNum,
  nSecNum          : integer;
begin
  Result := True;
  nCntGF := 0;
  nMaxGF := 0;

  {Get ReportHeader to Details}
  for nIndex := 0 to (nSections - 1) do
  begin
    SetDLLHandle;
    nCode := PEGetSectionCode(FPrintJob, nIndex);
    if nCode div 1000 < 5 then
    begin
      {We only want unique values: the Print Engine has limits and
      will repeat numbers for Subsections over 40 or Groups over 25}
      if slNCodes.IndexOf(IntToStr(nCode)) = -1 then
      begin
        {If we are checking for Areas only}
        if bArea then
        begin
          {If SectionCode has remainder less than 25, it is an AreaCode}
          if nCode mod 1000 < 25 then
            slNCodes.Add(IntToStr(nCode));
        end
        else
          slNCodes.Add(IntToStr(nCode));
      end;
    end
    else
    begin
      {Group Footer: get index number and count}
      if nCode div 1000 = 5 then
      begin
        Inc(nCntGF);
        nMaxGF := nIndex;
      end;
    end;
  end;

  {Add GroupFooter items to Section list, in reverse order}
  Dec(nCntGF);
  for nIndex := nMaxGF downto (nMaxGF - nCntGF) do
  begin
    SetDLLHandle;
    nCode := PEGetSectionCode(FPrintJob, nIndex);
    if slSCodes.IndexOf(IntToStr(nCode)) = -1 then
    begin
      {If we are checking for Areas only}
      if bArea then
      begin
        {If SectionCode has remainder less than 25, it is an AreaCode}
        if nCode mod 1000 < 25 then
          slSCodes.Add(IntToStr(nCode));
      end
      else
        slSCodes.Add(IntToStr(nCode));
    end;
  end;
  for nIndex := (slSCodes.Count - 1) downto 0 do
  begin
    slNCodes.Add(slSCodes[nIndex]);
  end;
  slSCodes.Clear;

  {Add ReportFooter/PageFooter items to Section list}
  for nIndex := 0 to (nSections - 1) do
  begin
    SetDLLHandle;
    nCode := PEGetSectionCode(FPrintJob, nIndex);
    if nCode div 1000 > 5 then
    begin
      if slNCodes.IndexOf(IntToStr(nCode)) = -1 then
      begin
        {If we are checking for Areas only}
        if bArea then
        begin
          {If SectionCode has remainder less than 25, it is an AreaCode}
          if nCode mod 1000 < 25 then
            slNCodes.Add(IntToStr(nCode));
        end
        else
          slNCodes.Add(IntToStr(nCode));
      end;
    end;
  end;

  {Copy the list}
  slSCodes.AddStrings(slNCodes);

  {Change Section Codes: 3000, to strings: GH1a}
  {Create temporary Stringlists}
  slRH := TStringList.Create;
  slPH := TStringList.Create;
  slGH := TStringList.Create;
  slD  := TStringList.Create;
  slGF := TStringList.Create;
  slPF := TStringList.Create;
  slRF := TStringList.Create;
  slNew := TStringList.Create;

  {Go through Section codes and sort}
  for cnt1 := 0 to (slSCodes.Count - 1) do
  begin
    nSecNum := StrToInt(slSCodes[cnt1]);
    {Get Section Type}
    nSecType := PE_SECTION_TYPE(nSecNum);
    case nSecType of
      1: slRH.Add(slSCodes[cnt1]); {RH}
      2: slPH.Add(slSCodes[cnt1]); {PH}
      3: slGH.Add(slSCodes[cnt1]); {GH}
      4: slD.Add(slSCodes[cnt1]);  {D}
      5: slGF.Add(slSCodes[cnt1]); {GF}
      7: slPF.Add(slSCodes[cnt1]); {PF}
      8: slRF.Add(slSCodes[cnt1]); {RF}
    end;
  end;

  {Report Header}
  for cnt1 := 0 to (slRH.Count - 1) do
  begin
    {Get Section Code number}
    nSecNum := StrToInt(slRH[cnt1]);
    {Get SubSection number}
    nSecNum := PE_SECTION_N(nSecNum);
    {Convert to string format}
    if slRH.Count = 1 then
      slNew.Add('RH')
    else
      slNew.Add('RH' + sCode[nSecNum]);
  end;

  {Page Header}
  for cnt1 := 0 to (slPH.Count - 1) do
  begin
    {Get Section Code number}
    nSecNum := StrToInt(slPH[cnt1]);
    {Get SubSection number}
    nSecNum := PE_SECTION_N(nSecNum);
    {Convert to string format}
    if slPH.Count = 1 then
      slNew.Add('PH')
    else
      slNew.Add('PH' + sCode[nSecNum]);
  end;

  {Group Header}
  cnt1 := 0;  {Loops through all items}
  {cnt2}      {Inner loop: loops through individual Groups}
  cnt3 := 0;  {counts subSection numbers}
  while cnt1 < slGH.Count do
  begin
    nGroupNum := PE_GROUP_N(StrToInt(slGH[cnt1]));
    cnt2 := nGroupNum;
    while cnt2 = nGroupNum do
    begin
      {Convert Section Code to number}
      nSecNum := StrToInt(slGH[cnt1]);
      {Get Group Number}
      nGroupNum := PE_GROUP_N(nSecNum);
      {Get SubSection number}
      nSecNum := PE_SECTION_N(nSecNum);
      {Convert to string format: GH1a}
      case cnt3 of
        0: slNew.Add('GH' + IntToStr(nGroupNum + 1));
        1: begin
             slNew[slNew.Count - 1] := slNew[slNew.Count - 1] + 'a';
             slNew.Add('GH' + IntToStr(nGroupNum + 1) + sCode[nSecNum]);
           end;
        else slNew.Add('GH' + IntToStr(nGroupNum + 1) + sCode[nSecNum]);
      end;
      Inc(cnt1);
      Inc(cnt3);
      if cnt1 < slGH.Count then
        nGroupNum := PE_GROUP_N(StrToInt(slGH[cnt1]))
      else
        Break;
    end;
    cnt3 := 0;
  end;

  {Details}
  for cnt1 := 0 to (slD.Count - 1) do
  begin
    {Get Section Code number}
    nSecNum := StrToInt(slD[cnt1]);
    {Get SubSection number}
    nSecNum := PE_SECTION_N(nSecNum);
    {Convert to string format}
    if slD.Count = 1 then
      slNew.Add('D')
    else
      slNew.Add('D' + sCode[nSecNum]);
  end;

  {Group Footer}
  cnt1 := 0;  {Loops through all items}
  {cnt2}      {Inner loop: loops through individual Groups}
  cnt3 := 0;  {counts subSection numbers}
  while cnt1 < slGF.Count do
  begin
    nGroupNum := PE_GROUP_N(StrToInt(slGF[cnt1]));
    cnt2 := nGroupNum;
    {Loop for the Group number}
    while cnt2 = nGroupNum do
    begin
      {Convert Section Code to number}
      nSecNum := StrToInt(slGF[cnt1]);
      {Get Group Number}
      nGroupNum := PE_GROUP_N(nSecNum);
      {Get SubSection number}
      nSecNum := PE_SECTION_N(nSecNum);
      {Convert to string format: GF1a}
      case cnt3 of
        0: slNew.Add('GF' + IntToStr(nGroupNum + 1));
        1: begin
             slNew[slNew.Count - 1] := slNew[slNew.Count - 1] + 'a';
             slNew.Add('GF' + IntToStr(nGroupNum + 1) + sCode[nSecNum]);
           end;
        else slNew.Add('GF' + IntToStr(nGroupNum + 1) + sCode[nSecNum]);
      end;
      Inc(cnt1);
      Inc(cnt3);
      if cnt1 < slGF.Count then
        nGroupNum := PE_GROUP_N(StrToInt(slGF[cnt1]))
      else
        Break;
    end;
    cnt3 := 0;
  end;

  {Page Footer}
  for cnt1 := 0 to (slPF.Count - 1) do
  begin
    if cnt1 > 39 then
      slPF.Delete(cnt1)
    else
    begin
      {Get Section Code number}
      nSecNum := StrToInt(slPF[cnt1]);
      {Get SubSection number}
      nSecNum := PE_SECTION_N(nSecNum);
      {Convert to string format}
      if slPF.Count = 1 then
        slNew.Add('PF')
      else
        slNew.Add('PF' + sCode[nSecNum]);
    end;
  end;

  {Report Footer}
  for cnt1 := 0 to (slRF.Count - 1) do
  begin
    if cnt1 > 39 then
      slRF.Delete(cnt1)
    else
    begin
      {Get Section Code number}
      nSecNum := StrToInt(slRF[cnt1]);
      {Get SubSection number}
      nSecNum := PE_SECTION_N(nSecNum);
      {Convert to string format}
      if slRF.Count = 1 then
        slNew.Add('RF')
      else
        slNew.Add('RF' + sCode[nSecNum]);
    end;
  end;

  {Add Valid sections to Sections list}
  slSCodes.Clear;
  slNCodes.Clear;
  slSCodes.AddStrings(slNew);
  slNCodes.AddStrings(slRH);
  slNCodes.AddStrings(slPH);
  slNCodes.AddStrings(slGH);
  slNCodes.AddStrings(slD);
  slNCodes.AddStrings(slGF);
  slNCodes.AddStrings(slPF);
  slNCodes.AddStrings(slRF);

  {Adjust number of sections in case it has changed}
  nSections := slSCodes.Count;

  {Free temporary stringlists}
  slRH.Free;
  slPH.Free;
  slGH.Free;
  slD.Free;
  slGF.Free;
  slRF.Free;
  slPF.Free;
  slNew.Free;
end;

{------------------------------------------------------------------------------}
{ Read member function GetWindowZoom                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowZoom : TCrpeWindowZoom;
begin
  Result := FWindowZoom;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindowZoom                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowZoom(const Value: TCrpeWindowZoom);
begin
  FWindowZoom.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read member function GetWindowStyle                                          }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowStyle : TCrpeWindowStyle;
begin
  Result := FWindowStyle;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindowStyle                                        }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowStyle(const Value: TCrpeWindowStyle);
begin
  FWindowStyle.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read member function GetWindowSize                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowSize : TCrpeWindowSize;
begin
  Result := FWindowSize;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindowSize                                         }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowSize(const Value: TCrpeWindowSize);
begin
  FWindowSize.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read member function GetWindowButtonBar                                      }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowButtonBar : TCrpeWindowButtonBar;
begin
  Result := FWindowButtonBar;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindowButtonBar                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowButtonBar(const Value: TCrpeWindowButtonBar);
begin
  FWindowButtonBar.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Read member function GetWindowCursor                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowCursor : TCrpeWindowCursor;
begin
  Result := FWindowCursor;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindowCursor                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowCursor (const Value: TCrpeWindowCursor);
begin
  FWindowCursor.Assign(Value);
end;

{------------------------------------------------------------------------------}
{ Member function GetLastErrorNumber                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetLastErrorNumber : integer;
begin
  Result := FLastErrorNumber;
end;
{------------------------------------------------------------------------------}
{ Member procedure SetLastErrorNumber                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetLastErrorNumber(const Value: integer);
begin
  FLastErrorNumber := Value;
end;

{------------------------------------------------------------------------------}
{ Member function GetLastErrorString                                           }
{------------------------------------------------------------------------------}
function TCrpe.GetLastErrorString : string;
begin
  Result := FLastErrorString;
end;
{------------------------------------------------------------------------------}
{ Member procedure SetLastErrorString                                          }
{------------------------------------------------------------------------------}
procedure TCrpe.SetLastErrorString(const Value: string);
begin
  FLastErrorString := Value;
end;

{------------------------------------------------------------------------------}
{ Read Access method GetSessionInfo                                            }
{------------------------------------------------------------------------------}
function TCrpe.GetSessionInfo : TCrpeSessionInfo;
begin
  Result := SubItem.FSessionInfo;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSessionInfo                                           }
{------------------------------------------------------------------------------}
procedure TCrpe.SetSessionInfo(const Value : TCrpeSessionInfo);
begin
  SubItem.FSessionInfo.Assign(Value);
end;

{******************************************************************************}
{ Utility Functions                                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ StrToTCrBoolean                                                              }
{------------------------------------------------------------------------------}
function StrToTCrBoolean (const sValue: string): TCrBoolean;
var
  sTmp : string;
begin
  sTmp := UpperCase(Trim(sValue));
  if Length(sTmp) > 0 then
    sTmp := sTmp[1]
  else
    sTmp := '2';
  if (sTmp = '0') or (sTmp = 'F') or (sTmp = 'N') then
    Result := cFalse
  else if (sTmp = '1') or (sTmp = 'T') or (sTmp = 'Y') then
    Result := cTrue
  else
    Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ TCrBooleanToStr                                                              }
{------------------------------------------------------------------------------}
function TCrBooleanToStr (const crbValue: TCrBoolean): string;
begin
  case crbValue of
    cFalse   : Result := '0';
    cTrue    : Result := '1';
    cDefault : Result := '-1';
  end; { case }
end;


{**** Beginning of SubClass Definitions ****}
{******************************************************************************}
{ TCrpeVersion Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeVersion.Create;
begin
  inherited Create;
  {Set Defaults}
  FDLL := '';
  FEngine := '';
  FFileVersion := '';
  FWindows := '';
  FMajor := 0;
  FMinor := 0;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.Clear;
begin
  FDLL := '';
  FEngine := '';
  FFileVersion := '';
  FWindows := '';
  FMajor := 0;
  FMinor := 0;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.CopyFrom (Source: TCrpeVersion);
begin
  Clear;
  FDLL := Source.FDLL;
  FEngine := Source.FEngine;
  FFileVersion := Source.FFileVersion;
  FWindows := Source.FWindows;
  FMajor := Source.FMajor;
  FMinor := Source.FMinor;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeVersion.Retrieve: boolean;
var
  pBuf       : TOSVersionInfo;
  iDLL, iEng : smallint;
  sTmp       : string;
begin
  Result := False;
  if not Cr.OpenPrintEngine then
    Exit;
  {Get CRPE version}
  Cr.SetDLLHandle;
  iDLL := PEGetVersion(PE_GV_DLL);
  iEng := PEGetVersion(PE_GV_ENGINE);
  FDLL := IntToStr(Hi(iDLL)) + '.' + IntToStr(Lo(iDLL));
  FEngine := IntToStr(Hi(iEng)) + '.' + IntToStr(Lo(iEng));
  Result := True;
  {Get Windows version}
  pBuf.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);
  if GetVersionEx(pBuf) then
  begin
     case pBuf.dwPlatformId of
       0: sTmp := '32s';
       1: sTmp := '95';
       2: sTmp := 'NT';
     end;
     sTmp := sTmp + '/' + IntToStr(pBuf.dwMajorVersion);
     FWindows := sTmp + '.' + IntToStr(pBuf.dwMinorVersion);
  end;
end;
{------------------------------------------------------------------------------}
{ Read member function GetDLL                                                  }
{------------------------------------------------------------------------------}
function TCrpeVersion.GetDLL : string;
begin
  Result := FDLL;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetDLL                                                }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.SetDLL(const Value : string);
begin
  {nothing: it is actually read-only}
end;
{------------------------------------------------------------------------------}
{ Read member function GetEngine                                               }
{------------------------------------------------------------------------------}
function TCrpeVersion.GetEngine : string;
begin
  Result := FEngine;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetEngine                                             }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.SetEngine(const Value : string);
begin
  {nothing: it is actually read-only}
end;
{------------------------------------------------------------------------------}
{ Read member function GetWindows                                              }
{------------------------------------------------------------------------------}
function TCrpeVersion.GetWindows : string;
begin
  Result := FWindows;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetWindows                                            }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.SetWindows(const Value : string);
begin
  {nothing: it is actually read-only}
end;
{------------------------------------------------------------------------------}
{ Read member function GetFileVersion                                          }
{------------------------------------------------------------------------------}
function TCrpeVersion.GetFileVersion : string;
begin
  Result := FFileVersion;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetFileVersion                                        }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.SetFileVersion(const Value : string);
begin
  {nothing: it is actually read-only}
end;
{------------------------------------------------------------------------------}
{ Read member function GetMajor                                                }
{------------------------------------------------------------------------------}
function TCrpeVersion.GetMajor : integer;
begin
  Result := FMajor;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetMajor                                              }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.SetMajor(const Value : integer);
begin
  {nothing: it is actually read-only}
end;
{------------------------------------------------------------------------------}
{ Read member function GetMinor                                                }
{------------------------------------------------------------------------------}
function TCrpeVersion.GetMinor : integer;
begin
  Result := FMinor;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetMinor                                              }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.SetMinor(const Value : integer);
begin
  {nothing: it is actually read-only}
end;


{******************************************************************************}
{ TCrpeWindowSize Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowSize.Create;
begin
  inherited Create;
  {Set Defaults}
  FTop    := -1;
  FLeft   := -1;
  FWidth  := -1;
  FHeight := -1;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.Clear;
begin
  FTop    := -1;
  FLeft   := -1;
  FWidth  := -1;
  FHeight := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.CopyFrom (Source: TCrpeWindowSize);
begin
  Clear;
  FTop    := Source.FTop;
  FLeft   := Source.FLeft;
  FWidth  := Source.FWidth;
  FHeight := Source.FHeight;
end;
{------------------------------------------------------------------------------}
{ Member function Retrieve                                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.Retrieve : boolean;
var
  rSize   : TRect;
  wHandle : hWnd;
begin
  Result := False;
  if (Cr.FPrintJob = 0) then
    Exit;
  wHandle := Cr.ReportWindowHandle;
  if (wHandle > 0) then
  begin
    if GetWindowRect(wHandle, rSize) then
    begin
      FTop := rSize.Top;
      FHeight := rSize.Bottom - rSize.Top;
      FLeft := rSize.Left;
      FWidth := rSize.Right - rSize.Left;
      Result := True;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function Send                                                         }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.Send : boolean;
var
  curLeft, curTop,
  curHeight, curWidth : Integer;
  newLeft, newTop,
  newHeight, newWidth : Integer;
  Changed             : boolean;
begin
  Result := False;
  Changed := False;
  if Cr.ReportWindowHandle > 0 then
  begin
    {Store the new settings}
    newTop := FTop;
    newLeft := FLeft;
    newWidth := FWidth;
    newHeight := FHeight;
    {Retrieve the current size}
    Retrieve;
    {Store current size}
    curTop := FTop;
    curLeft := FLeft;
    curWidth := FWidth;
    curHeight := FHeight;
    {Reset the Properties}
    FTop := newTop;
    FLeft := newLeft;
    FWidth := newWidth;
    FHeight := newHeight;
    {Compare for changes}
    if newTop <> curTop then
      Changed := True;
    if newLeft <> curLeft then
      Changed := True;
    if newWidth <> curWidth then
      Changed := True;
    if newHeight <> curHeight then
      Changed := True;
    {Set Window size and position}
    if Changed then
    begin
      if newTop > -1 then curTop := newTop;
      if newLeft > -1 then curLeft := newLeft;
      if newWidth > -1 then curWidth := newWidth;
      if newHeight > -1 then curHeight := newHeight;
      SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, curLeft, curTop,
        curWidth, curHeight, SWP_NOZORDER);
      Result := True;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTop                                                    }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetTop : smallint;
begin
  Result := FTop;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetTop                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetTop(const Value: smallint);
begin
  if Value > -2 then
    FTop := Value;
end; { SetTop }
{------------------------------------------------------------------------------}
{ Read Access method GetLeft                                                   }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetLeft : smallint;
begin
  Result := FLeft;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetLeft                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetLeft(const Value : smallint);
begin
  if Value > -2 then
    FLeft := Value;
end; { SetLeft }
{------------------------------------------------------------------------------}
{ Read Access method GetWidth                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetWidth : smallint;
begin
  Result := FWidth;
end;
{------------------------------------------------------------------------------}
{ Write ccess method SetWidth                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetWidth(const Value: smallint);
begin
  if Value > -2 then
    FWidth := Value;
end; { SetWidth }
{------------------------------------------------------------------------------}
{ Read Access method GetHeight                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetHeight : smallint;
begin
  Result := FHeight;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetHeight                                                }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetHeight(const Value : smallint);
begin
  if Value > -2 then
    FHeight := Value;
end; { SetHeight }


{******************************************************************************}
{ TCrpeWindowZoom Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowZoom.Create;
begin
  inherited Create;
  {Set Defaults}
  FPreview := pwDefault;
  FMagnification := -1;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.Clear;
begin
  FPreview := pwDefault;
  FMagnification := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.CopyFrom (Source: TCrpeWindowZoom);
begin
  Clear;
  FPreview := Source.FPreview;
  FMagnification := Source.FMagnification;
end;
{------------------------------------------------------------------------------}
{ NextLevel method                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.NextLevel;
begin
  if Cr.ReportWindowHandle > 0 then
  begin
    Cr.SetDLLHandle;
    if not PENextPrintWindowMagnification(Cr.FPrintJob) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowZoom.NextLevel <PENextPrintWindowMagnification>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end
  else
  begin
    case FPreview of
      pwDefault   : FPreview := pwNormal;
      pwNormal    : FPreview := pwPageWidth;
      pwPageWidth : FPreview := pwWholePage;
      pwWholePage : FPreview := pwNormal;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowZoom.Send : boolean;
var
  Value : integer;
begin
  Result := False;

  {If Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    if FPreview <> pwDefault then
       Value := Ord(FPreview)
    else
       Value := FMagnification;

    case Value of
      0..2,
      25..400:
        begin
          Cr.SetDLLHandle;
          if not PEZoomPreviewWindow(Cr.FPrintJob, Value) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'WindowZoom.Send <PEZoomPreviewWindow>') of
              cFalse   : Exit;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end;
          Result := True;
        end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read member procedure GetPreview                                             }
{------------------------------------------------------------------------------}
function TCrpeWindowZoom.GetPreview : TCrZoomPreview;
begin
  Result := FPreview;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetPreview                                            }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.SetPreview(const Value: TCrZoomPreview);
begin
  FPreview := Value;
  FMagnification := -1;
  Send;
end;
{------------------------------------------------------------------------------}
{ Read member procedure GetMagnification                                       }
{------------------------------------------------------------------------------}
function TCrpeWindowZoom.GetMagnification : TCrZoomMagnification;
begin
  Result := FMagnification;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetMagnification                                      }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.SetMagnification(const Value: TCrZoomMagnification);
begin
  case Value of
    0..2,
    25..400:
      begin
        FMagnification := Value;
        FPreview := pwDefault;
        Send;
      end;
    -1: FMagnification := Value;
    else
      begin
        FMagnification := -1;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_INVALID_MAGNIFICATION,
          'WindowZoom.SetMagnification') of
          cFalse   : Exit;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
  end;
end;


{******************************************************************************}
{ TCrpeWindowStyle Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowStyle.Create;
begin
  inherited Create;
  {Set Defaults}
  FTitle       := '';
  FSystemMenu  := True;
  FMaxButton   := True;
  FMinButton   := True;
  FBorderStyle := bsSizeable;
  FMDIForm     := nil;
  FDisabled    := False;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.Clear;
begin
  FTitle       := '';
  FSystemMenu  := True;
  FMaxButton   := True;
  FMinButton   := True;
  FBorderStyle := bsSizeable;
  FDisabled    := False;
  if FMDIForm <> nil then
  begin
    FMDIForm.Free;
    FMDIForm := nil;
  end;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.CopyFrom (Source: TCrpeWindowStyle);
begin
  Clear;
  FTitle       := Source.FTitle;
  FSystemMenu  := Source.FSystemMenu;
  FMaxButton   := Source.FMaxButton;
  FMinButton   := Source.FMinButton;
  FBorderStyle := Source.FBorderStyle;
  FDisabled    := Source.FDisabled;
end;
{------------------------------------------------------------------------------}
{ Read member function GetTitle                                                }
{------------------------------------------------------------------------------}
function TCrpeWindowStyle.GetTitle : string;
begin
  Result := FTitle;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetTitle                                              }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetTitle(const Value: string);
begin
  FTitle := Value;
  if Cr.ReportWindowHandle > 0 then
  begin
    if (FMDIForm <> nil) and (FMDIForm is TForm) then
      FMDIForm.Caption := FTitle
    else
      SetWindowText(Cr.ReportWindowHandle, PChar(FTitle));
  end;
end;
{------------------------------------------------------------------------------}
{ Read member function GetSystemMenu                                           }
{------------------------------------------------------------------------------}
function TCrpeWindowStyle.GetSystemMenu : boolean;
begin
  Result := FSystemMenu;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetSystemMenu                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetSystemMenu(const Value: boolean);
begin
  FSystemMenu := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetMaxButton                                            }
{------------------------------------------------------------------------------}
function TCrpeWindowStyle.GetMaxButton : boolean;
begin
  Result := FMaxButton;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetMaxButton                                          }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetMaxButton(const Value: boolean);
begin
  FMaxButton := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetMinButton                                            }
{------------------------------------------------------------------------------}
function TCrpeWindowStyle.GetMinButton : boolean;
begin
  Result := FMinButton;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetMinButton                                          }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetMinButton(const Value: boolean);
begin
  FMinButton := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetBorderStyle                                         }
{------------------------------------------------------------------------------}
function TCrpeWindowStyle.GetBorderStyle : TCrFormBorderStyle;
begin
  Result := FBorderStyle;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetBorderStyle                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetBorderStyle(const Value: TCrFormBorderStyle);
begin
  FBorderStyle := Value;
end;
{------------------------------------------------------------------------------}
{ Read member function GetDisabled                                             }
{------------------------------------------------------------------------------}
function TCrpeWindowStyle.GetDisabled : boolean;
begin
  Result := FDisabled;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetDisabled                                           }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetDisabled(const Value: boolean);
var
  bTmp: Bool;
begin
  FDisabled := Value;
  bTmp := not FDisabled;
  if Cr.ReportWindowHandle > 0 then
    EnableWindow(Cr.ReportWindowHandle, bTmp);
end;
{------------------------------------------------------------------------------}
{ Procedure OnMDIResize                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.OnMDIResize(Sender: TObject);
begin
  if Cr.ReportWindowHandle > 0 then
  begin
    SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, 0, 0,
      FMDIForm.ClientWidth, FMDIForm.ClientHeight, SWP_NOZORDER);
  end;
end;
{------------------------------------------------------------------------------}
{ Procedure OnMDIClose                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.OnMDIClose(Sender: TObject; var Action: TCloseAction);
begin
  if (FMDIForm <> nil) and (FMDIForm is TForm) then
  begin
    Cr.CloseWindow;
    FMDIForm.Release;
    FMDIForm := nil;
  end;
end;


{******************************************************************************}
{ TCrpeWindowButtonBar Class Definition                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowButtonBar.Create;
begin
  inherited Create;
  {Set Defaults}
  FVisible := True;
  FAllowDrillDown := False;
  FCancelBtn := False;
  FCloseBtn := False;
  FExportBtn := True;
  FGroupTree := False;
  FNavigationCtls := True;
  FPrintBtn := True;
  FPrintSetupBtn := False;
  FProgressCtls := True;
  FRefreshBtn := False;
  FSearchBtn := False;
  FZoomCtl := True;
  FToolbarTips := True;
  FDocumentTips := false;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.Clear;
begin
  FVisible := True;
  FAllowDrillDown := False;
  FCancelBtn := False;
  FCloseBtn := False;
  FExportBtn := True;
  FGroupTree := False;
  FNavigationCtls := True;
  FPrintBtn := True;
  FPrintSetupBtn := False;
  FProgressCtls := True;
  FRefreshBtn := False;
  FSearchBtn := False;
  FZoomCtl := True;
  FToolbarTips := True;
  FDocumentTips := false;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.CopyFrom (Source: TCrpeWindowButtonBar);
begin
  Clear;
  FVisible := Source.FVisible;
  FAllowDrillDown := Source.FAllowDrillDown;
  FCancelBtn := Source.FCancelBtn;
  FCloseBtn := Source.FCloseBtn;
  FExportBtn := Source.FExportBtn;
  FGroupTree := Source.FGroupTree;
  FNavigationCtls := Source.FNavigationCtls;
  FPrintBtn := Source.FPrintBtn;
  FPrintSetupBtn := Source.FPrintSetupBtn;
  FProgressCtls := Source.FProgressCtls;
  FRefreshBtn := Source.FRefreshBtn;
  FSearchBtn := Source.FSearchBtn;
  FZoomCtl := Source.FZoomCtl;
  FToolbarTips := Source.FToolbarTips;
  FDocumentTips := Source.FDocumentTips;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.Retrieve : boolean;
var
  WindowOptions : PEWindowOptions;
  bShow         : LongBool;  //WinAPI: BOOL
begin
  Result := False;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Cr.SetDLLHandle;
    {Check if ButtonBar is Visible}
    if not PEPrintControlsShowing(Cr.FPrintJob, bShow) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.Retrieve <PEPrintControlsShowing>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FVisible := Boolean(bShow);
    Result := True;

    {Window ButtonBar control requires SCR 6+}
    if Cr.FVersion.FMajor < 6 then
      Exit;

    {Check which Buttons are showing}
    Cr.SetDLLHandle;
    if not PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'WindowButtonBar.Retrieve <PEGetWindowOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FGroupTree := boolean(WindowOptions.hasGroupTree);
    FAllowDrillDown := boolean(WindowOptions.CanDrillDown);
    FNavigationCtls := boolean(WindowOptions.hasNavigationControls);
    FCancelBtn := boolean(WindowOptions.hasCancelButton);
    FPrintBtn := boolean(WindowOptions.hasPrintButton);
    FExportBtn := boolean(WindowOptions.hasExportButton);
    FZoomCtl := boolean(WindowOptions.hasZoomControl);
    FCloseBtn := boolean(WindowOptions.hasCloseButton);
    FProgressCtls := boolean(WindowOptions.hasProgressControls);
    FSearchBtn := boolean(WindowOptions.hasSearchButton);
    FPrintSetupBtn := boolean(WindowOptions.hasPrintSetupButton);
    FRefreshBtn := boolean(WindowOptions.hasRefreshButton);
    {SCR 7 adds two new properties}
    if Cr.FVersion.FMajor > 6 then
    begin
      FToolbarTips  := boolean(WindowOptions.showToolbarTips);
      FDocumentTips := boolean(WindowOptions.showDocumentTips);
    end;
  end;
end; { Retrieve }
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.Send : boolean;
var
  WindowOptions   : PEWindowOptions;
  bGroupTree      : boolean;
  bAllowDrillDown : boolean;
  bNavigationCtls : boolean;
  bCancelBtn      : boolean;
  bPrintBtn       : boolean;
  bExportBtn      : boolean;
  bZoomCtl        : boolean;
  bCloseBtn       : boolean;
  bProgressCtls   : boolean;
  bSearchBtn      : boolean;
  bPrintSetupBtn  : boolean;
  bRefreshBtn     : boolean;
  bToolbarTips    : boolean;
  bDocumentTips   : boolean;
  Changed         : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  Changed := True;

  Cr.SetDLLHandle;
  {ButtonBar Visible}
  if not PEShowPrintControls(Cr.FPrintJob, BOOL(FVisible)) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowButtonBar.Send <PEShowPrintControls>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;

  {ButtonBar Options on available with 6.0+}
  if Cr.FVersion.FMajor < 6 then
    Exit;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    Cr.SetDLLHandle;
    {Check which Buttons are showing}
    if not PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.Send <PEGetWindowOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bGroupTree := boolean(WindowOptions.hasGroupTree);
    bAllowDrillDown := boolean(WindowOptions.CanDrillDown);
    bNavigationCtls := boolean(WindowOptions.hasNavigationControls);
    bCancelBtn := boolean(WindowOptions.hasCancelButton);
    bPrintBtn := boolean(WindowOptions.hasPrintButton);
    bExportBtn := boolean(WindowOptions.hasExportButton);
    bZoomCtl := boolean(WindowOptions.hasZoomControl);
    bCloseBtn := boolean(WindowOptions.hasCloseButton);
    bProgressCtls := boolean(WindowOptions.hasProgressControls);
    bSearchBtn := boolean(WindowOptions.hasSearchButton);
    bPrintSetupBtn := boolean(WindowOptions.hasPrintSetupButton);
    bRefreshBtn := boolean(WindowOptions.hasRefreshButton);
    bToolbarTips := boolean(WindowOptions.showToolbarTips);
    bDocumentTips := boolean(WindowOptions.showDocumentTips);

    {GroupTree}
    if FGroupTree <> bGroupTree then
    begin
      WindowOptions.hasGroupTree := SmallInt(FGroupTree);
      Changed := True;
    end;
    {AllowDrillDown}
    if FAllowDrillDown <> bAllowDrillDown then
    begin
      WindowOptions.CanDrillDown := SmallInt(FAllowDrillDown);
      Changed := True;
    end;
    {NavigationCtls}
    if FNavigationCtls <> bNavigationCtls then
    begin
      WindowOptions.hasNavigationControls := SmallInt(FNavigationCtls);
      Changed := True;
    end;
    {CancelBtn}
    if FCancelBtn <> bCancelBtn then
    begin
      WindowOptions.hasCancelButton := SmallInt(FCancelBtn);
      Changed := True;
    end;
    {PrintBtn}
    if FPrintBtn <> bPrintBtn then
    begin
      WindowOptions.hasPrintButton := SmallInt(FPrintBtn);
      Changed := True;
    end;
    {ExportBtn}
    if FExportBtn <> bExportBtn then
    begin
      WindowOptions.hasExportButton := SmallInt(FExportBtn);
      Changed := True;
    end;
    {ZoomCtl}
    if FZoomCtl <> bZoomCtl then
    begin
      WindowOptions.hasZoomControl := SmallInt(FZoomCtl);
      Changed := True;
    end;
    {CloseBtn}
    if FCloseBtn <> bCloseBtn then
    begin
      WindowOptions.hasCloseButton := SmallInt(FCloseBtn);
      Changed := True;
    end;
    {ProgressCtls}
    if FProgressCtls <> bProgressCtls then
    begin
      WindowOptions.hasProgressControls := SmallInt(FProgressCtls);
      Changed := True;
    end;
    {SearchBtn}
    if FSearchBtn <> bSearchBtn then
    begin
      WindowOptions.hasSearchButton := SmallInt(FSearchBtn);
      Changed := True;
    end;
    {PrintSetupBtn}
    if FPrintSetupBtn <> bPrintSetupBtn then
    begin
      WindowOptions.hasPrintSetupButton := SmallInt(FPrintSetupBtn);
      Changed := True;
    end;
    {RefreshBtn}
    if FRefreshBtn <> bRefreshBtn then
    begin
      WindowOptions.hasRefreshButton := SmallInt(FRefreshBtn);
      Changed := True;
    end;
    {ToolbarTips}
    if FToolbarTips <> bToolbarTips then
    begin
      WindowOptions.showToolbarTips := SmallInt(FToolbarTips);
      Changed := True;
    end;
    {DocumentTips}
    if FDocumentTips <> bDocumentTips then
    begin
      WindowOptions.showDocumentTips := SmallInt(FDocumentTips);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := SmallInt(FGroupTree);
    WindowOptions.CanDrillDown := SmallInt(FAllowDrillDown);
    WindowOptions.hasNavigationControls := SmallInt(FNavigationCtls);
    WindowOptions.hasCancelButton := SmallInt(FCancelBtn);
    WindowOptions.hasPrintButton := SmallInt(FPrintBtn);
    WindowOptions.hasExportButton := SmallInt(FExportBtn);
    WindowOptions.hasZoomControl := SmallInt(FZoomCtl);
    WindowOptions.hasCloseButton := SmallInt(FCloseBtn);
    WindowOptions.hasProgressControls := SmallInt(FProgressCtls);
    WindowOptions.hasSearchButton := SmallInt(FSearchBtn);
    WindowOptions.hasPrintSetupButton := SmallInt(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := SmallInt(FRefreshBtn);
    WindowOptions.showToolbarTips := SmallInt(FToolbarTips);
    WindowOptions.showDocumentTips := SmallInt(FDocumentTips);
  end;

  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.Send <PESetWindowOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write member procedure SetVisible                                            }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetVisible(const Value: boolean);
begin
  FVisible := Value;
  if Cr.ReportWindowHandle > 0 then
    Send;
end;


{******************************************************************************}
{ TCrpeWindowCursor Class Definition                                           }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowCursor.Create;
begin
  inherited Create;
  {Set Defaults}
  FGroupArea       := wcDefault;
  FGroupAreaField  := wcDefault;
  FDetailArea      := wcDefault;
  FDetailAreaField := wcDefault;
  FGraph           := wcDefault;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.Clear;
begin
  FGroupArea       := wcDefault;
  FGroupAreaField  := wcDefault;
  FDetailArea      := wcDefault;
  FDetailAreaField := wcDefault;
  FGraph           := wcDefault;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.CopyFrom (Source: TCrpeWindowCursor);
begin
  Clear;
  FGroupArea       := Source.FGroupArea;
  FGroupAreaField  := Source.FGroupAreaField;
  FDetailArea      := Source.FDetailArea;
  FDetailAreaField := Source.FDetailAreaField;
  FGraph           := Source.FGraph;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.Retrieve : boolean;
var
  CursorInfo : PETrackCursorInfo;

  {Local function to convert Cursor Type}
  function ConvertCursorType(rptCursor: smallint): TCrWindowCursor;
  const
    PECursorTypes : array[0..14] of Smallint =
     (PE_TC_DEFAULT_CURSOR, PE_TC_ARROW_CURSOR, PE_TC_CROSS_CURSOR,
      PE_TC_IBEAM_CURSOR, PE_TC_UPARROW_CURSOR, PE_TC_SIZEALL_CURSOR,
      PE_TC_SIZENWSE_CURSOR, PE_TC_SIZENESW_CURSOR, PE_TC_SIZEWE_CURSOR,
      PE_TC_SIZENS_CURSOR, PE_TC_NO_CURSOR, PE_TC_WAIT_CURSOR,
      PE_TC_APPSTARTING_CURSOR, PE_TC_HELP_CURSOR, PE_TC_MAGNIFY_CURSOR);
  var
    cnt : integer;
  begin
    Result := wcDefault;
    for cnt := Ord(Low(PECursorTypes)) to Ord(High(PECursorTypes)) do
    begin
      if rptCursor = PECursorTypes[cnt] then
      begin
        Result := TCrWindowCursor(cnt);
        Exit;
      end;
    end;
  end;

{Main function}
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {WindowCursor only available with 6.0+}
  if Cr.FVersion.FMajor < 6 then
    Exit;

  Cr.SetDLLHandle;
  {Retrieve the Cursor info}
  if not PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.Retrieve <PEGetTrackCursorInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store Track Cursor values}
  FGroupArea := ConvertCursorType(CursorInfo.groupAreaCursor);
  FGroupAreaField := ConvertCursorType(CursorInfo.groupAreaFieldCursor);
  FDetailArea := ConvertCursorType(CursorInfo.detailAreaCursor);
  FDetailAreaField := ConvertCursorType(CursorInfo.detailAreaFieldCursor);
  FGraph := ConvertCursorType(CursorInfo.graphCursor);
  Result := True;
end; { Retrieve }
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.Send : boolean;
const
  PECursorTypes : array[0..14] of Smallint =
   (PE_TC_DEFAULT_CURSOR, PE_TC_ARROW_CURSOR, PE_TC_CROSS_CURSOR,
    PE_TC_IBEAM_CURSOR, PE_TC_UPARROW_CURSOR, PE_TC_SIZEALL_CURSOR,
    PE_TC_SIZENWSE_CURSOR, PE_TC_SIZENESW_CURSOR, PE_TC_SIZEWE_CURSOR,
    PE_TC_SIZENS_CURSOR, PE_TC_NO_CURSOR, PE_TC_WAIT_CURSOR,
    PE_TC_APPSTARTING_CURSOR, PE_TC_HELP_CURSOR, PE_TC_MAGNIFY_CURSOR);
var
  CursorInfo       : PETrackCursorInfo;
  Changed          : boolean;
  rGroupArea,
  rGroupAreaField,
  rDetailArea,
  rDetailAreaField,
  rGraph           : TCrWindowCursor;

  {Local function to convert Cursor Type}
  function ConvertCursorType(rptCursor: smallint): TCrWindowCursor;
  var
    cnt : integer;
  begin
    Result := wcDefault;
    for cnt := Ord(Low(PECursorTypes)) to Ord(High(PECursorTypes)) do
    begin
      if rptCursor = PECursorTypes[cnt] then
      begin
        Result := TCrWindowCursor(cnt);
        Exit;
      end;
    end;
  end;

begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {WindowCursor only available with 6.0+}
  if Cr.FVersion.FMajor < 6 then
    Exit;
  Changed := False;

  Cr.SetDLLHandle;
  {Retrieve the Cursor info}
  if not PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.Send <PEGetTrackCursorInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store Track Cursor values}
  rGroupArea := ConvertCursorType(CursorInfo.groupAreaCursor);
  rGroupAreaField := ConvertCursorType(CursorInfo.groupAreaFieldCursor);
  rDetailArea := ConvertCursorType(CursorInfo.detailAreaCursor);
  rDetailAreaField := ConvertCursorType(CursorInfo.detailAreaFieldCursor);
  rGraph := ConvertCursorType(CursorInfo.graphCursor);

  {GroupArea}
  if Ord(FGroupArea) <> 0 then
  begin
    if FGroupArea <> rGroupArea then
    begin
      CursorInfo.groupAreaCursor := PECursorTypes[Ord(FGroupArea)];
      Changed := True;
    end;
  end;
  {GroupAreaField}
  if Ord(FGroupAreaField) <> 0 then
  begin
    if FGroupAreaField <> rGroupAreaField then
    begin
      CursorInfo.groupAreaFieldCursor := PECursorTypes[Ord(FGroupAreaField)];
      Changed := True;
    end;
  end;
  {DetailArea}
  if Ord(FDetailArea) <> 0 then
  begin
    if FDetailArea <> rDetailArea then
    begin
      CursorInfo.detailAreaCursor := PECursorTypes[Ord(FDetailArea)];
      Changed := True;
    end;
  end;
  {DetailAreaField}
  if Ord(FDetailAreaField) <> 0 then
  begin
    if FDetailAreaField <> rDetailAreaField then
    begin
      CursorInfo.detailAreaFieldCursor := PECursorTypes[Ord(FDetailAreaField)];
      Changed := True;
    end;
  end;
  {Graph}
  if Ord(FGraph) <> 0 then
  begin
    if FGraph <> rGraph then
    begin
      CursorInfo.graphCursor := PECursorTypes[Ord(FGraph)];
      Changed := True;
    end;
  end;

  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.Send <PESetTrackCursorInfo>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
end;


{******************************************************************************}
{ TCrpePages Class Definition                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ GetDisplayed method                                                          }
{------------------------------------------------------------------------------}
function TCrpePages.GetDisplayed : Word;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.DisplayPageN;
end;
{------------------------------------------------------------------------------}
{ GetLatest method                                                             }
{------------------------------------------------------------------------------}
function TCrpePages.GetLatest: Word;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.LatestPageN;
end;
{------------------------------------------------------------------------------}
{ GetStart method                                                              }
{------------------------------------------------------------------------------}
function TCrpePages.GetStart: Word;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.StartPageN;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpePages.Count: SmallInt;
begin
  Result := 0;
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  Result := PEGetNPages(Cr.FPrintJob);
end; {Count}
{------------------------------------------------------------------------------}
{ First method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpePages.First;
begin
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  if not PEShowFirstPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pages.First <PEShowFirstPage>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {First}
{------------------------------------------------------------------------------}
{ Next method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePages.Next;
begin
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  if not PEShowNextPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errPaging,errEngine,'',
        'Pages.Next <PEShowNextPage>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {Next}
{------------------------------------------------------------------------------}
{ Previous method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpePages.Previous;
begin
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  if not PEShowPreviousPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errPaging,errEngine,'',
       'Pages.Previous <PEShowPreviousPage>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {Previous}
{------------------------------------------------------------------------------}
{ Last method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePages.Last;
begin
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  if not PEShowLastPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pages.Last <PEShowLastPage>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {Last}
{------------------------------------------------------------------------------}
{ GoToPage method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpePages.GoToPage(const Value : SmallInt);
begin
  if (Cr.FPrintJob = 0) then
    Exit;
  Cr.SetDLLHandle;
  if not PEShowNthPage(Cr.FPrintJob, Value) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'Pages.GoToPage <PEShowNthPage>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {GoToPage}
{------------------------------------------------------------------------------}
{ GetIndex method                                                              }
{------------------------------------------------------------------------------}
function TCrpePages.GetIndex : integer;
begin
  Result := GetDisplayed;
end;
{------------------------------------------------------------------------------}
{ SetIndex method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpePages.SetIndex (const nIndex: integer);
begin
  GoToPage(nIndex);
end;
{------------------------------------------------------------------------------}
{ GetItem method                                                               }
{------------------------------------------------------------------------------}
function TCrpePages.GetItem (nIndex: integer) : string;
begin
  SetIndex(nIndex);
  Result := '';
end;


{******************************************************************************}
{ TCrpeRecords Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Printed method                                                               }
{------------------------------------------------------------------------------}
function TCrpeRecords.Printed : LongInt;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr.FPrintJob) = 0 then
    Exit;
  Cr.SetDLLHandle;
  PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.NumRecordsPrinted;
end;
{------------------------------------------------------------------------------}
{ Selected method                                                              }
{------------------------------------------------------------------------------}
function TCrpeRecords.Selected : LongInt;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr.FPrintJob) = 0 then
    Exit;
  Cr.SetDLLHandle;
  PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.NumRecordsSelected;
end;
{------------------------------------------------------------------------------}
{ Read method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeRecords.Read : LongInt;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr.FPrintJob) = 0 then
    Exit;
  Cr.SetDLLHandle;
  PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.NumRecordsRead;
end;


{******************************************************************************}
{ TCrpeSummaryInfo Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSummaryInfo.Create;
begin
  inherited Create;
  {Set Defaults}
  FAppName := '';
  FTitle := '';
  FSubject := '';
  FAuthor := '';
  FKeywords := '';
  FTemplate := '';
  FComments := TCrpeString.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSummaryInfo.Destroy;
begin
  FComments.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.Clear;
begin
  FAppName := '';
  FTitle := '';
  FSubject := '';
  FAuthor := '';
  FKeywords := '';
  FComments.Clear;
  FTemplate := '';
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.CopyFrom (Source: TCrpeSummaryInfo);
begin
  Clear;
  FAppName := Source.FAppName;
  FTitle := Source.FTitle;
  FSubject := Source.FSubject;
  FAuthor := Source.FAuthor;
  FKeywords := Source.FKeywords;
  FComments.Assign(Source.FComments);
  FTemplate := Source.FTemplate;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.Retrieve : boolean;
var
  SumInfo : PEReportSummaryInfo;
  nReport : integer;
  xJob    : smallint;
begin
  Result := False;
  if not Cr.OpenPrintEngine then
    Exit;
  {SummaryInfo only available in SCR 6+}
  if Cr.FVersion.FMajor < 6 then
    Exit;

  {SummaryInfo only applies to main Report: store SubReport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  {Change to Main Report}
  Cr.FSubreports.SetIndex(0);
  {Open PrintJob}
  if not Cr.OpenPrintJob then
  begin
    {Set Subreports class back to original setting}
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;

  Cr.SetDLLHandle;
  if not PEGetReportSummaryInfo(Cr.FPrintJob, SumInfo) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'SummaryInfo.Retrieve <PEGetReportSummaryInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    FAppName := String(SumInfo.applicationName);
    FTitle := String(SumInfo.title);
    FSubject := String(SumInfo.subject);
    FAuthor := String(SumInfo.author);
    FKeywords := String(SumInfo.keywords);
    FComments.SetText(PECommentsType(SumInfo.comments));
    FTemplate := String(SumInfo.reportTemplate);
    Result := True;
  end;
  {Re-set Subreports class}
  Cr.FSubreports.SetIndex(nReport);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.Send : boolean;
var
  SumInfo    : PEReportSummaryInfo;
  sTitle,
  sSubject,
  sAuthor,
  sKeywords,
  sTemplate  : TCrSummaryString;
  Changed    : Boolean;
  sTmp       : string;
  nReport    : integer;
  xJob       : smallint;
begin
  Result := False;
  {Test for blank values}
  if (FTitle = '') and (FSubject = '') and
     (FAuthor = '') and (FKeywords = '') and
     (FComments.Count = 0) and (FTemplate = '') then
     Exit;
  if not Cr.OpenPrintEngine then
    Exit;
  {SummaryInfo only available in CRW 6+}
  if Cr.FVersion.FMajor < 6 then
    Exit;

  {SummaryInfo only applies to main Report: store SubReport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  {Change to Main Report}
  Cr.FSubreports.SetIndex(0);
  {Open PrintJob}
  if not Cr.OpenPrintJob then
  begin
    {Set Subreports class back to original setting}
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;
  Changed := False;

  Cr.SetDLLHandle;
  {Get SummaryInfo from Report}
  if not PEGetReportSummaryInfo(Cr.FPrintJob, SumInfo) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'SummaryInfo.Send <PEGetReportSummaryInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Title}
  sTitle := String(SumInfo.title);
  if FTitle <> '' then
  begin
    if LowerCase(FTitle) = CrEmptyStr then
      FTitle := '';
    if CompareText(FTitle, sTitle) <> 0 then
    begin
      StrCopy(SumInfo.title, PChar(FTitle));
      Changed := True;
    end;
  end;

  {Subject}
  sSubject := String(SumInfo.subject);
  if FSubject <> '' then
  begin
    if LowerCase(FSubject) = CrEmptyStr then
      FSubject := '';
    if CompareText(FSubject, sSubject) <> 0 then
    begin
      StrCopy(SumInfo.subject, PChar(FSubject));
      Changed := True;
    end;
  end;

  {Author}
  sAuthor := String(SumInfo.author);
  if FAuthor <> '' then
  begin
    if LowerCase(FAuthor) = CrEmptyStr then
      FAuthor := '';
    if CompareText(FAuthor, sAuthor) <> 0 then
    begin
      StrCopy(SumInfo.author, PChar(FAuthor));
      Changed := True;
    end;
  end;

  {Keywords}
  sKeywords := String(SumInfo.keywords);
  if FKeywords <> '' then
  begin
    if LowerCase(FKeywords) = CrEmptyStr then
      FKeywords := '';
    if CompareText(FKeywords, sKeywords) <> 0 then
    begin
      StrCopy(SumInfo.keywords, PChar(FKeywords));
      Changed := True;
    end;
  end;

  {Comments}
  sTmp := RTrimList(FComments);
  if Length(sTmp) <> 0 then
  begin
    {Check for CrEmptyStr}
    if LowerCase(sTmp) = CrEmptyStr then
      sTmp := '';
    {Compare with Report}
    if StrComp(SumInfo.comments, PChar(sTmp)) <> 0 then
    begin
      StrCopy(SumInfo.comments, PChar(sTmp));
      Changed := True;
    end;
  end;

  {Template}
  sTemplate := String(SumInfo.reportTemplate);
  if FTemplate <> '' then
  begin
    if LowerCase(FTemplate) = CrEmptyStr then
      FTemplate := '';
    if CompareText(FTemplate, sTemplate) <> 0 then
    begin
      StrCopy(SumInfo.reportTemplate, PChar(FTemplate));
      Changed := True;
    end;
  end;

  {Set SummaryInfo}
  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetReportSummaryInfo(Cr.FPrintJob, SumInfo) then
    begin
      xJob := Cr.FPrintJob;
      Cr.FSubreports.SetIndex(nReport);
      case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
          'SummaryInfo.Send <PESetReportSummaryInfo>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
  {Set Subreports class back to original setting}
  Cr.FSubreports.SetIndex(nReport);
end;
{------------------------------------------------------------------------------}
{ Write method SetTitle                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetTitle(Value: TCrSummaryString);
begin
  FTitle := Value;
  {Check Length}
  if Length(FTitle) > PE_SI_TITLE_LEN then
    FTitle := Copy(FTitle, 1, PE_SI_TITLE_LEN);
end;
{------------------------------------------------------------------------------}
{ Write method SetSubject                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetSubject(Value: TCrSummaryString);
begin
  FSubject := Value;
  {Check Length}
  if Length(FSubject) > PE_SI_SUBJECT_LEN then
    FSubject := Copy(FSubject, 1, PE_SI_SUBJECT_LEN);
end;
{------------------------------------------------------------------------------}
{ Write method SetAuthor                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetAuthor(Value: TCrSummaryString);
begin
  FAuthor := Value;
  {Check Length}
  if Length(FAuthor) > PE_SI_AUTHOR_LEN then
    FAuthor := Copy(FAuthor, 1, PE_SI_AUTHOR_LEN);
end;
{------------------------------------------------------------------------------}
{ Write method SetKeywords                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetKeywords(Value: TCrSummaryString);
begin
  FKeywords := Value;
  {Check Length}
  if Length(FKeywords) > PE_SI_KEYWORDS_LEN then
    FKeywords := Copy(FKeywords, 1, PE_SI_KEYWORDS_LEN);
end;
{------------------------------------------------------------------------------}
{ Read method GetComments                                                      }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetComments : TCrpeString;
begin
  Result := FComments;
end;
{------------------------------------------------------------------------------}
{ Write method SetComments                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetComments(const ListVar: TCrpeString);
var
  sTmp: string;
begin
  FComments.Assign(ListVar);
  {Check Length}
  sTmp := FComments.Text;
  if Length(sTmp) > PE_SI_COMMENTS_LEN then
  begin
    sTmp := Copy(sTmp, 1, PE_SI_COMMENTS_LEN);
    FComments.Text := sTmp;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetTemplate                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetTemplate(Value: TCrSummaryString);
begin
  FTemplate := Value;
  {Check Length}
  if Length(FTemplate) > PE_SI_REPORT_TEMPLATE_LEN then
    FTemplate := Copy(FTemplate, 1, PE_SI_REPORT_TEMPLATE_LEN);
end;
{------------------------------------------------------------------------------}
{ Write method SetAppName                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetAppName(Value : TCrSummaryString);
begin
  {Read-only for now}
  {FAppName := Value;}
end;


{******************************************************************************}
{ TCrpeReportOptions Class Definition                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeReportOptions.Create;
begin
  inherited Create;
  {Set defaults}
  FSaveDataWithReport := cDefault;
  FSaveSummariesWithReport := cDefault;
  FUseIndexForSpeed := cDefault;
  FTranslateDOSStrings := cDefault;
  FTranslateDOSMemos := cDefault;
  FConvertNullFieldToDefault := cDefault;
  FPrintEngineErrorMessages := cDefault;
  FCaseInsensitiveSQLData := cDefault;
  FVerifyOnEveryPrint := cDefault;
  FCreateGroupTree := cDefault;
  FNoDataForHiddenObjects := cDefault;
  FPerformGroupingOnServer := cDefault;
  FConvertDateTimeType := dtDefault;
  FZoomMode := pwDefault;
  FAsyncQuery := cDefault;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.Clear;
begin
  {Set defaults}
  FSaveDataWithReport := cDefault;
  FSaveSummariesWithReport := cDefault;
  FUseIndexForSpeed := cDefault;
  FTranslateDOSStrings := cDefault;
  FTranslateDOSMemos := cDefault;
  FConvertNullFieldToDefault := cDefault;
  FPrintEngineErrorMessages := cDefault;
  FCaseInsensitiveSQLData := cDefault;
  FVerifyOnEveryPrint := cDefault;
  FCreateGroupTree := cDefault;
  FNoDataForHiddenObjects := cDefault;
  FPerformGroupingOnServer := cDefault;
  FConvertDateTimeType := dtDefault;
  FZoomMode := pwDefault;
  FAsyncQuery := cDefault;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.CopyFrom (Source: TCrpeReportOptions);
begin
  Clear;
  FSaveDataWithReport := Source.FSaveDataWithReport;
  FSaveSummariesWithReport := Source.FSaveSummariesWithReport;
  FUseIndexForSpeed := Source.FUseIndexForSpeed;
  FTranslateDOSStrings := Source.FTranslateDOSStrings;
  FTranslateDOSMemos := Source.FTranslateDOSMemos;
  FConvertNullFieldToDefault := Source.FConvertNullFieldToDefault;
  FPrintEngineErrorMessages := Source.FPrintEngineErrorMessages;
  FCaseInsensitiveSQLData := Source.FCaseInsensitiveSQLData;
  FVerifyOnEveryPrint := Source.FVerifyOnEveryPrint;
  FCreateGroupTree := Source.FCreateGroupTree;
  FNoDataForHiddenObjects := Source.FNoDataForHiddenObjects;
  FPerformGroupingOnServer := Source.FPerformGroupingOnServer;
  FConvertDateTimeType := Source.FConvertDateTimeType;
  FZoomMode := Source.FZoomMode;
  FAsyncQuery := Source.FAsyncQuery;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.Retrieve : boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {ReportOptions only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  Cr.SetDLLHandle;
  if not PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.Retrieve <PEGetReportOptions>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    FSaveDataWithReport := TCrBoolean(ReportOptions.saveDataWithReport);
    FSaveSummariesWithReport := TCrBoolean(ReportOptions.saveSummariesWithReport);
    FUseIndexForSpeed := TCrBoolean(ReportOptions.useIndexForSpeed);
    FTranslateDOSStrings := TCrBoolean(ReportOptions.translateDOSStrings);
    FTranslateDOSMemos := TCrBoolean(ReportOptions.translateDOSMemos);
    FConvertNullFieldToDefault := TCrBoolean(ReportOptions.convertNullFieldToDefault);
    FPrintEngineErrorMessages := TCrBoolean(ReportOptions.morePrintEngineErrorMessages);
    FCaseInsensitiveSQLData := TCrBoolean(ReportOptions.caseInsensitiveSQLData);
    FVerifyOnEveryPrint := TCrBoolean(ReportOptions.verifyOnEveryPrint);
    FCreateGroupTree := TCrBoolean(ReportOptions.hasGroupTree);
    FNoDataForHiddenObjects := TCrBoolean(ReportOptions.dontGenerateDataForHiddenObjects);
    FPerformGroupingOnServer := TCrBoolean(ReportOptions.performGroupingOnServer);
    case ReportOptions.convertDateTimeType of
      PE_RPTOPT_CVTDATETIMETOSTR : FConvertDateTimeType := dtConvertToString;
      PE_RPTOPT_CVTDATETIMETODATE: FConvertDateTimeType := dtConvertToDate;
      PE_RPTOPT_KEEPDATETIMETYPE : FConvertDateTimeType := dtKeepAsDateTime;
      else
      FConvertDateTimeType := dtDefault;
    end;
    case ReportOptions.zoomMode of
      PE_ZOOM_FULL_SIZE           : FZoomMode := pwNormal;
      PE_ZOOM_SIZE_FIT_ONE_SIDE   : FZoomMode := pwPageWidth;
      PE_ZOOM_SIZE_FIT_BOTH_SIDES : FZoomMode := pwWholePage;
      else
        FZoomMode := pwDefault;
    end;
    FAsyncQuery := TCrBoolean(ReportOptions.doAsyncQuery);
    Result := True;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.Send : boolean;
var
  ReportOptions : PEReportOptions;
  Changed       : Boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {ReportOptions only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  Changed := False;

  Cr.SetDLLHandle;
  {Get ReportOptions from Report}
  if not PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.Send <PEGetReportOptions>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SaveDataWithReport}
  if FSaveDataWithReport <> cDefault then
  begin
    if Ord(FSaveDataWithReport) <> ReportOptions.saveDataWithReport then
    begin
      ReportOptions.saveDataWithReport := Ord(FSaveDataWithReport);
      Changed := True;
    end;
  end;

  {SaveSummariesWithReport}
  if FSaveSummariesWithReport <> cDefault then
  begin
    if Ord(FSaveSummariesWithReport) <> ReportOptions.saveSummariesWithReport then
    begin
      ReportOptions.saveSummariesWithReport := Ord(FSaveSummariesWithReport);
      Changed := True;
    end;
  end;

  {UseIndexForSpeed}
  if FUseIndexForSpeed <> cDefault then
  begin
    if Ord(FUseIndexForSpeed) <> ReportOptions.useIndexForSpeed then
    begin
      ReportOptions.UseIndexForSpeed := Ord(FUseIndexForSpeed);
      Changed := True;
    end;
  end;

  {TranslateDOSStrings}
  if FTranslateDOSStrings <> cDefault then
  begin
    if Ord(FTranslateDOSStrings) <> ReportOptions.translateDOSStrings then
    begin
      ReportOptions.translateDOSStrings := Ord(FTranslateDOSStrings);
      Changed := True;
    end;
  end;

  {TranslateDOSMemos}
  if FTranslateDOSMemos <> cDefault then
  begin
    if Ord(FTranslateDOSMemos) <> ReportOptions.translateDOSMemos then
    begin
      ReportOptions.translateDOSMemos := Ord(FTranslateDOSMemos);
      Changed := True;
    end;
  end;

  {ConvertNullFieldToDefault}
  if FConvertNullFieldToDefault <> cDefault then
  begin
    if Ord(FConvertNullFieldToDefault) <> ReportOptions.convertNullFieldToDefault then
    begin
      ReportOptions.convertNullFieldToDefault := Ord(FConvertNullFieldToDefault);
      Changed := True;
    end;
  end;

  {PrintEngineErrorMessages}
  if FPrintEngineErrorMessages <> cDefault then
  begin
    if Ord(FPrintEngineErrorMessages) <> ReportOptions.morePrintEngineErrorMessages then
    begin
      ReportOptions.morePrintEngineErrorMessages := Ord(FPrintEngineErrorMessages);
      Changed := True;
    end;
  end;

  {CaseInsensitiveSQLData}
  if FCaseInsensitiveSQLData <> cDefault then
  begin
    if Ord(FCaseInsensitiveSQLData) <> ReportOptions.caseInsensitiveSQLData then
    begin
      ReportOptions.caseInsensitiveSQLData := Ord(FCaseInsensitiveSQLData);
      Changed := True;
    end;
  end;

  {VerifyOnEveryPrint}
  if FVerifyOnEveryPrint <> cDefault then
  begin
    if Ord(FVerifyOnEveryPrint) <> ReportOptions.verifyOnEveryPrint then
    begin
      ReportOptions.verifyOnEveryPrint := Ord(FVerifyOnEveryPrint);
      Changed := True;
    end;
  end;

  {CreateGroupTree}
  if FCreateGroupTree <> cDefault then
  begin
    if Ord(FCreateGroupTree) <> ReportOptions.hasGroupTree then
    begin
      ReportOptions.hasGroupTree := Ord(FCreateGroupTree);
      Changed := True;
    end;
  end;

  {NoDataForHiddenObjects}
  if FNoDataForHiddenObjects <> cDefault then
  begin
    if Ord(FNoDataForHiddenObjects) <> ReportOptions.dontGenerateDataForHiddenObjects then
    begin
      ReportOptions.dontGenerateDataForHiddenObjects := Ord(FNoDataForHiddenObjects);
      Changed := True;
    end;
  end;

  {FPerformGroupingOnServer}
  if FPerformGroupingOnServer <> cDefault then
  begin
    if Ord(FPerformGroupingOnServer) <> ReportOptions.performGroupingOnServer then
    begin
      ReportOptions.performGroupingOnServer := Ord(FPerformGroupingOnServer);
      Changed := True;
    end;
  end;

  {ConvertDateTimeType}
  if FConvertDateTimeType <> dtDefault then
  begin
    if Ord(FConvertDateTimeType) <> ReportOptions.convertDateTimeType then
    begin
      ReportOptions.convertDateTimeType := Ord(FConvertDateTimeType);
      Changed := True;
    end;
  end;

  {ZoomMode}
  if FZoomMode <> pwDefault then
  begin
    if Ord(FZoomMode) <> ReportOptions.zoomMode then
    begin
      ReportOptions.zoomMode := Ord(FZoomMode);
      Changed := True;
    end;
  end;

  {AsyncQuery}
  if FAsyncQuery <> cDefault then
  begin
    if Ord(FAsyncQuery) <> ReportOptions.doAsyncQuery then
    begin
      ReportOptions.doAsyncQuery := Ord(FAsyncQuery);
      Changed := True;
    end;
  end;

  {Set ReportOptions}
  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.Send <PESetReportOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
end;


{******************************************************************************}
{ TCrpeMargins Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeMargins.Create;
begin
  inherited Create;
  {Set defaults}
  FLeft := -1;
  FRight := -1;
  FTop := -1;
  FBottom := -1;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.Clear;
begin
  FLeft := -1;
  FRight := -1;
  FTop := -1;
  FBottom := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.CopyFrom (Source: TCrpeMargins);
begin
  Clear;
  FLeft := Source.FLeft;
  FRight := Source.FRight;
  FTop := Source.FTop;
  FBottom := Source.FBottom;
end;
{------------------------------------------------------------------------------}
{ Member function Retrieve                                                     }
{------------------------------------------------------------------------------}
function TCrpeMargins.Retrieve : boolean;
var
  nLeft, nRight,
  nTop,nBottom : Word;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nLeft := 0;
  nRight := 0;
  nTop := 0;
  nBottom := 0;

  Cr.SetDLLHandle;
  {Get Margins}
  if not PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.Retrieve <PEGetMargins>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FLeft := nLeft;
  FRight := nRight;
  FTop := nTop;
  FBottom := nBottom;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Member procedure Send                                                        }
{------------------------------------------------------------------------------}
function TCrpeMargins.Send : boolean;
var
  nLeft, nRight,
  nTop,nBottom  : Word;
  Changed       : boolean;

  {local procedure to compare margin settings}
  function CompareMargins(uMrg: Smallint; var rptMrg: Word): boolean;
  var
    rMrg: integer;
  begin
    Result := False;
    {If it is not set to ignore...}
    if (uMrg <> -1) then
    begin
      {If it is not equal to the Report settings...}
      rMrg := rptMrg;
      if uMrg <> rMrg then
      begin
        Result := True;
        {Use default margin settings for current printer}
        if (uMrg < -1) then
          rptMrg := PE_SM_DEFAULT
        {Use new value passed in}
        else if (uMrg > -1) then
          rptMrg := uMrg;
      end;
    end;
  end;

{Main procedure Margins.Send}
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nLeft := 0;
  nRight := 0;
  nTop := 0;
  nBottom := 0;
  Changed := False;

  Cr.SetDLLHandle;
  {Get Margins from Report}
  if not PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.Send <PEGetMargins>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare Margins}
  if CompareMargins(FLeft, nLeft) = True then
    Changed := True;
  if CompareMargins(FRight, nRight) = True then
    Changed := True;
  if CompareMargins(FTop, nTop) = True then
    Changed := True;
  if CompareMargins(FBottom, nBottom) = True then
    Changed := True;

  {Set Margins}
  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Margins.Send <PESetMargins>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
end; { Send }


{******************************************************************************}
{ TCrpePrintDate Class Definition                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePrintDate.Create;
begin
  inherited Create;
  {Set defaults}
  FDay   := 0;
  FMonth := 0;
  FYear  := 0;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpePrintDate.Clear;
begin
  FDay   := 0;
  FMonth := 0;
  FYear  := 0;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePrintDate.CopyFrom (Source: TCrpePrintDate);
begin
  Clear;
  FDay   := Source.FDay;
  FMonth := Source.FMonth;
  FYear  := Source.FYear;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpePrintDate.Retrieve : boolean;
var
  nReport : integer;
  xJob    : smallint;
begin
  Result := False;
  {PrintDate calls only apply to main Report: store Subreport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  Cr.FSubreports.SetIndex(0);
  {Make sure PrintJob is open}
  if not Cr.OpenPrintJob then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;

  Cr.SetDLLHandle;
  {Retrieve PrintDate}
  if not PEGetPrintDate(Cr.FPrintJob, FYear, FMonth, FDay) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'PrintDate.Retrieve <PEGetPrintDate>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
  Cr.FSubreports.SetIndex(nReport);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpePrintDate.Send : boolean;
var
  rptYear,
  rptMonth,
  rptDay    : Smallint;
  nReport   : integer;
  xJob      : smallint;
  Changed   : Boolean;
begin
  Result := False;
  {PrintDate calls only apply to main Report: store Subreport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  Cr.FSubreports.SetIndex(0);
  {Make sure PrintJob is open}
  if not Cr.OpenPrintJob then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;
  Changed := False;

  Cr.SetDLLHandle;
  {Retrieve PrintDate from Report}
  if not PEGetPrintDate(Cr.FPrintJob, rptYear, rptMonth, rptDay) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'PrintDate.Send <PEGetPrintDate>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Day}
  if FDay <> 0 then
  begin
    if FDay <> rptDay then
    begin
      rptDay := FDay;
      Changed := True;
    end;
  end;

  {Month}
  if FMonth <> 0 then
  begin
    if FMonth <> rptMonth then
    begin
      rptMonth := FMonth;
      Changed := True;
    end;
  end;

  {Year}
  if FYear <> 0 then
  begin
    if FYear <> rptYear then
    begin
      rptYear := FYear;
      Changed := True;
    end;
  end;

  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetPrintDate(Cr.FPrintJob, rptYear, rptMonth, rptDay) then
    begin
      xJob := Cr.FPrintJob;
      Cr.FSubreports.SetIndex(nReport);
      case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
          'PrintDate.Send <PESetPrintDate>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
  Cr.FSubreports.SetIndex(nReport);
end;


{******************************************************************************}
{ TCrpeExportEmail Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeExportEmail.Clear;
begin
  FCCList := '';
  FMessage := '';
  FSubject := '';
  FToList := '';
  FBCCList := '';
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeExportEmail.CopyFrom (Source: TCrpeExportEmail);
begin
  Clear;
  FCCList := Source.FCCList;
  FMessage := Source.FMessage;
  FSubject := Source.FSubject;
  FToList := Source.FToList;
  FBCCList := Source.FBCCList;
end;


{******************************************************************************}
{ TCrpeExportExchange Class Definition                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeExportExchange.Clear;
begin
  FFolder := '';
  FPassword := '';
  FProfile := '';
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeExportExchange.CopyFrom (Source: TCrpeExportExchange);
begin
  Clear;
  FFolder := Source.FFolder;
  FPassword := Source.FPassword;
  FProfile := Source.FProfile;
end;


{******************************************************************************}
{ TCrpeExportODBC Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeExportODBC.Clear;
begin
  FPassword := '';
  FSource := '';
  FTable := '';
  FUser := '';
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeExportODBC.CopyFrom (Source: TCrpeExportODBC);
begin
  Clear;
  FPassword := Source.FPassword;
  FSource := Source.FSource;
  FTable := Source.FTable;
  FUser := Source.FUser;
end;


{******************************************************************************}
{ TCrpeExportExcel Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportExcel.Create;
begin
  inherited Create;
  {Set defaults}
  FColumnHeadings := False;
  FColumnWidth    := ByArea;
  FTabularFormat  := False;
  FConstant       := 9;
  FArea           := 'D';
  FWorksheetFunctions := True;
  FXlsType        := Excel5Extended;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeExportExcel.CopyFrom (Source: TCrpeExportExcel);
begin
  Clear;
  FColumnHeadings := Source.FColumnHeadings;
  FColumnWidth    := Source.FColumnWidth;
  FTabularFormat  := Source.FTabularFormat;
  FConstant       := Source.FConstant;
  FArea           := Source.FArea;
  FWorksheetFunctions := Source.FWorksheetFunctions;
  FXlsType        := Source.FXlsType;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeExportExcel.Clear;
begin
  FColumnHeadings := False;
  FColumnWidth    := ByArea;
  FTabularFormat  := False;
  FConstant       := 9;
  FArea           := 'D';
  FWorksheetFunctions := True;
  FXlsType        := Excel5Extended;
end;


{******************************************************************************}
{ TCrpeExportLotusNotes Class Definition                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportLotusNotes.Create;
begin
  inherited Create;
  {Set defaults}
  FDBName := '';
  FFormName := '';
  FComments := '';
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeExportLotusNotes.Clear;
begin
  {Set defaults}
  FDBName := '';
  FFormName := '';
  FComments := '';
end;
{------------------------------------------------------------------------------}
{ CopyFrom method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeExportLotusNotes.CopyFrom (Source: TCrpeExportLotusNotes);
begin
  Clear;
  FDBName   := Source.FDBName;
  FFormName := Source.FFormName;
  FComments := Source.FComments;
end;


{******************************************************************************}
{ TCrpeExport Class Definition                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExport.Create;
begin
  inherited Create;
  {Set defaults}
  FFileName         := '';
  FFileType         := Ascii;
  FDestination      := toFile;
  FUseRptNumberFmt  := True;
  FUseRptDateFmt    := True;
  FCharSepQuote     := ' ';
  FCharSepSeparator := '';
  FLinesPerPage     := 60;
  FPromptForOptions := False;
  FPromptOnOverwrite := False;
  FEmail := TCrpeExportEmail.Create;
  FExchange := TCrpeExportExchange.Create;
  FODBC := TCrpeExportODBC.Create;
  FExcel := TCrpeExportExcel.Create;
  FLotusNotes := TCrpeExportLotusNotes.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeExport.Destroy;
begin
  FEmail.Free;
  FExchange.Free;
  FODBC.Free;
  FExcel.Free;
  FLotusNotes.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeExport.Clear;
begin
  FFileName         := '';
  FFileType         := Ascii;
  FDestination      := toFile;
  FUseRptNumberFmt  := True;
  FUseRptDateFmt    := True;
  FCharSepQuote     := ' ';
  FCharSepSeparator := '';
  FLinesPerPage     := 60;
  FPromptForOptions := False;
  FPromptOnOverwrite := False;
  FEmail.Clear;
  FExchange.Clear;
  FODBC.Clear;
  FExcel.Clear;
  FLotusNotes.Clear;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeExport.CopyFrom (Source: TCrpeExport);
begin
  Clear;
  FFileName         := Source.FFileName;
  FFileType         := Source.FFileType;
  FDestination      := Source.FDestination;
  FUseRptNumberFmt  := Source.FUseRptNumberFmt;
  FUseRptDateFmt    := Source.FUseRptDateFmt;
  FCharSepQuote     := Source.FCharSepQuote;
  FCharSepSeparator := Source.FCharSepSeparator;
  FLinesPerPage     := Source.FLinesPerPage;
  FPromptForOptions := Source.FPromptForOptions;
  FPromptOnOverwrite := Source.FPromptOnOverwrite;
  FEmail.CopyFrom (Source.FEmail);
  FExchange.CopyFrom (Source.FExchange);
  FODBC.CopyFrom (Source.FODBC);
  FExcel.CopyFrom (Source.FExcel);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeExport.Send : boolean;
type
  TFormat = (DifFormat, Rec, CommaSep, CharSep, HTML, ODBCType,
     PagText, Xls);
const
  UXFFormatType: array[TCrExportType] of Word =(
    UXFRecordType, UXFTabSeparatedType, UXFTextType, UXFDifType,
    UXFCommaSeparatedType, UXFCharSeparatedType, UXFTabbedTextType,
    UXFCrystalReportType, UXFLotusWk1Type, UXFLotusWk3Type, UXFLotusWksType,
    UXFRichTextFormatType, UXFWordWinType, UXFXls5TypeExt, UXFHTML3Type,
    UXFHTML32ExtType, UXFHTML32StdType, UXFODBCType, UXFPaginatedTextType,
    UXFReportDefinitionType);

  UXFExcelFormatType: array[TCrExportExcelType] of Word = (UXFXls2Type,
    UXFXls3Type, UXFXls4Type, UXFXls5Type, UXFXls5TypeExt, UXFXls7Type,
    UXFXls7TabType, UXFXls8Type, UXFXls8TabType);

  FormatDLL: array[TCrExportType] of PEDllNameType =
   ('u2frec.dll', 'u2fsepv.dll', 'u2ftext.dll', 'u2fdif.dll', 'u2fsepv.dll',
    'u2fsepv.dll', 'u2ftext.dll', 'u2fcr.dll', 'u2fwks.dll', 'u2fwks.dll',
    'u2fwks.dll', 'u2frtf.dll', 'u2fwordw.dll', 'u2fxls.dll', 'u2fhtml.dll',
    'u2fhtml.dll', 'u2fhtml.dll', 'u2fodbc.dll', 'u2ftext', 'u2frdef.dll');

  DestinationFormat: array[TCrExportDestination] of Word =
   (UXDDiskType, UXDMAPIType, UXDVIMType, UXDSMIType, UXDExchFolderType,
   UXDNotesType, UXDApplicationType);

  DestinationDLL: array[TCrExportDestination] of PEDllNameType =
   ('uxddisk.dll', 'uxdmapi.dll', 'uxdvim.dll', 'uxdvim.dll', 'uxdpost.dll',
   'uxdnotes.dll', 'uxdapp.dll');

var
  nCode  : Smallint;
  nGroup : integer;

  { Private FormatOptions }
  function FormatOptions(const Key: TFormat): Pointer;
  begin
    Result := nil;
    case Key of
      DifFormat:
        begin
          Cr.UXFDif.structSize := SizeOf(UXFDIFOptions);
          Cr.UXFDif.useReportNumberFormat := FUseRptNumberFmt;
          Cr.UXFDif.useReportDateFormat := FUseRptDateFmt;
          Result := @Cr.UXFDif;
        end;

      Rec:
        begin
          Cr.UXFRec.structSize := SizeOf(UXFRecordStyleOptions);
          Cr.UXFRec.useReportNumberFormat := FUseRptNumberFmt;
          Cr.UXFRec.useReportDateFormat := FUseRptDateFmt;
          Result := @Cr.UXFRec;
        end;

      CommaSep:
        begin
          Cr.UXFCsv.structSize := SizeOf(UXFCommaTabSeparatedOptions);
          Cr.UXFCsv.useReportNumberFormat := FUseRptNumberFmt;
          Cr.UXFCsv.useReportDateFormat := FUseRptDateFmt;
          Result := @Cr.UXFCsv;
        end;

      CharSep:
        begin
          Cr.UXFCharSep.structSize := SizeOf(UXFCharSeparatedOptions);
          Cr.UXFCharSep.useReportNumberFormat := FUseRptNumberFmt;
          Cr.UXFCharSep.useReportDateFormat := FUseRptDateFmt;
          Cr.UXFCharSep.stringDelimiter := FCharSepQuote;
          Cr.UXFCharSep.fieldDelimiter := PChar(FCharSepSeparator);
          Result := @Cr.UXFCharSep;
        end;

      HTML:
        begin
          Cr.UXFHTML.structSize := SizeOf(UXFHTML3Options);
          Cr.UXFHTML.filename := PChar(FFileName);
          Result := @Cr.UXFHTML;
        end;

      ODBCType:
        begin
          Cr.UXFODBC.structsize := SizeOf(UXFODBCOptions);
          Cr.UXFODBC.dataSourceName := PChar(FODBC.FSource);
          Cr.UXFODBC.dataSourceUserID := PChar(FODBC.FUser);
          Cr.UXFODBC.dataSourcePassword := PChar(FODBC.FPassword);
          Cr.UXFODBC.exportTableName := PChar(FODBC.FTable);
          Result := @Cr.UXFODBC
        end;

      PagText:
        begin
          Cr.UXFPagText.structSize := SizeOf(UXFPaginatedTextOptions);
          Cr.UXFPagText.nLinesPerPage := FLinesPerPage;
          Result := @Cr.UXFPagText;
        end;

      Xls:
        begin
          if (FExcel.FXlsType = Excel2) or
             (FExcel.FXlsType = Excel3) or
             (FExcel.FXlsType = Excel4) or
             (FExcel.FXlsType = Excel5) then
          begin
            Result := nil;
          end
          else
          begin
            {SCR 7 supports more Excel options}
            if Cr.FVersion.FMajor > 6 then
            begin
              Cr.UXFXls.structSize := SizeOf(UXFXlsOptions);
              Cr.UXFXls.bColumnHeadings := FExcel.FColumnHeadings;
              case FExcel.FColumnWidth of
                ByConstant : Cr.UXFXls.bUseConstColWidth := Bool(True);
                ByArea     : Cr.UXFXls.bUseConstColWidth := Bool(False);
              end;
              Cr.UXFXls.fConstColWidth := FExcel.FConstant;
              if not StrToSectionCode(FExcel.FArea, nCode) then
              begin
                case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
                    'Export.Send <StrToSectionCode>') of
                  cFalse   : Exit;
                  cTrue    : Abort;
                  cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
              end;
              nGroup := nCode mod 25;
              nCode := (nCode div 1000);
              Cr.UXFXls.baseAreaType := nCode;
              Cr.UXFXls.baseAreaGroupNum := nGroup + 1;
              Cr.UXFXls.bTabularFormat := Bool(FExcel.FTabularFormat);
              if (FExcel.FXlsType in [Excel7..Excel8Tab]) then
                Cr.UXFXls.bUseWorksheetFunc := Bool(FExcel.FWorksheetFunctions);
            end
            else if Cr.FVersion.FMajor = 6 then
            begin
              Cr.UXFXls.structSize := SizeOf(UXFXlsOptions6);
              Cr.UXFXls.bColumnHeadings := FExcel.FColumnHeadings;
              case FExcel.FColumnWidth of
                ByConstant : Cr.UXFXls.bUseConstColWidth := Bool(True);
                ByArea     : Cr.UXFXls.bUseConstColWidth := Bool(False);
              end;
              Cr.UXFXls.fConstColWidth := FExcel.FConstant;
              if not StrToSectionCode(FExcel.FArea, nCode) then
              begin
                case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
                    'Export.Send <StrToSectionCode>') of
                  cFalse   : Exit;
                  cTrue    : Abort;
                  cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
              end;
              nGroup := nCode mod 25;
              nCode := (nCode div 1000);
              Cr.UXFXls.baseAreaType := nCode;
              Cr.UXFXls.baseAreaGroupNum := nGroup + 1;
              Cr.UXFXls.bTabularFormat := Bool(FExcel.FTabularFormat);
            end
            else {CRW 5}
            begin
              Cr.UXFXls.structSize := SizeOf(UXFXlsOptions5);
              Cr.UXFXls.bColumnHeadings := FExcel.FColumnHeadings;
            end;
            Result := @Cr.UXFXls;
          end;
        end;
    end;
  end; { FormatOptions }

  { Private DiskOptions }
  function DiskOptions(const Key : TCrExportDestination) : Pointer;
  begin
    Result := nil;
    case Key of
      {Disk}
      toFile :
        begin
          Cr.UXDDisk.structSize := SizeOf(UXDDiskOptions);
          Cr.UXDDisk.filename := PChar(FFileName);
          Result := @Cr.UXDDisk;
        end;
      {MAPI}
      toEmailViaMapi :
        begin
          Cr.UXDMapi.structSize := SizeOf(UXDMAPIOptions);
          Cr.UXDMapi.toList := PChar(FEmail.FToList);
          Cr.UXDMapi.ccList := PChar(FEmail.FCCList);
          Cr.UXDMapi.subject := PChar(FEmail.FSubject);
          Cr.UXDMapi.mailmessage := PChar(FEmail.FMessage);
          Result := @Cr.UXDMapi;
        end;
      {VIM}
      toEMailViaVIM :
        begin
          Cr.UXDVIM.structSize := SizeOf(UXDVIMOptions);
          Cr.UXDVIM.toList := PChar(FEmail.FToList);
          Cr.UXDVIM.bccList := PChar(FEmail.FCCList);
          Cr.UXDVIM.ccList := PChar(FEmail.FBCCList);
          Cr.UXDVIM.subject := PChar(FEmail.FSubject);
          Cr.UXDVIM.mailmessage := PChar(FEmail.FMessage);
          Result := @Cr.UXDVIM;
        end;
      {SMI}
      toEMailViaSMI :
        begin
          Cr.UXDSMI.structSize := SizeOf(UXDSMIOptions);
          Cr.UXDSMI.toList := PChar(FEmail.FToList);
          Cr.UXDSMI.bccList := PChar(FEmail.FCCList);
          Cr.UXDSMI.ccList := PChar(FEmail.FBCCList);
          Cr.UXDSMI.subject := PChar(FEmail.FSubject);
          Cr.UXDSMI.mailmessage := PChar(FEmail.FMessage);
          Result := @Cr.UXDSMI;
        end;
      {Exchange}
      toMSExchange :
        begin
          Cr.UXDExch.structsize := SizeOf(UXDPostFolderOptions);
          Cr.UXDExch.pszProfile := PChar(FExchange.FProfile);
          Cr.UXDExch.pszPassword := PChar(FExchange.FPassword);
          Cr.UXDExch.pszFolderPath := PChar(FExchange.FFolder);
          Cr.UXDExch.wDestType := 1011; {UXDPostDocMessage}
          Result := @Cr.UXDExch;
        end;
      {Lotus Notes DB}
      toLotusNotes :
        begin
          Cr.UXDNotes.structsize := SizeOf(UXDNotesOptions);
          Cr.UXDNotes.szDBName := PChar(FLotusNotes.FDBName);
          Cr.UXDNotes.szFormName := PChar(FLotusNotes.FFormName);
          Cr.UXDNotes.szComments := PChar(FLotusNotes.FComments);
          Result := @Cr.UXDNotes;
        end;
      {Application}
      toApplication :
        begin
          Cr.UXDApp.structSize := SizeOf(UXDApplicationOptions);
          Cr.UXDApp.fileName := PChar(FFileName);
          Result := @Cr.UXDApp;
        end;
    end; { case }
  end; { DiskOptions }

{Main procedure: ExportOptions.Send}
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  Cr.FExportOpt.structSize := SizeOf(PEExportOptions);

  if FPromptForOptions then
  begin
    Cr.SetDLLHandle;
    if not PEGetExportOptions(Cr.FPrintJob, Cr.FExportOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errCancelDialog,errEngine,'',
          'ExportOptions.Send <PEGetExportOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end
  else
  begin
    {Set FormatOptions}
    Cr.pFormat := nil;
    Cr.UXFCharSep.fieldDelimiter := nil;
    case FFileType of
      Records                  : Cr.pFormat := FormatOptions(Rec);
      TabSeparated             : Cr.pFormat := FormatOptions(CommaSep);
      Ascii                    : Cr.pFormat := nil;
      Dif                      : Cr.pFormat := FormatOptions(DifFormat);
      Csv                      : Cr.pFormat := FormatOptions(CommaSep);
      CharacterSeparated       : Cr.pFormat := FormatOptions(CharSep);
      TabSeparatedText..WordForWindows : Cr.pFormat := nil;
      ExcelXLS                 : Cr.pFormat := FormatOptions(Xls);
      HTML30..HTML32std        : Cr.pFormat := FormatOptions(HTML);
      ODBCTable                : Cr.pFormat := FormatOptions(ODBCType);
      PaginatedText            : Cr.pFormat := FormatOptions(PagText);
      ReportDefinition         : Cr.pFormat := nil;
    end; { case ExportType }

    {Format DLL}
    StrCopy(Cr.FExportOpt.formatDLLName, FormatDLL[FFileType]);
    {Format Type}
    if FFileType = ExcelXLS then
      Cr.FExportOpt.formatType := UXFExcelFormatType[FExcel.FXLSType]
    else
      Cr.FExportOpt.formatType := UXFFormatType[FFileType];
    {Format Options}
    Cr.FExportOpt.formatOptions := Cr.pFormat;

    {Set DestinationOptions}
    Cr.pDisk := nil;
    if FDestination = toApplication then
    begin
      {If SCR 7+, and AppName not defined, use AppOptions}
      if IsStrEmpty(FAppName) and (Cr.FVersion.FMajor > 6) then
      begin
        StrCopy(Cr.FExportOpt.destinationDLLName, DestinationDLL[FDestination]{uxdapp});
        Cr.FExportOpt.destinationType := DestinationFormat[FDestination]{UXDApplicationType};
        Cr.pDisk := DiskOptions(FDestination);
        Cr.FExportOpt.destinationOptions := Cr.pDisk;
      end
      {AppOptions not supported with < SCR 7+, use DiskOptions}
      {Also, user may want to send to specific App,
       so the VCL will handle that in the Execute method}
      else
      begin
        StrCopy(Cr.FExportOpt.destinationDLLName, DestinationDLL[toFile]{uxddisk});
        Cr.FExportOpt.destinationType := DestinationFormat[toFile]{UXDDiskType};
        Cr.pDisk := DiskOptions(toFile);
        Cr.FExportOpt.destinationOptions := Cr.pDisk;
      end;
    end
    else
    begin
      StrCopy(Cr.FExportOpt.destinationDLLName, DestinationDLL[FDestination]);
      Cr.FExportOpt.destinationType := DestinationFormat[FDestination];
      Cr.pDisk := DiskOptions(FDestination);
      Cr.FExportOpt.destinationOptions := Cr.pDisk;
    end;
  (* Cr.FExportOpt.nFormatOptionsBytes := 0;       { n/a} *)
  (* Cr.FExportOpt.nDestinationOptionsBytes := 0;  { n/a} *)
  end;
  Cr.SetDLLHandle;
  if not PEExportTo(Cr.FPrintJob, Cr.FExportOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ExportOptions.Send <PEExportTo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Write method SetEmail                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExport.SetEmail(const Value: TCrpeExportEmail);
begin
  FEmail.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Write method SetExchange                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeExport.SetExchange(const Value: TCrpeExportExchange);
begin
  FExchange.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Write method SetODBC                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeExport.SetODBC(const Value: TCrpeExportODBC);
begin
  FODBC.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Write method SetExcel                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExport.SetExcel(const Value: TCrpeExportExcel);
begin
  FExcel.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Write method SetLotusNotes                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeExport.SetLotusNotes(const Value: TCrpeExportLotusNotes);
begin
  FLotusNotes.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ GetCrpe method                                                               }
{------------------------------------------------------------------------------}
function TCrpeExport.GetCrpe : TCrpe;
begin
  Result := Cr;
end;


{******************************************************************************}
{ TCrpePrinter Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePrinter.Create;
begin
  inherited Create;
  {Set defaults}
  FName := '';
  FPort := '';
  FDriver := '';
  FMode := 0;
  FPMode := nil;
  FOrientation := orDefault;
  FShowDialog := False;
  FPreserveRptSettings := [];
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.Clear;
begin
  FName := '';
  FPort := '';
  FDriver := '';
  FMode := 0;
  FPMode := nil;
  FOrientation := orDefault;
  FShowDialog := False;
  FPreserveRptSettings := [];
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.CopyFrom (Source: TCrpePrinter);
begin
  Clear;
  FName := Source.FName;
  FPort := Source.FPort;
  FDriver := Source.FDriver;
  SetPMode(Source.FPMode);
  FOrientation := Source.FOrientation;
  FShowDialog := Source.FShowDialog;
  FPreserveRptSettings := Source.FPreserveRptSettings;
end;
{------------------------------------------------------------------------------}
{ Member function GetDMPointerFromHandle                                       }
{  Gets a DevMode pointer from a Handle                                        }
{------------------------------------------------------------------------------}
function TCrpePrinter.GetDMPointerFromHandle(xHandle: THandle): PDevMode;
begin
  if xHandle <> 0 then
  begin
    Result := GlobalLock(xHandle);
    {If GlobalLock fails it could be a local variable}
    if Result = nil then
      Result := PDevMode(Pointer(xHandle)^)
    else
      GlobalUnlock(xHandle);
  end
  else
    Result := nil;
end;
{------------------------------------------------------------------------------}
{ Member function Retrieve                                                     }
{  Gets the printer information from the Report and fills in the               }
{  PrinterName, PrinterDriver, PrinterPort, and PrinterMode properties         }
{------------------------------------------------------------------------------}
function TCrpePrinter.Retrieve : boolean;
var
  hDriverText, hPrinterText, hPortText : hWnd;
  nDriverLen, nPrinterLen, nPortLen    : Smallint;
  pPrinter, pDriver, pPort             : PChar;
  pxDevMode                            : PDevMode;
  nReport                              : integer;
  xJob                                 : smallint;
begin
  Result := False;
  {Printer calls only apply to main Report: store Subreport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  Cr.FSubreports.SetIndex(0);
  {Make sure PrintJob is open}
  if not Cr.OpenPrintJob then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;
  pxDevMode := nil;

  Cr.SetDLLHandle;
  if PEGetSelectedPrinter(Cr.FPrintJob, hDriverText, nDriverLen, hPrinterText, nPrinterLen,
     hPortText, nPortLen, pxDevMode) then
  begin
    {The DevMode pointer from the Report returns Nil:
     This means that Default Printer, Default Options
     are selected in the Printer Setup dialog for that Report.
     Get Default Printer from System, use Default Orientation.}

    if pxDevMode = nil then
    begin
      FOrientation := orDefault;
      Printers.Printer.PrinterIndex := -1;
      Result := GetCurrent(False);
    end
    {Read Report Orientation}
    else
    begin
      case pxDevMode^.dmOrientation of
        dmOrient_Portrait  : FOrientation := orPortrait;
        dmOrient_Landscape : FOrientation := orLandscape;
        else
          FOrientation := orDefault;
      end;

      Cr.SetDLLHandle;
      {PrinterName}
      pPrinter := StrAlloc(nPrinterLen);
      if not PEGetHandleString(hPrinterText, pPrinter, nPrinterLen) then
      begin
        xJob := Cr.FPrintJob;
        Cr.FSubreports.SetIndex(nReport);
        StrDispose(pPrinter);
        case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
            'Printer.Retrieve <PEGetHandleString>') of
          cFalse   : Exit;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FName := String(pPrinter);
      StrDispose(pPrinter);

      Cr.SetDLLHandle;
      {PrinterDriver}
      pDriver := StrAlloc(nDriverLen);
      if not PEGetHandleString(hDriverText, pDriver, nDriverLen) then
      begin
        xJob := Cr.FPrintJob;
        Cr.FSubreports.SetIndex(nReport);
        StrDispose(pDriver);
        case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
            'Printer.Retrieve <PEGetHandleString>') of
          cFalse   : Exit;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FDriver := String(pDriver);
      StrDispose(pDriver);

      Cr.SetDLLHandle;
      {PrinterPort}
      pPort := StrAlloc(nPortLen);
      if not PEGetHandleString(hPortText, pPort, nPortLen) then
      begin
        xJob := Cr.FPrintJob;
        Cr.FSubreports.SetIndex(nReport);
        StrDispose(pPort);
        case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
            'Printer.Retrieve <PEGetHandleString>') of
          cFalse   : Exit;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FPort := String(pPort);
      StrDispose(pPort);

      {PrinterMode}
      SetPMode(pxDevMode);

      if (Trim(FName) <> '') and (Trim(FDriver) <> '') and (Trim(FPort) <> '') then
        Result := True
    end;
  end
  {PEGetSelectedPrinter fails: 'No Printer' is probably checked in
   the Printer Setup dialog for the Report, or the call failed.}
  else
  begin
    FName := '';
    FPort := '';
    FDriver := '';
    FMode := 0;
    FPMode := nil;
    FOrientation := orDefault;
  end;
  {Re-set Subreports}
  Cr.FSubreports.SetIndex(nReport);
end;
{------------------------------------------------------------------------------}
{ Member function GetPrinterInfoFromName                                       }
{------------------------------------------------------------------------------}
function TCrpePrinter.GetPrinterInfoFromName(PrtName: string): boolean;
var
  cnt1    : smallint;
  index   : smallint;
  PrtList : TStringList;
begin
  Result := False;
  PrtList := TStringList.Create;

  {Build List of Printer Names}
  for cnt1 := 0 to (Printers.Printer.Printers.Count - 1) do
    PrtList.Add(TCrPrinterDevice(Printers.Printer.Printers.Objects[cnt1]).Device);

  {If Printer Name is "HPLaserjet on LPT1:", get Device Name only}
  index := Printers.Printer.Printers.IndexOf(PrtName);
  if index > -1 then
    {Get Device Name only}
    PrtName := TCrPrinterDevice(Printers.Printer.Printers.Objects[index]).Device
  else
    {Locate Device Name in list}
    index := PrtList.IndexOf(PrtName);

  {If the Printer was found, get info}
  if index > -1 then
  begin
    Printers.Printer.PrinterIndex := index;
    if GetCurrent(False) then
      Result := True;
  end;
  PrtList.Free;
end;
{------------------------------------------------------------------------------}
{ Member function GetCurrent                                                   }
{  Gets the currently selected system printer information and fills in the     }
{  PrinterName, PrinterDriver, PrinterPort, and PrinterMode properties         }
{------------------------------------------------------------------------------}
function TCrpePrinter.GetCurrent(PreserveDevMode: boolean): boolean;
var
  hMode   : THandle;
  xPMode  : PDevMode;
  pName   : PChar;
  pDriver : PChar;
  pPort   : PChar;
begin
  GetMem(pName, 255);
  GetMem(pDriver, MAX_PATH);
  GetMem(pPort, MAX_PATH);
  {Use GetPrinter for the hMode since it will show the current
   settings (orientation, etc.) from a PrintDialog change}
  Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
  if LStrLen(pDriver) = 0 then
  begin
    GetProfileString('Devices',pName,'',pDriver,MAX_PATH);
    pDriver[Pos(',',pDriver) - 1] := #0;
  end;
  if LStrLen(pPort) = 0 then
  begin
    GetProfileString('Devices',pName,'',pPort,MAX_PATH);
    LStrCpy(pPort, @pPort[LStrLen(pPort) + 2]);
  end;
  FDriver := String(pDriver);
  FPort := String(pPort);

  {If GetCurrent is not being called after a PrintDialog...}
  if not PreserveDevMode then
  begin
    {SetPrinter causes the selected Printer to be updated
     as the current printer, in case the selection was by
     code and not by a PrintDialog}
    Printers.Printer.SetPrinter(pName, pDriver, pPort, 0);
    {Use GetPrinter then, to get the updated value for hMode}
    Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
  end;

  {If the Printer is currently selected, attempt to preserve DevMode}
  if FName = String(pName) then
  begin
    if FPMode <> nil then
    begin
      xPMode := GetDMPointerFromHandle(hMode);
      if xPMode <> nil then
      begin
        {Just to be safe...}
        if FPMode^.dmDeviceName = xPMode^.dmDeviceName then
          CopyDevMode(FPMode^, xPMode^);
      end;
    end;
  end;

  FName := String(pName);
  SetMode(hMode);

  FreeMem(pName, 255);
  FreeMem(pDriver, MAX_PATH);
  FreeMem(pPort, MAX_PATH);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Member function SetCurrent                                                   }
{  Sets the current VCL Printer to be the one selected in the Delphi           }
{   Application Environment.  In other words, when the PrintDialog is          }
{   called, it will have the Printer specified in the VCL selected by default. }
{------------------------------------------------------------------------------}
function TCrpePrinter.SetCurrent: boolean;
var
  hMode    : THandle;
  xPMode   : PDevMode;
  xDevMode : TDevMode;
  pName    : PChar;
  pDriver  : PChar;
  pPort    : PChar;
begin
  Result := False;
  if FName <> '' then
  begin
    if (FDriver = '') or (FPort = '') or (FPMode = nil) then
    begin
      if not GetPrinterInfoFromName(FName) then
        Exit;
    end;
    GetMem(pName, 255);
    GetMem(pDriver, MAX_PATH);
    GetMem(pPort, MAX_PATH);
    StrPCopy(pName, FName);
    StrPCopy(pDriver, FDriver);
    StrPCopy(pPort, FPort);
    if FPMode <> nil then
    begin
      CopyDevMode(FPMode^, xDevMode);
      Printers.Printer.SetPrinter(pName, pDriver, pPort, 0);
      Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
      xPMode := GetDMPointerFromHandle(hMode);
      if xPMode <> nil then
        CopyDevMode(xDevMode, xPMode^);
    end
    else
    begin
      Printers.Printer.SetPrinter(pName, pDriver, pPort, 0);
      Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
    end;
    FreeMem(pName, 255);
    FreeMem(pDriver, MAX_PATH);
    FreeMem(pPort, MAX_PATH);
    Result := True;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpePrinter.Send : TCrBoolean;
var
  curName, curDriver, curPort : string;
  curDevMode                  : TDevMode;
  curPMode                    : PDevMode;
  curOrientation              : TCrOrientation;
  rptName, rptDriver, rptPort : string;
  rptDevMode                  : TDevMode;
  rptPMode                    : PDevMode;
  I                           : integer;
  bCancel                     : boolean;
  iCopies                     : integer;
  nReport                     : integer;
  xJob                        : smallint;
begin
  Result := cDefault;
  {Printer calls only apply to main Report: store Subreport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  Cr.FSubreports.SetIndex(0);
  {Make sure PrintJob is open}
  if not Cr.OpenPrintJob then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;

  if IsStrEmpty(FName) and (FOrientation = orDefault) and
    (FPreserveRptSettings = []) and (FShowDialog = False) then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;

  {Backup the current values}
  curName := FName;
  curDriver := FDriver;
  curPort := FPort;
  if FPMode <> nil then
  begin
    CopyDevMode(FPMode^, curDevMode);
    curPMode := Addr(curDevMode);
  end
  else
    curPMode := nil;
  curOrientation := FOrientation;

  {Get Report values}
  Retrieve;
  rptName := FName;
  rptDriver := FDriver;
  rptPort := FPort;
  if FPMode <> nil then
  begin
    CopyDevMode(FPMode^, rptDevMode);
    rptPMode := Addr(rptDevMode);
  end
  else
    rptPMode := nil;

  {Restore current values}
  FName := curName;
  FDriver := curDriver;
  FPort := curPort;
  SetPMode(curPMode);
  FOrientation := curOrientation;

  if FShowDialog then
  begin
    if not ShowPrintDlg then
    begin
      Cr.FSubreports.SetIndex(nReport);
      Result := cFalse;
      Exit;
    end;
  end;

  {If no Printer Name has been set...}
  if IsStrEmpty(FName) then
  begin
    {If we have to set Orientation or Preserve Report Settings,
     get Printer from Report}
    if (FOrientation <> orDefault) or (FPreserveRptSettings <> []) then
    begin
      FName := rptName;
      FDriver := rptDriver;
      FPort := rptPort;
      SetPMode(rptPMode);
    end
    else
    begin
      Cr.FSubreports.SetIndex(nReport);
      Exit;
    end;
  end;

  {If Printername is "HPLaserjet on LPT1:", we only want the name}
  I := Printers.Printer.Printers.IndexOf(FName);
  if I > -1 then
    FName := TCrPrinterDevice(Printers.Printer.Printers.Objects[I]).Device;

  {If the Driver, Port, or PMode are not set, get them}
  if IsStrEmpty(FDriver) or IsStrEmpty(FPort) or (FPMode = nil) then
  begin
    if not GetPrinterInfoFromName(FName) then
    begin
      Cr.FSubreports.SetIndex(nReport);
      Exit;
    end;
  { begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_PRINTER_INFO,
        'Printer.Send <GetPrinterInfoFromName>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end; }
  end;

  {Check the Orientation property}
  if not (prOrientation in FPreserveRptSettings) then
  begin
    case FOrientation of
      orPortrait  :
        begin
          Printers.Printer.Orientation := poPortrait;
          FPMode^.dmFields := FPMode^.dmFields or DM_ORIENTATION;
          FPMode^.dmOrientation := DMORIENT_PORTRAIT;
        end;
      orLandscape :
        begin
          Printers.Printer.Orientation := poLandscape;
          FPMode^.dmFields := FPMode^.dmFields or DM_ORIENTATION;
          FPMode^.dmOrientation := DMORIENT_LANDSCAPE;
        end;
    end;
  end;

  {Preserve Report Settings}
  if (rptPMode <> nil) then
  begin
    if prOrientation in FPreserveRptSettings then
    begin
      FPMode^.dmFields := FPMode^.dmFields or DM_ORIENTATION;
      FPMode^.dmOrientation := rptDevMode.dmOrientation;
    end;
    if prPaperSize in FPreserveRptSettings then
    begin
      FPMode^.dmFields := FPMode^.dmFields or DM_PAPERSIZE;
      FPMode^.dmPaperSize := rptDevMode.dmPaperSize;
    end;
    if prPaperSource in FPreserveRptSettings then
    begin
      FPMode^.dmFields := FPMode^.dmFields or DM_DEFAULTSOURCE;
      FPMode^.dmDefaultSource := rptDevMode.dmDefaultSource;
    end;
  end; { if }
  {This is to prevent a problem with incrementing the
  number of copies printed.  If both PrintOptions.Copies
  and Printer.PMode^.dmCopies are set to more than 1,
  the number of copies are multiplied! This problem was
  fixed in CRPE32 from SCR 7.}
  if Cr.FVersion.FMajor < 7 then
  begin
    if Cr.FPrintOptions.FCopies > 1 then
    begin
      FPMode^.dmFields := FPMode^.dmFields or DM_COPIES;
      FPMode^.dmCopies := 1;
    end;
  end
  {Set DevMode copies to same as PrintOptions copies: this
   will affect the copies that appear in the dialog when
   the Preview Window Print button is clicked}
  else
  begin
    iCopies := Cr.FPrintOptions.FCopies;
    if FPMode^.dmCopies <> iCopies then
    begin
      FPMode^.dmFields := FPMode^.dmFields or DM_COPIES;
      FPMode^.dmCopies := iCopies;
    end;
  end;

  {OnPrinterSend event}
  if Assigned(Cr.FOnPrinterSend) then
  begin
    bCancel := False;
    Cr.FOnPrinterSend(Cr, FPMode, bCancel);
    if bCancel then
    begin
      Cr.FSubreports.SetIndex(nReport);
      Exit;
    end;
  end;

  Cr.SetDLLHandle;
  {Send Printer info to Report}
  if not PESelectPrinter(Cr.FPrintJob, PChar(FDriver),
    PChar(FName), PChar(FPort), FPMode) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'Printer.Send <PESelectPrinter>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Update DevMode: not sure why this is necessary, but it works...}
  GetCurrent(True);
  {Re-set Subreports item}
  Cr.FSubreports.SetIndex(nReport);
  Result := cTrue;
end; { Send }
{------------------------------------------------------------------------------}
{ ShowPrintDlg method                                                          }
{------------------------------------------------------------------------------}
function TCrpePrinter.ShowPrintDlg : boolean;
var
  PrinterDlg : TPrintDialog;
begin
  Result := False;
  {If a Printer is defined in the VCL make sure it is the
   selected one in the Delphi environment}
  SetCurrent;
  {Create the Print Dialog}
  PrinterDlg := TPrintDialog.Create(Cr);
  try
    {Set the PrintDialog options from the PrinterOptions}
    PrinterDlg.Options := [poPageNums, poWarning];
    PrinterDlg.Copies := Cr.FPrintOptions.FCopies;
    PrinterDlg.MinPage := 1;
    PrinterDlg.MaxPage := PE_MAXPAGEN; {65535}
    PrinterDlg.FromPage := Cr.FPrintOptions.FStartPage;
    PrinterDlg.ToPage := Cr.FPrintOptions.FStopPage;
    PrinterDlg.PrintRange := prPageNums;

    if (Cr.FPrintOptions.FStartPage < 2) then
    begin
      PrinterDlg.FromPage := 1;
      if (Cr.FPrintOptions.FStopPage = 0) or
         (Cr.FPrintOptions.FStopPage = 65535) then
        PrinterDlg.PrintRange := prAllPages;
    end;

    if (Cr.FPrintOptions.FStopPage < 1) then
      PrinterDlg.ToPage := 65535;

    if Cr.FPrintOptions.FCollation <> DefaultCollation then
      PrinterDlg.Collate := Boolean(Ord(Cr.FPrintOptions.FCollation));

    {Show the Print Dialog}
    if PrinterDlg.Execute then
    begin
      {Set the PrinterOptions from the PrintDialog}
      Cr.FPrintOptions.FStartPage := PrinterDlg.FromPage;
      Cr.FPrintOptions.FStopPage  := PrinterDlg.ToPage;
      Cr.FPrintOptions.FCopies  := PrinterDlg.Copies;
      Cr.FPrintOptions.FCollation := TCrCollation(Ord(PrinterDlg.Collate));
      if PrinterDlg.PrintRange = prAllPages then
      begin
        Cr.FPrintOptions.FStartPage := 1;
        Cr.FPrintOptions.FStopPage := 65535;
      end;
      {Put this in to update PrintOptions since
       in Execute, PrintOptions is sent first}
      Cr.FPrintOptions.Send;
      {Get the Selected Printer information}
      if GetCurrent(True) then
        Result := True;
    end;
  finally
    PrinterDlg.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetMode                                                         }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.SetMode(const Value : THandle);
begin
  FPMode := GetDMPointerFromHandle(Value);
  FMode := Value;
end; { SetMode }
{------------------------------------------------------------------------------}
{ Write method SetPMode                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.SetPMode(Value: PDevMode);
begin
  FPMode := Value;
  if FPMode = nil then
    FMode := 0
  else
    FMode := THandle(@FPMode);
end; { SetPMode }


{******************************************************************************}
{ TCrpePrintOptions Class Definition                                           }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePrintOptions.Create;
begin
  inherited Create;
  {Set defaults}
  FCopies := 1;
  FCollation := DefaultCollation;
  FStartPage := 0;
  FStopPage := 0;
  FPromptForOptions := False;
  FOutputFileName := '';
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.Clear;
begin
  FCopies := 1;
  FCollation := DefaultCollation;
  FStartPage := 0;
  FStopPage := 0;
  FPromptForOptions := False;
  FOutputFileName := '';
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.CopyFrom (Source: TCrpePrintOptions);
begin
  Clear;
  FCopies := Source.FCopies;
  FCollation := Source.FCollation;
  FStartPage := Source.FStartPage;
  FStopPage := Source.FStopPage;
  FPromptForOptions := Source.FPromptForOptions;
  FOutputFileName := Source.FOutputFileName;
end;
{------------------------------------------------------------------------------}
{ Member function Retrieve                                                     }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.Retrieve : boolean;
var
  PrintOpt : PEPrintOptions;
  nReport  : integer;
  xJob     : smallint;
begin
  Result := False;
  {Printer calls only apply to main Report: store Subreport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  Cr.FSubreports.SetIndex(0);
  {Make sure PrintJob is open}
  if not Cr.OpenPrintJob then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;

  Cr.SetDLLHandle;
  if not PEGetPrintOptions(Cr.FPrintJob, PrintOpt) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'PrintOptions.Retrieve <PEGetPrintOptions>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FStartPage := PrintOpt.StartPageN;
  FStopPage := PrintOpt.StopPageN;
  FCopies := PrintOpt.nReportCopies;
  case PrintOpt.Collation of
    PE_UNCOLLATED       : FCollation := Uncollated;
    PE_COLLATED         : FCollation := Collated;
    PE_DEFAULTCOLLATION : FCollation := DefaultCollation;
  end;
  {OutputFileName only availabe in SCR 7+}
  if Cr.FVersion.FMajor > 6 then
    FOutputFileName := String(PrintOpt.outputFileName);
  {Re-set Subreports item}
  Cr.FSubreports.SetIndex(nReport);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.Send : TCrBoolean;
var
  PrintOpt      : PEPrintOptions;
  pPrintOpt     : ^PEPrintOptions;
  nStart, nStop : Word;
  sTmp          : string;
  iCollation    : integer;
  Changed       : boolean;
  nReport       : integer;
  xJob          : smallint;
begin
  Result := cDefault;
  {Printer calls only apply to main Report: store Subreport index}
  nReport := Cr.FSubreports.ItemIndex;
  if nReport < 0 then nReport := 0;
  Cr.FSubreports.SetIndex(0);
  {Make sure PrintJob is open}
  if not Cr.OpenPrintJob then
  begin
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;
  Changed := False;

  {Check PromptForOptions value}
  if FPromptForOptions = True then
  begin
    pPrintOpt := nil;
    Cr.SetDLLHandle;
    if not PESetPrintOptions(Cr.FPrintJob, PEPrintOptions(pPrintOpt^)) then
    begin
      xJob := Cr.FPrintJob;
      Cr.FSubreports.SetIndex(nReport);
      Result := cFalse;
      case Cr.GetErrorMsg(xJob,errCancelDialog,errEngine,'',
          'PrintOptions.Send <PESetPrintOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := cTrue;
    {Store the new options in the VCL}
    Retrieve;
    Cr.FSubreports.SetIndex(nReport);
    Exit;
  end;

  Cr.SetDLLHandle;
  {Get PrintOptions from Report}
  if not PEGetPrintOptions(Cr.FPrintJob, PrintOpt) then
  begin
    xJob := Cr.FPrintJob;
    Cr.FSubreports.SetIndex(nReport);
    case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
        'PrintOptions.Send <PEGetPrintOptions>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {StartPage}
  nStart := FStartPage;
  if nStart = 0 then
    nStart := 1;
  if PrintOpt.StartPageN <> nStart then
  begin
    PrintOpt.StartPageN := nStart;
    Changed := True;
  end;

  {StopPage}
  nStop := FStopPage;
  if nStop = 0 then
    nStop := 65535; {MaxWord}
  if PrintOpt.StopPageN <> nStop then
  begin
    PrintOpt.StopPageN := nStop;
    Changed := True;
  end;

  {Copies}
  if PrintOpt.nReportCopies <> FCopies then
  begin
    PrintOpt.nReportCopies := FCopies;
    Changed := True;
  end;

  {Collation}
  iCollation := Ord(FCollation);
  if PrintOpt.Collation <> iCollation then
  begin
    PrintOpt.Collation := iCollation;
    Changed := True;
  end;

  {OutputFileName only availabe in SCR 7+}
  if Cr.FVersion.FMajor > 6 then
  begin
    sTmp := String(PrintOpt.outputFileName);
    if CompareText(FOutputFileName, sTmp) <> 0 then
    begin
      StrCopy(PrintOpt.outputFileName, PChar(FOutputFileName));
      Changed := True;
    end;
  end;

  {Send PrintOptions}
  if Changed then
  begin
    if not PESetPrintOptions(Cr.FPrintJob, PrintOpt) then
    begin
      xJob := Cr.FPrintJob;
      Cr.FSubreports.SetIndex(nReport);
      case Cr.GetErrorMsg(xJob,errNoOption,errEngine,'',
          'PrintOptions.Send <PESetPrintOptions>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := cTrue;
  end;
  {Re-set Subreports item}
  Cr.FSubreports.SetIndex(nReport);
end; { Send }
{------------------------------------------------------------------------------}
{ Write method SetOutputFileName                                               }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.SetOutputFileName(const Value : TCrPrintFileName);
begin
  FOutputFileName := Value;
  {Check Length}
  if Length(FOutputFileName) > PE_FILE_PATH_LEN then
    FOutputFileName := Copy(FOutputFileName, 1, PE_FILE_PATH_LEN);
end;

(*
{******************************************************************************}
{ TCrpeFax Class Definition                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeFax.Create;
begin
  inherited Create;
  {Set defaults}
  FFaxType := ftBlackIce;
  FPhoneNumber := '';
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeFax.Clear;
begin
  FFaxType := ftBlackIce;
  FPhoneNumber := '';
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeFax.CopyFrom (Source: TCrpeFax): boolean;
begin
  Clear;
  try
    FFaxType := Source.FFaxType;
    FPhoneNumber := Source.FPhoneNumber;
    Result := True;
  except
    Result := False;
  end;
end;
*)

{******************************************************************************}
{ TCrpeConnect Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeConnect.Create;
begin
  inherited Create;
  {Set defaults}
  FServerName   := '';
  FUserID       := '';
  FPassword     := '';
  FDatabaseName := '';
  FPropagate    := False;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.Clear;
begin
  FServerName   := '';
  FUserID       := '';
  FPassword     := '';
  FDatabaseName := '';
  FPropagate    := False;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.CopyFrom (Source: TCrpeConnect);
begin
  Clear;
  FServerName   := Source.FServerName;
  FUserID       := Source.FUserID;
  FPassword     := Source.FPassword;
  FDatabaseName := Source.FDatabaseName;
  FPropagate    := Source.FPropagate;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeConnect.Retrieve : boolean;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : smallint;
  bProp           : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear but keep Propagate setting}
  bProp := FPropagate;
  Clear;
  FPropagate := bProp;

  Cr.SetDLLHandle;
  nTables := PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Connect.Retrieve <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Loop through tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    Cr.SetDLLHandle;
    {Try to find an SQL table}
    if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.Retrieve <PEGetNthTableType>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if (TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
    begin
      Cr.SetDLLHandle;
      if not PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.Retrieve <PEGetNthTableLogOnInfo>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FServerName := String(LogInfo.ServerName);
      FUserID := String(LogInfo.UserID);
      FPassword := String(LogInfo.Password);
      FDatabaseName := String(LogInfo.DatabaseName);
      Result := True;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Test method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeConnect.Test: boolean;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : Smallint;
  nRpt            : integer;
  nSub            : integer;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {If Propagate is set we need to go through all the reports}
  if (FPropagate = True) or (Cr.FSubreports.ListItem(0).FConnect.FPropagate = True) then
  begin
    {Store current Rpt Index}
    nSub := Cr.FSubreports.FIndex;
    if Cr.FSubreports.Count = 1 then
      Cr.FSubreports.Retrieve;

    {Loop through the reports}
    for nRpt := 0 to (Cr.FSubreports.Count - 1) do
    begin
      {Set up the report pointer}
      Cr.FSubreports.SetIndex(nRpt);
      {Grab the Connect data from the Main report}
      if nRpt = 0 then
      begin
        StrCopy(LogInfo.ServerName, PChar(FServerName));
        StrCopy(LogInfo.UserID, PChar(FUserID));
        StrCopy(LogInfo.Password, PChar(FPassword));
        StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
      end;

      Cr.SetDLLHandle;
      {Get the number of tables}
      nTables := PEGetNTables(Cr.FPrintJob);
      if nTables = -1 then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.Test <PEGetNTables>') of
          cFalse   : Continue;
          cTrue    : begin
              {Reset the report pointer}
              Cr.FSubreports.SetIndex(nSub);
              Abort;
            end;
          cDefault : begin
              {Reset the report pointer}
              Cr.FSubreports.SetIndex(nSub);
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Loop through the tables}
      for nIndex := 0 to (nTables - 1) do
      begin
        Cr.SetDLLHandle;
        if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
               'Connect.Test <PEGetNthTableType>') of
            cFalse   : Continue;
            cTrue    : begin
                {Reset the report pointer}
                Cr.FSubreports.SetIndex(nSub);
                Abort;
              end;
            cDefault : begin
                {Reset the report pointer}
                Cr.FSubreports.SetIndex(nSub);
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;
        {Try to find an SQL table}
        if (TableType.DBType = PE_DT_SQL) or
           (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
        begin
          Cr.SetDLLHandle;
          {Set LogOnInfo}
          if not PESetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo, False) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'Connect.Test <PESetNthTableLogOnInfo>') of
              cFalse   : Continue;
              cTrue    : begin
                  {Reset the report pointer}
                  Cr.FSubreports.SetIndex(nSub);
                  Abort;
                end;
              cDefault : begin
                  {Reset the report pointer}
                  Cr.FSubreports.SetIndex(nSub);
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          Cr.SetDLLHandle;
          if not PETestNthTableConnectivity(Cr.FPrintJob, nIndex) then
          begin
            Result := False;
            {Reset the report pointer}
            Cr.FSubreports.SetIndex(nSub);
            Exit;
          end
          else
            Result := True;
        end;
      end;
    end;
    {Reset the report pointer}
    Cr.FSubreports.SetIndex(nSub);
  end
  {Propagate is False}
  else
  begin
    {Set the Connect logon info}
    StrCopy(LogInfo.ServerName, PChar(FServerName));
    StrCopy(LogInfo.UserID, PChar(FUserID));
    StrCopy(LogInfo.Password, PChar(FPassword));
    StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));

    Cr.SetDLLHandle;
    {Get the number of tables}
    nTables := PEGetNTables(Cr.FPrintJob);
    if nTables = -1 then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.Test <PEGetNTables>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Loop through the tables}
    for nIndex := 0 to (nTables - 1) do
    begin
      Cr.SetDLLHandle;
      if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.Test <PEGetNthTableType>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      {Try to find an SQL table}
      if (TableType.DBType = PE_DT_SQL) or
         (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
      begin
        Cr.SetDLLHandle;
        {Set LogOnInfo and propagate through other tables}
        if not PESetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo, True) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Connect.Test <PESetNthTableLogOnInfo>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Cr.SetDLLHandle;
        {Test Connect}
        Result := PETestNthTableConnectivity(Cr.FPrintJob, nIndex);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeConnect.Send : boolean;
var
  LogInfo                : PELogOnInfo;
  nTable, nTables        : smallint;   { first table }
  sDSN, sPWD, sUID, sDSQ : string;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nTable := 0;

  Cr.SetDLLHandle;
  {Get number of tables}
  nTables := PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Connect.Send <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {If there are no Tables, do not send Connect}
  if nTables = 0 then
    Exit;

  {if Connect.Propagate = True, use Main Report
   Connect for all Subreports also}
  if Cr.FSubreports.ListItem(0).FConnect.FPropagate = True then
  begin
    sDSN := Cr.FSubreports.ListItem(0).FConnect.FServerName;
    sUID := Cr.FSubreports.ListItem(0).FConnect.FUserID;
    sPWD := Cr.FSubreports.ListItem(0).FConnect.FPassword;
    sDSQ := Cr.FSubreports.ListItem(0).FConnect.FDatabaseName;
  end
  else
  begin
    sDSN := Cr.SubItem.FConnect.FServerName;
    sUID := Cr.SubItem.FConnect.FUserID;
    sPWD := Cr.SubItem.FConnect.FPassword;
    sDSQ := Cr.SubItem.FConnect.FDatabaseName;
  end;

  {If Connect info is blank, exit}
  if (sDSN = '') and (sUID = '') and
     (sPWD = '') and (sDSQ = '') then
    Exit;

  StrCopy(LogInfo.ServerName, PChar(sDSN));
  StrCopy(LogInfo.DatabaseName, PChar(sDSQ));
  StrCopy(LogInfo.UserID, PChar(sUID));
  StrCopy(LogInfo.Password, PChar(sPWD));

  Cr.SetDLLHandle;
  {Send the Connect to the Report}
  if not PESetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo, True) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Connect.Send <PESetNthTableLogOnInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
end; { Send }


{******************************************************************************}
{ TCrpeLogOnServerItem Class Definition                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnServerItem.Create;
begin
  inherited Create;
  FServerName   := '';
  FUserID       := '';
  FPassword     := '';
  FDatabaseName := '';
  FDllName      := '';
  FNumber       := -1;
end;


{******************************************************************************}
{ TCrpeLogOnServer Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnServer.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeLogOnServer.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.CopyFrom (Source: TCrpeLogOnServer);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add;
    ListItem(cnt).FServerName := Source[cnt].ServerName;
    ListItem(cnt).FUserID := Source[cnt].UserID;
    ListItem(cnt).FPassword := Source[cnt].Password;
    ListItem(cnt).FDatabaseName := Source[cnt].DatabaseName;
    ListItem(cnt).FDllName := Source[cnt].DllName;
    ListItem(cnt).FNumber := Source[cnt].Number;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.Retrieve : boolean;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : smallint;
  nRptIndex       : integer;
  nRpt            : integer;
  slTmp           : TStringList;
  sTmp            : string;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the current LogOnServer items}
  Clear;
  {Allocate memory for Temporary list}
  slTmp := TStringList.Create;

  {Store the current Rpt Index}
  nRptIndex := Cr.FSubreports.FIndex;
  {Make sure Subreport info is setup}
  if Cr.FSubreports.Count = 1 then
    Cr.FSubreports.Retrieve;

  {Loop through Reports}
  for nRpt := 0 to (Cr.FSubreports.Count - 1) do
  begin
    {Set Report number}
    Cr.FSubreports.SetIndex(nRpt);
    Cr.SetDLLHandle;
    {Loop through the tables}
    nTables := PEGetNTables(Cr.FPrintJob);
    for nIndex := 0 to (nTables - 1) do
    begin
      Cr.SetDLLHandle;
      if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'LogOnServer.Retrieve <PEGetNthTableType>') of
          cFalse   : Continue;
          cTrue    : begin
              slTmp.Free;
              Cr.FSubreports.SetIndex(nRptIndex);
              Abort;
            end;
          cDefault : begin
              slTmp.Free;
              Cr.FSubreports.SetIndex(nRptIndex);
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;
      {Try to find an SQL table}
      if (TableType.DBType = PE_DT_SQL) or
         (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
      begin
        Cr.SetDLLHandle;
        if not PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'LogOnServer.Retrieve <PEGetNthTableLogOnInfo>') of
            cFalse   : Continue;
            cTrue    : begin
                slTmp.Free;
                Cr.FSubreports.SetIndex(nRptIndex);
                Abort;
              end;
            cDefault : begin
                slTmp.Free;
                Cr.FSubreports.SetIndex(nRptIndex);
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;
        {Only take unique LogOn info}
        sTmp := String(TableType.DLLName) +
                String(LogInfo.ServerName) +
                String(LogInfo.UserID) +
                String(LogInfo.DatabaseName);
        if slTmp.IndexOf(sTmp) = -1 then
        begin
          slTmp.Add(sTmp);
          Add;
          ListItem(FIndex).FDLLName := String(TableType.DLLName);
          ListItem(FIndex).FServerName := String(LogInfo.ServerName);
          ListItem(FIndex).FUserID := String(LogInfo.UserID);
          ListItem(FIndex).FPassword := String(LogInfo.Password);
          ListItem(FIndex).FDatabaseName := String(LogInfo.DatabaseName);
          ListItem(FIndex).FNumber := 0;
          Result := True;
        end;
      end;
    end;
  end;
  slTmp.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
  {Restore Rpt index}
  Cr.FSubreports.SetIndex(nRptIndex);
end; {Retrieve}
{------------------------------------------------------------------------------}
{ LogOn method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.LogOn : boolean;
var
  LogInfo  : PELogOnInfo;
  pDllName : array[0..255] of Char;
  cnt1     : smallint;
  nIndex   : smallint;
  nJob     : smallint;
begin
  Result := False;
  if not Cr.OpenPrintEngine then
    Exit;

  StrCopy(LogInfo.ServerName, PChar(ListItem(FIndex).FServerName));
  StrCopy(LogInfo.DatabaseName, PChar(ListItem(FIndex).FDatabaseName));
  StrCopy(LogInfo.UserID, PChar(ListItem(FIndex).FUserId));
  StrCopy(LogInfo.Password, PChar(ListItem(FIndex).FPassword));
  StrCopy(pDllName, PChar(UpperCase(ListItem(FIndex).FDllName)));

  Cr.SetDLLHandle;
  if not PELogOnServer(pDllName, LogInfo) then
  begin
    Cr.SetDLLHandle;
    {If PrintJob does not return error, try zero}
    nJob := Cr.FPrintJob;
    if PEGetErrorCode(nJob) = 0 then
      nJob := 0;
    case Cr.GetErrorMsg(nJob,errNoOption,errEngine,'',
        'LogOnServer.LogOn <PELogOnServer>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Set the LogOn Number}
  cnt1 := 0;
  while (Result = False) do
  begin
    {LogOn numbers start with 1, not 0}
    {Check to see if the LogOn number exists already}
    nIndex := IndexOfNumber(cnt1 + 1);
    {If the number wasn't found, use it}
    if nIndex = -1 then
    begin
      ListItem(FIndex).FNumber := cnt1 + 1;
      Result := True;
    end
    else
      Inc(cnt1);
  end;
end;
{------------------------------------------------------------------------------}
{ LogOff method                                                                }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.LogOff : boolean;
var
  LogInfo  : PELogOnInfo;
  pDllName : array[0..255] of Char;
  nTmp     : integer;
  nJob     : smallint;
begin
  Result := False;
  if not Cr.OpenPrintEngine then
    Exit;

  {Get the LogOn Number}
  nTmp := ListItem(FIndex).FNumber;
  {If already Logged Off, Exit}
  if (nTmp = 0) then
    Exit;

  Cr.SetDLLHandle;
  StrCopy(LogInfo.ServerName, PChar(ListItem(FIndex).FServerName));
  StrCopy(LogInfo.DatabaseName, PChar(ListItem(FIndex).FDatabaseName));
  StrCopy(LogInfo.UserID, PChar(ListItem(FIndex).FUserID));
  StrCopy(LogInfo.Password, PChar(ListItem(FIndex).FPassword));
  StrCopy(pDllName, PChar(ListItem(FIndex).FDllName));
  if not PELogOffServer(pDllName, LogInfo) then
  begin
    {If PrintJob does not return error, try zero}
    nJob := Cr.FPrintJob;
    Cr.SetDLLHandle;
    if PEGetErrorCode(nJob) = 0 then
      nJob := 0;
    case Cr.GetErrorMsg(nJob,errNoOption,errEngine,'',
        'LogOnServer.LogOff <PELogOffServer>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(FIndex).FNumber := 0;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.ListItem(nIndex: integer): TCrpeLogOnServerItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.Add: integer;
var
  p1 : Pointer;
begin
  p1 := TCrpeLogOnServerItem.Create;
  FIndex := FList.Add(p1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'LogOnServer.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.IndexOf(Server,User,Database: string): integer;
var
  cnt   : integer;
  s1,s2 : string;
begin
  Result := -1;
  s1 := Server + User + Database;
  for cnt := 0 to FList.Count - 1 do
  begin
    s2 := ListItem(cnt).FServerName + ListItem(cnt).FUserID +
      ListItem(cnt).FDatabaseName;
    if CompareText(s1,s2) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ IndexOfNumber method                                                         }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.IndexOfNumber(LogNumber: integer): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = LogNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetDLLName                                                       }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetDLLName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDLLName;
end;
{------------------------------------------------------------------------------}
{ Write method SetDLLName                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetDLLName(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDLLName := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetServerName                                                    }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetServerName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FServerName
end;
{------------------------------------------------------------------------------}
{ Write method SetServerName                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetServerName(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FServerName := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetUserID                                                        }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetUserID : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUserID;
end;
{------------------------------------------------------------------------------}
{ Write method SetUserID                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetUserID(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FUserID := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetPassword                                                      }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetPassword : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPassword;
end;
{------------------------------------------------------------------------------}
{ Write method SetPassword                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetPassword(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPassword := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetDatabaseName                                                  }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetDatabaseName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDatabaseName;
end;
{------------------------------------------------------------------------------}
{ Write method SetDatabaseName                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetDatabaseName(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDatabaseName := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetNumber                                                        }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetNumber : integer;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'LogOnServer[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetItem                                                          }
{   - This is the default property and can be also set                         }
{      via Crpe1.LogOnServer[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetItem(nIndex: integer) : TCrpeLogOnServer;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeLogOnInfoItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnInfoItem.Create;
begin
  inherited Create;
  FTable           := -1;
  FServerName      := '';
  FUserID          := '';
  FPassword        := '';
  FDatabaseName    := '';
  FDLLName         := '';
  FDescriptiveName := '';
  FTableType       := ttUnknown;
end;


{******************************************************************************}
{ Class TCrpeLogOnInfo                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnInfo.Create;
begin
  inherited Create;
  FList := TList.Create;
  FPromptForLogOn := False;
  FSQLTablesOnly := True;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeLogOnInfo.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FPromptForLogOn := False;
  FSQLTablesOnly := True;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.CopyFrom (Source: TCrpeLogOnInfo);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Table);
    ListItem(cnt).FServerName := Source[cnt].ServerName;
    ListItem(cnt).FUserID := Source[cnt].UserID;
    ListItem(cnt).FPassword := Source[cnt].Password;
    ListItem(cnt).FDatabaseName := Source[cnt].DatabaseName;
    ListItem(cnt).FDLLName := Source[cnt].DLLName;
    ListItem(cnt).FDescriptiveName := Source[cnt].DescriptiveName;
    ListItem(cnt).FTableType := Source[cnt].TableType;
  end;
  FPromptForLogOn := Source.PromptForLogOn;
  FSQLTablesOnly := Source.SQLTablesOnly;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.IndexOf (TableNumber: TCrLogOnInfoTable): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FTable = TableNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.ListItem(nIndex: integer) : TCrpeLogOnInfoItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.Add (TableNumber: TCrLogOnInfoTable): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(TableNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
      'LogOnInfo <' + IntToStr(TableNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeLogOnInfoItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FTable := TableNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'LogOnInfo.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.Retrieve : boolean;
var
  LogInfo   : PELogOnInfo;
  TableType : PETableType;
  nTables,
  nIndex    : smallint;
  bPrompt   : boolean;
  bSQL      : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the LogOnInfo stringlists: retain option settings}
  bPrompt := FPromptForLogOn;
  bSQL := FSQLTablesOnly;
  Clear;
  FPromptForLogOn := bPrompt;
  FSQLTablesOnly := bSQL;

  Cr.SetDLLHandle;
  {Loop through the tables}
  nTables := PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'LogOnInfo.Retrieve <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  for nIndex := 0 to (nTables - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'LogOnInfo.Retrieve <PEGetNthTableType>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {If SQLTablesOnly then check for SQL table}
    if FSQLTablesOnly and not ((TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE)) then
      Continue;
    Cr.SetDLLHandle;
    {Get the LogOnInfo}
    if not PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'LogOnInfo.Retrieve <PEGetNthTableLogOnInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Add(nIndex);
    ListItem(FIndex).FServerName := String(LogInfo.ServerName);
    ListItem(FIndex).FUserID := String(LogInfo.UserID);
    ListItem(FIndex).FPassword := String(LogInfo.Password);
    ListItem(FIndex).FDatabaseName := String(LogInfo.DatabaseName);
    {TableType}
    ListItem(FIndex).FDLLName := String(TableType.DLLName);
    ListItem(FIndex).FDescriptiveName := String(TableType.DescriptiveName);
    case TableType.DBType of
      PE_DT_STANDARD             : ListItem(FIndex).FTableType := ttStandard;
      PE_DT_SQL                  : ListItem(FIndex).FTableType := ttSQL;
      PE_DT_SQL_STORED_PROCEDURE : ListItem(FIndex).FTableType := ttStoredProcedure;
      else
        ListItem(FIndex).FTableType := ttUnknown;
    end;
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end; {RetrieveLogOnInfo}
{------------------------------------------------------------------------------}
{ Test method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.Test : boolean;
var
  LogInfo     : PELogOnInfo;
  nTable      : integer;
  hTextHandle : HWnd;
  nTextLen    : Smallint;
  pErrorText  : PChar;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  StrCopy(LogInfo.ServerName, PChar(ListItem(FIndex).FServerName));
  StrCopy(LogInfo.UserID, PChar(ListItem(FIndex).FUserID));
  StrCopy(LogInfo.Password, PChar(ListItem(FIndex).FPassword));
  StrCopy(LogInfo.DatabaseName, PChar(ListItem(FIndex).FDatabaseName));

  {Get the Table Number}
  nTable := ListItem(FIndex).FTable;

  Cr.SetDLLHandle;
  {Set LogOnInfo}
  if not PESetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo, False) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'LogOnInfo.Test <PESetNthTableLogOnInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  Cr.SetDLLHandle;
  {Test LogOn}
  Result := PETestNthTableConnectivity(Cr.FPrintJob, nTable);

  {If if failed, store the resulting error}
  if Result = False then
  begin
    Cr.SetDLLHandle;
    Cr.FLastErrorNumber := PEGetErrorCode(Cr.FPrintJob);
    {Get ErrorString}
    if not PEGetErrorText(Cr.FPrintJob, hTextHandle, nTextLen) then
      {Failed to Retrieve Error String from Print Engine}
      Cr.FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR)
    else
    begin
      Cr.SetDLLHandle;
      pErrorText := StrAlloc(nTextLen);
      if not PEGetHandleString(hTextHandle, pErrorText, nTextLen) then
      begin
        StrDispose(pErrorText);
        {Failed to Retrieve Error from Print Engine}
        Cr.FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
      end
      else
      begin
        Cr.FLastErrorString := String(pErrorText);
        {Remove the Period if it exists}
        if Pos('.', Cr.FLastErrorString) > 0 then
          Cr.FLastErrorString := Copy(Cr.FLastErrorString, 1,
            Pos('.', Cr.FLastErrorString) - 1);
        StrDispose(pErrorText);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.Send : TCrBoolean;
var
  LogInfo           : PELogOnInfo;
  TableType         : PETableType;
  nTable            : smallint;   {table number}
  nTables           : smallint;
  nIndex            : integer;
  sSN, sUID, sDBN   : string;
  slLogOnInfo       : TStringList;
  slNumbers         : TStringList;
  nRptIndex         : integer;
  nRpt              : integer;
  s1, s2            : string;
  n1, n2            : integer;
  PromptDlg         : TLogOnInfoDlg;
  Changed           : boolean;

  procedure FreeList (var sList: TStringList);
  var
    i     : integer;
    xList : TStringList;
  begin
    try
      for i := 0 to (sList.Count - 1) do
      begin
        xList := TStringList(sList.Objects[i]);
        if xList <> nil then
           xList.Free;
      end;
      sList.Free;
    except
      Exit;
    end;
  end;

begin
  Result := cDefault;
  if (FPromptForLogOn = False) and (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {If Prompt is true}
  if FPromptForLogOn = True then
  begin
    {Allocate memory for Temporary list}
    slLogOnInfo := TStringList.Create;

    {Store the current Rpt Index}
    nRptIndex := Cr.FSubreports.FIndex;
    if nRptIndex = 0 then
    begin
      {Make sure Subreport info is setup}
      if Cr.FSubreports.Count = 1 then
        Cr.FSubreports.Retrieve;
      nIndex := (Cr.FSubreports.Count - 1);
    end
    else
      nIndex := 0;

    {Loop through Reports}
    for nRpt := 0 to nIndex do
    begin
      {If running Main Report, set Report number,
       so we loop through the subreports also}
      if nRptIndex = 0 then
        Cr.FSubreports.SetIndex(nRpt);

      Cr.SetDLLHandle;
      {Get number of tables}
      nTables := PEGetNTables(Cr.FPrintJob);
      if nTables = -1 then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'LogOnInfo.Send <PEGetNTables>') of
          cFalse   : Continue;
          cTrue    : begin
              FreeList(slLogOnInfo);
              Abort;
            end;
          cDefault : begin
              FreeList(slLogOnInfo);
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Loop through the tables}
      for nTable := 0 to (nTables - 1) do
      begin
        Cr.SetDLLHandle;
        if not PEGetNthTableType(Cr.FPrintJob, nTable, TableType) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'LogOnInfo.Send <PEGetNthTableType>') of
            cFalse   : Continue;
            cTrue    : begin
                FreeList(slLogOnInfo);
                Cr.FSubreports.SetIndex(nRptIndex);
                Abort;
              end;
            cDefault : begin
                FreeList(slLogOnInfo);
                Cr.FSubreports.SetIndex(nRptIndex);
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;
        {If SQLTablesOnly then check for SQL table}
        if FSQLTablesOnly and not ((TableType.DBType = PE_DT_SQL) or
           (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE)) then
          Continue;
        Cr.SetDLLHandle;
        if not PEGetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'LogOnInfo.Send <PEGetNthTableLogOnInfo>') of
            cFalse   : Continue;
            cTrue    : begin
                FreeList(slLogOnInfo);
                Cr.FSubreports.SetIndex(nRptIndex);
                Abort;
              end;
            cDefault : begin
                FreeList(slLogOnInfo);
                Cr.FSubreports.SetIndex(nRptIndex);
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;
        {Only take unique LogOn info}
        s1 := String(LogInfo.ServerName) + ';;' +
              String(LogInfo.UserID) + ';;' +
              String(LogInfo.DatabaseName) + ';;' +
              String(LogInfo.Password);
        n1 := slLogOnInfo.IndexOf(s1);
        if n1 = -1 then
        begin
          {Add the string}
          slLogOnInfo.Add(s1);
          {Add a stringlist to the Object to hold Rpt & Table #}
          slLogOnInfo.Objects[slLogOnInfo.Count - 1] := TStringList.Create;
          slNumbers := TStringList(slLogOnInfo.Objects[slLogOnInfo.Count - 1]);
          slNumbers.Add(IntToStr(Cr.FSubreports.ItemIndex) +
            ';;' + IntToStr(nTable));
        end
        {It's not unique but we still store Rpt and Table #}
        else
        begin
          slNumbers := TStringList(slLogOnInfo.Objects[n1]);
          slNumbers.Add(IntToStr(Cr.FSubreports.ItemIndex) +
            ';;' + IntToStr(nTable));
        end;
      end; {for nTable}
    end; {for nReport}

    if slLogOnInfo.Count > 0 then
    begin
      {Show Prompt Dialog}
      PromptDlg := TLogOnInfoDlg.Create(Application);
      PromptDlg.slLogInfo := slLogOnInfo;
      PromptDlg.ShowModal;
      if PromptDlg.ModalResult = mrOk then
      begin
        {Loop through slLogOnInfo items}
        for n1 := 0 to (slLogOnInfo.Count - 1) do
        begin
          {Clear LogInfo}
          StrCopy(LogInfo.ServerName, '');
          StrCopy(LogInfo.UserID, '');
          StrCopy(LogInfo.Password, '');
          StrCopy(LogInfo.DatabaseName, '');
          {Copy the LogOnInfo string}
          s1 := slLogOnInfo[n1];
          {Extract ServerName}
          s2 := GetToken(s1, ';;');
          StrCopy(LogInfo.ServerName, PChar(s2));
          {Extract UserID}
          s2 := GetToken(s1, ';;');
          StrCopy(LogInfo.UserID, PChar(s2));
          {Extract DatabaseName}
          s2 := GetToken(s1, ';;');
          StrCopy(LogInfo.DatabaseName, PChar(s2));
          {Get Password}
          StrCopy(LogInfo.Password, PChar(s1));
          {Apply LogOn to each table that needs it}
          slNumbers := TStringList(slLogOnInfo.Objects[n1]);
          for n2 := 0 to (slNumbers.Count - 1) do
          begin
            {Set Report number}
            s1 := slNumbers[n2];
            s2 := GetToken(s1, ';;');
            nRpt := StrToInt(s2);
            Cr.FSubreports.SetIndex(nRpt);
            {Set the Table Number}
            nTable := StrToInt(s1);
            Cr.SetDLLHandle;
            {Set the LogOnInfo}
            if not PESetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo, False) then
            begin
              Result := cFalse;
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                   'LogOnInfo.Send <PESetNthTableLogOnInfo>') of
                cFalse   : Continue;
                cTrue    : begin
                    FreeList(slLogOnInfo);
                    Cr.FSubreports.SetIndex(nRptIndex);
                    Abort;
                  end;
                cDefault : begin
                    FreeList(slLogOnInfo);
                    Cr.FSubreports.SetIndex(nRptIndex);
                    raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                  end;
              end;
            end;
            Result := cTrue;
          end; {for slNumbers}
        end; {for slLogOnInfo}
      end {if PromptDialog OK}
      else
        Result := cFalse;
    end; {if slLogOnInfo.Count}
    FreeList(slLogOnInfo);
    {Restore Rpt index}
    Cr.FSubreports.SetIndex(nRptIndex);
    Exit;
  end;

  {Loop through the LogOnInfo items}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    Cr.SetDLLHandle;
    {Get number of tables}
    nTables := PEGetNTables(Cr.FPrintJob);
    if nTables = -1 then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'LogOnInfo.Send <PEGetNTables>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get the Table Number}
    nTable := ListItem(nIndex).FTable;

    {If the Table Number is out of range, raise error}
    if nTable > (nTables - 1) then
    begin
      Result := cDefault;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_BAD_LOGON_TABLENUM,
        'LogOnInfo.Send <Table: ' + IntToStr(nIndex) + ' >') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    Cr.SetDLLHandle;
    {Get the LogOnInfo from the Report}
    if not PEGetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo) then
    begin
      Result := cDefault;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'LogOnInfo.Send <PEGetNthTableLogOnInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {ServerName}
    sSN := String(LogInfo.ServerName);
    if CompareStr(sSN, ListItem(nIndex).FServerName) <> 0 then
    begin
      if ListItem(nIndex).FServerName <> '' then
        StrCopy(LogInfo.ServerName, PChar(ListItem(nIndex).FServerName));
      Changed := True;
    end;

    {UserID}
    sUID := String(LogInfo.UserID);
    if CompareStr(sUID, ListItem(nIndex).FUserID) <> 0 then
    begin
      if ListItem(nIndex).FUserID <> '' then
        StrCopy(LogInfo.UserID, PChar(ListItem(nIndex).FUserID));
      Changed := True;
    end;

    {Password}
    if ListItem(nIndex).FPassword <> '' then
    begin
      StrCopy(LogInfo.Password, PChar(ListItem(nIndex).FPassword));
      Changed := True;
    end;

    {DatabaseName}
    sDBN := String(LogInfo.DatabaseName);
    if CompareStr(sDBN, ListItem(nIndex).FDatabaseName) <> 0 then
    begin
      if ListItem(nIndex).FDatabaseName <> '' then
        StrCopy(LogInfo.DatabaseName, PChar(ListItem(nIndex).FDatabaseName));
      Changed := True;
    end;

    {Send the LogOnInfo to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo, False) then
      begin
        Result := cDefault;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'LogOnInfo.Send <PESetNthTableLogOnInfo>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := cTrue;
    end; { if }
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read method GetTable                                                         }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetTable : TCrLogOnInfoTable;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTable;
end;
{------------------------------------------------------------------------------}
{ Write method SetTable                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetTable(const Value: TCrLogOnInfoTable);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
      'LogOnInfo.Table := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetServerName                                                    }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetServerName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FServerName;
end;
{------------------------------------------------------------------------------}
{ Write method SetServerName                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetServerName(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FServerName := Value;
    {Check Length}
    if Length(ListItem(FIndex).FServerName) > PE_SERVERNAME_LEN then
      ListItem(FIndex).FServerName := Copy(ListItem(FIndex).FServerName, 1, PE_SERVERNAME_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetUserID                                                        }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetUserID : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUserID;
end;
{------------------------------------------------------------------------------}
{ Write method SetUserID                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetUserID(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FUserID := Value;
    {Check Length}
    if Length(ListItem(FIndex).FUserID) > PE_USERID_LEN then
      ListItem(FIndex).FUserID := Copy(ListItem(FIndex).FUserID, 1, PE_USERID_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetPassword                                                      }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetPassword : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPassword;
end;
{------------------------------------------------------------------------------}
{ Write method SetPassword                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetPassword(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FPassword := Value;
    {Check Length}
    if Length(ListItem(FIndex).FPassword) > PE_PASSWORD_LEN then
      ListItem(FIndex).FPassword := Copy(ListItem(FIndex).FPassword, 1, PE_PASSWORD_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetDatabaseName                                                  }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetDatabaseName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDatabaseName;
end;
{------------------------------------------------------------------------------}
{ Write method SetDatabaseName                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetDatabaseName(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FDatabaseName := Value;
    {Check Length}
    if Length(ListItem(FIndex).FDatabaseName) > PE_DATABASENAME_LEN then
      ListItem(FIndex).FDatabaseName := Copy(ListItem(FIndex).FDatabaseName, 1, PE_DATABASENAME_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetDLLName                                                       }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetDLLName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDLLName;
end;
{------------------------------------------------------------------------------}
{ Read method GetDescriptiveName                                               }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetDescriptiveName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDescriptiveName;
end;
{------------------------------------------------------------------------------}
{ Read method GetTableType                                                     }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetTableType : TCrTableType;
begin
  Result := ttUnknown;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTableType;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'LogOnInfo[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItem method                                                               }
{   - This is the default property and can be also set                         }
{      via Crpe1.LogOnInfo[nIndex]                                             }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetItem(nIndex: integer): TCrpeLogOnInfo;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeTablesItem                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeTablesItem.Create;
begin
  inherited Create;
  FNumber          := -1;
  FName            := '';
  FPath            := '';
  FSubName         := '';
  FConnectBuffer   := '';
  FPassword        := '';
  {TableType}
  FTableType       := ttUnknown;
  FDLLName         := '';
  FDescriptiveName := '';
  {PrivateInfo}
  FBytes           := 0;
  FTag             := 0;
  FDataPointer     := nil;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeTablesItem.Destroy;
begin
  FDataPointer := nil;
  inherited Destroy;
end;

{******************************************************************************}
{ Class TCrpeTables                                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeTables.Create;
begin
  inherited Create;
  FList := TList.Create;
  FPropagate := False;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeTables.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeTables.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FPropagate := False;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ CopyFrom method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeTables.CopyFrom (Source: TCrpeTables);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FName := Source[cnt].Name;
    ListItem(cnt).FPath := Source[cnt].Path;
    ListItem(cnt).FSubName := Source[cnt].SubName;
    ListItem(cnt).FConnectBuffer := Source[cnt].ConnectBuffer;
    ListItem(cnt).FPassword := Source[cnt].Password;
    ListItem(cnt).FTableType := Source[cnt].TableType;
    ListItem(cnt).FDLLName := Source[cnt].DLLName;
    ListItem(cnt).FDescriptiveName := Source[cnt].DescriptiveName;
    ListItem(cnt).FBytes := Source[cnt].Bytes;
    ListItem(cnt).FTag := Source[cnt].Tag;
    ListItem(cnt).FDataPointer := Source[cnt].DataPointer;
  end;
  FPropagate := Source.FPropagate;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeTables.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeTables.Add(TableNumber: TCrTableNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(TableNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
      'Tables <' + IntToStr(TableNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeTablesItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := TableNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeTables.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'Tables.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeTables.IndexOf(TableNumber : TCrTableNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = TableNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ IndexOfName method                                                           }
{------------------------------------------------------------------------------}
function TCrpeTables.IndexOfName (TableName: string): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FName, TableName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeTables.ListItem(nIndex: integer): TCrpeTablesItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeTables.Retrieve : boolean;
var
  TableLoc    : PETableLocation;
  TableType   : PETableType;
  PrivateInfo : PETablePrivateInfo;
  nIndex      : Smallint;
  nTables     : Smallint;
  bProp       : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the Tables object but keep Propagate setting}
  bProp := FPropagate;
  Clear;
  FPropagate := bProp;

  Cr.SetDLLHandle;
  {Get number of tables}
  nTables := PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.Retrieve <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    Cr.SetDLLHandle;
    {Get table location}
    if not PEGetNthTableLocation(Cr.FPrintJob, nIndex, TableLoc) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables.Retrieve <PEGetNthTableLocation>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Add(nIndex);
    ListItem(FIndex).FName := ExtractFileName(String(TableLoc.Location));
    ListItem(FIndex).FPath := ExtractFilePath(String(TableLoc.Location));
    ListItem(FIndex).FPassword := '';   {obviously we can't retrieve a password!}
    {SCR7+ only}
    if Cr.FVersion.FMajor > 6 then
    begin
      ListItem(FIndex).FSubName := String(TableLoc.SubLocation);
      ListItem(FIndex).FConnectBuffer := String(TableLoc.ConnectBuffer);
    end;

    Cr.SetDLLHandle;
    {Get TableType}
    if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables.Retrieve <PEGetNthTableType>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    case TableType.DBType of
      PE_DT_STANDARD             : ListItem(FIndex).FTableType := ttStandard;
      PE_DT_SQL	                 : ListItem(FIndex).FTableType := ttSQL;
      PE_DT_SQL_STORED_PROCEDURE : ListItem(FIndex).FTableType := ttStoredProcedure;
      else
        ListItem(FIndex).FTableType := ttUnknown;
    end;
    ListItem(FIndex).FDLLName := String(TableType.DLLName);
    ListItem(FIndex).FDescriptiveName := String(TableType.DescriptiveName);

    {Get PrivateInfo}
    if Cr.FVersion.FMajor > 5 then
    begin
      if CompareText(ListItem(FIndex).FDLLName,'pdsmon.dll') = 0 then
      begin
        Cr.SetDLLHandle;
        if not PEGetNthTablePrivateInfo(Cr.FPrintJob, nIndex, PrivateInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Tables.Retrieve <PEGetNthTablePrivateInfo>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        ListItem(FIndex).FBytes := PrivateInfo.nBytes;
        ListItem(FIndex).FTag := PrivateInfo.tag;
      end;
    end;
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeTables.Send : boolean;
var
  TableLoc      : PETableLocation;
  LogInfo       : PELogOnInfo;
  PrivateInfo   : PETablePrivateInfo;
  nTables       : smallint;
  nIndex        : smallint;
  nTable        : smallint;
  sFile, sLoc   : string;
  sFile2, sLoc2 : string;
  sTmp          : string;
  sTmp2         : string;
  bProp         : boolean;
  Changed       : boolean;
begin
  Result := False;
  {Check Propagate property}
  bProp := False;
  if (FPropagate = True) or (Cr.FSubreports.ListItem(0).FTables.FPropagate = True) then
    bProp := True;
  {If there are no Tables set, and Propagate is not set, Exit}
  if (Count = 0) and (bProp = False) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  Cr.SetDLLHandle;
  {Get the number of Tables}
  nTables := PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.Send <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {If Propagate is True, take the Table Path
   from the first table in the main report}
  if bProp then
  begin
    {Get Path from first table of Main report}
    sLoc := '';
    if (Cr.FSubreports.ListItem(0).FTables.Count > 0) then
      sLoc := Trim(Cr.FSubreports.ListItem(0).FTables.ListItem(0).FPath);

    {Loop through all the tables}
    for nTable := 0 to (nTables - 1) do
    begin
      Changed := False;
      Cr.SetDLLHandle;
      {Get the table location from the Report}
      if not PEGetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Tables.Send <PEGetNthTableLocation>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      sTmp2 := String(TableLoc.Location);
      sFile2 := ExtractFileName(String(TableLoc.Location));
      sLoc2 := ExtractFilePath(String(TableLoc.Location));

      {Locate the Table Number in the Table object list}
      nIndex := IndexOf(nTable);
      {If the Table item isn't in the VCL, use Table Name from Report}
      if (nIndex = -1) then
        sFile := sFile2
      {If Table has been set in VCL, retrieve the Name}
      else
      begin
        sFile := ListItem(nIndex).FName;
        {If the Table Name is blank, use Table Name from Report}
        if sFile = '' then
          sFile := sFile2;

        {If Password property was set, call LogOnInfo}
        if ListItem(nIndex).FPassword <> '' then
        begin
          Cr.SetDLLHandle;
          StrCopy(LogInfo.ServerName, '');
          StrCopy(LogInfo.DatabaseName, '');
          StrCopy(LogInfo.UserID, '');
          StrCopy(LogInfo.Password, PChar(ListItem(nIndex).FPassword));
          if not PESetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo, False) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'Tables.Send <PESetNthTableLogOnInfo>') of
              cFalse   : Continue;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end;
        end;
      end;

      {Check the Path}
      if Length(sLoc) > 0 then
      begin
        {Convert Paths with BDE Aliases to directories}
        if sLoc[1] = ':' then
        begin
          if not GetPathFromAlias(sLoc, sLoc) then
          begin
            case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
                'Tables.Send <GetPathFromAlias>') of
              cFalse   : Continue;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end;
        end;
        {Add trailing backslash if needed; trim spaces}
        sLoc := AddBackSlash(sLoc);
      end
      {If Table[0] Path is invalid, use the current Table item path}
      else
        sLoc := sLoc2;

      {Join the Name & Path}
      sTmp := sLoc + sFile;
      {Check Length}
      if Length(sTmp) > PE_TABLE_LOCATION_LEN then
        sTmp := Copy(sTmp, 1, PE_TABLE_LOCATION_LEN);

      {Compare the new Table location/name}
      if CompareText(sTmp, sTmp2) <> 0 then
      begin
        StrCopy(TableLoc.Location, PChar(sTmp));
        Changed := True;
      end;

      {SCR 7 Features}
      if Cr.FVersion.FMajor > 6 then
      begin
        if nIndex > -1 then
        begin
          {Compare the SubName}
          sTmp := string(TableLoc.SubLocation);
          if CompareText(sTmp, ListItem(nIndex).FSubName) <> 0 then
          begin
            StrCopy(TableLoc.SubLocation, PChar(ListItem(nIndex).FSubName));
            Changed := True;
          end;

          {Compare the ConnectBuffer}
          sTmp := string(TableLoc.ConnectBuffer);
          if CompareText(sTmp, ListItem(nIndex).FConnectBuffer) <> 0 then
          begin
            StrCopy(TableLoc.ConnectBuffer, PChar(ListItem(nIndex).FConnectBuffer));
            Changed := True;
          end;
        end;
      end;

      if Changed then
      begin
        Cr.SetDLLHandle;
        if not PESetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Tables.Send <PESetNthTableLocation>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;

      {PrivateInfo}
      if (Cr.FVersion.FMajor > 5) and (nIndex > -1) then
      begin
        if ListItem(nIndex).FDataPointer <> nil then
        begin
          if ListItem(nIndex).FBytes = 0 then
          begin
            Cr.SetDLLHandle;
            {Get PrivateInfo}
            if not PEGetNthTablePrivateInfo(Cr.FPrintJob, nTable, PrivateInfo) then
            begin
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                  'Tables.Send <PEGetNthTablePrivateInfo>') of
                cFalse   : Continue;
                cTrue    : Abort;
                cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
            ListItem(nIndex).FBytes := PrivateInfo.nBytes;
          end;
          PrivateInfo.nBytes := ListItem(nIndex).FBytes;
          PrivateInfo.tag := 3; {ListItem(nIndex).FTag;} {3 is the only option for now}
          PrivateInfo.dataPtr := ListItem(nIndex).FDataPointer;
          Cr.SetDLLHandle;
          {Set PrivateInfo}
          if not PESetNthTablePrivateInfo(Cr.FPrintJob, nTable, PrivateInfo) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'Tables.Send <PESetNthTablePrivateInfo>') of
              cFalse   : Continue;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end;
        end;
      end;
    end;
  end
  {No Propagate}
  else
  begin
    {Loop through the items}
    for nIndex := 0 to (Count - 1) do
    begin
      Changed := False;
      {Get the Table Number}
      nTable := ListItem(nIndex).FNumber;

      {If the Table Number is out of range, raise error}
      if nTable > (nTables - 1) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_BAD_TABLE_NUMBER,
          'Tables[' + IntToStr(nIndex) + '] = ' + IntToStr(nTable)) of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Get the Table Information}
      sFile := Trim(ListItem(nIndex).FName);
      sLoc := Trim(ListItem(nIndex).FPath);

      Cr.SetDLLHandle;
      {Get the Table Location from the Report}
      if not PEGetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Tables.Send <PEGetNthTableLocation>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      sTmp2 := String(TableLoc.Location);
      sFile2 := ExtractFileName(String(TableLoc.Location));
      sLoc2 := ExtractFilePath(String(TableLoc.Location));

      {If the Table Name is blank, use Table Name from Report}
      if sFile = '' then
        sFile := sFile2;

      {Check the Path}
      if Length(sLoc) > 0 then
      begin
        {Convert Paths with BDE Aliases to directories}
        if sLoc[1] = ':' then
        begin
          if not GetPathFromAlias(sLoc, sLoc) then
          begin
            case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
                'Tables.Send <GetPathFromAlias>') of
              cFalse   : Continue;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end;
        end;
        {Add trailing backslash if needed; trim spaces}
        sLoc := AddBackSlash(sLoc);
      end
      else
        sLoc := sLoc2;

      {Join the Name & Path}
      sTmp := sLoc + sFile;
      {Check Length}
      if Length(sTmp) > PE_TABLE_LOCATION_LEN then
        sTmp := Copy(sTmp, 1, PE_TABLE_LOCATION_LEN);

      {Send in the new Table location/name}
      if CompareText(sTmp, sTmp2) <> 0 then
      begin
        StrCopy(TableLoc.Location, PChar(sTmp));
        Changed := True;
      end;

      {SCR 7 features}
      if Cr.FVersion.FMajor > 6 then
      begin
        {Compare the SubName}
        sTmp := string(TableLoc.SubLocation);
        if CompareText(sTmp, ListItem(nIndex).FSubName) <> 0 then
        begin
          StrCopy(TableLoc.SubLocation, PChar(ListItem(nIndex).FSubName));
          Changed := True;
        end;

        {Compare the ConnectBuffer}
        sTmp := string(TableLoc.ConnectBuffer);
        if CompareText(sTmp, ListItem(nIndex).FConnectBuffer) <> 0 then
        begin
          StrCopy(TableLoc.ConnectBuffer, PChar(ListItem(nIndex).FConnectBuffer));
          Changed := True;
        end;
      end;

      if Changed then
      begin
        Cr.SetDLLHandle;
        if not PESetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Tables.Send <PESetNthTableLocation>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;

      {If Password property was set, call LogOnInfo}
      if ListItem(nIndex).FPassword <> '' then
      begin
        Cr.SetDLLHandle;
        StrCopy(LogInfo.ServerName, '');
        StrCopy(LogInfo.DatabaseName, '');
        StrCopy(LogInfo.UserID, '');
        StrCopy(LogInfo.Password, PChar(ListItem(nIndex).FPassword));
        if not PESetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo, False) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Tables.Send <PESetNthTableLogOnInfo>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;

      {PrivateInfo}
      if Cr.FVersion.FMajor > 5 then
      begin
        if ListItem(nIndex).FDataPointer <> nil then
        begin
          if ListItem(nIndex).FBytes = 0 then
          begin
            Cr.SetDLLHandle;
            {Get PrivateInfo}
            if not PEGetNthTablePrivateInfo(Cr.FPrintJob, nTable, PrivateInfo) then
            begin
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                  'Tables.Send <PEGetNthTablePrivateInfo>') of
                cFalse   : Continue;
                cTrue    : Abort;
                cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
            ListItem(nIndex).FBytes := PrivateInfo.nBytes;
          end;
          Cr.SetDLLHandle;
          PrivateInfo.nBytes := ListItem(nIndex).FBytes;
          PrivateInfo.tag := 3; {ListItem(nIndex).FTag;} {3 is the only option for now}
          PrivateInfo.dataPtr := ListItem(nIndex).FDataPointer;
          {Set PrivateInfo}
          if not PESetNthTablePrivateInfo(Cr.FPrintJob, nTable, PrivateInfo) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'Tables.Send <PESetNthTablePrivateInfo>') of
              cFalse   : Continue;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end;
        end; {if DataPointer <> nil}
      end; {if Version > 5}
    end; {for nIndex}
  end; {else}
end; { Send }
{------------------------------------------------------------------------------}
{ Test method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeTables.Test : boolean;
var
  TableLoc    : PETableLocation;
  nTable      : integer;
  bProp       : boolean;
  sName1      : string;
  sPath1      : string;
  sLoc2       : string;
  sName2      : string;
  sPath2      : string;
  hTextHandle : HWnd;
  nTextLen    : Smallint;
  pErrorText  : PChar;
begin
  Result := False;
  {Check Propagate property}
  bProp := False;
  if (FPropagate = True) or (Cr.FSubreports.ListItem(0).FTables.FPropagate = True) then
    bProp := True;
  {If there are no Tables set, and Propagate is not set, Exit}
  if (Count = 0) and (bProp = False) then
    Exit;
  {Check that PrintJob is open}
  if not Cr.OpenPrintJob then
    Exit;

  {Get the current Table Number}
  nTable := ListItem(FIndex).FNumber;

  Cr.SetDLLHandle;
  {Get the Table Location from the Report}
  if not PEGetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.Test <PEGetNthTableLocation>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sName1 := ExtractFileName(String(TableLoc.Location));
  sPath1 := ExtractFilePath(String(TableLoc.Location));

  {If Propagate is True, take the Table Path
   from the first table in the main report}
  if bProp then
  begin
    {Get Path from first table of Main report}
    sPath2 := sPath1;
    if (Cr.FSubreports.ListItem(0).FTables.Count > 0) then
      sPath2 := Trim(Cr.FSubreports.ListItem(0).FTables.ListItem(0).FPath);

    {If the Table Name is blank, use Table Name from Report}
    if ListItem(FIndex).FName = '' then
      sName2 := sName1
    {If Table has been set in VCL, retrieve the Name}
    else
      sName2 := ListItem(FIndex).FName;

    {Check the Path}
    if Length(sPath2) > 0 then
    begin
      {Convert Paths with BDE Aliases to directories}
      if sPath2[1] = ':' then
      begin
        if not GetPathFromAlias(sPath2, sPath2) then
        begin
          case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
              'Tables.Test <GetPathFromAlias>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
      end;
      {Add trailing backslash if needed}
      sPath2 := AddBackSlash(sPath2);
    end;

    {Join the Name & Path}
    sLoc2 := sPath2 + sName2;
    {Check Length}
    if Length(sLoc2) > PE_TABLE_LOCATION_LEN then
      sLoc2 := Copy(sLoc2, 1, PE_TABLE_LOCATION_LEN);
  end
  {No Propagate}
  else
  begin
    {If the Table Name is blank, use Table Name from Report}
    if ListItem(FIndex).FName = '' then
      sName2 := sName1
    {If Table has been set in VCL, retrieve the Name}
    else
      sName2 := Trim(ListItem(FIndex).FName);

    {Table Path}
    sPath2 := Trim(ListItem(FIndex).FPath);
    {If Path is not blank...}
    if Length(sPath2) > 0 then
    begin
      {Convert Paths with BDE Aliases to directories}
      if sPath2[1] = ':' then
      begin
        if not GetPathFromAlias(sPath2, sPath2) then
        begin
          case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
              'Tables.Test <GetPathFromAlias>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
      end;
      {Add trailing backslash if needed}
      sPath2 := AddBackSlash(sPath2);
    end
    {else use Report Path}
    else
      sPath2 := sPath1;

    {Join the Name & Path}
    sLoc2 := sPath2 + sName2;
    {Check Length}
    if Length(sLoc2) > PE_TABLE_LOCATION_LEN then
      sLoc2 := Copy(sLoc2, 1, PE_TABLE_LOCATION_LEN);
  end;
  {Location}
  StrCopy(TableLoc.Location, PChar(sLoc2));
  {SubName}
  StrCopy(TableLoc.SubLocation, PChar(ListItem(FIndex).FSubName));
  {ConnectBuffer}
  StrCopy(TableLoc.ConnectBuffer, PChar(ListItem(FIndex).FConnectBuffer));

  Cr.SetDLLHandle;
  {Set the Table Location}
  if not PESetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.Test <PESetNthTableLocation>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
(*
  PE_ERR_DATABASESESSION  = 535;
  PE_ERR_DATABASELOGON    = 536;
  PE_ERR_DATABASELOCATION = 537;
*)
  Cr.SetDLLHandle;
  {Test Connectivity}
  Result := PETestNthTableConnectivity(Cr.FPrintJob, nTable);

  {If if failed, store the resulting error}
  if Result = False then
  begin
    Cr.SetDLLHandle;
    Cr.FLastErrorNumber := PEGetErrorCode(Cr.FPrintJob);
    {Get ErrorString}
    if not PEGetErrorText(Cr.FPrintJob, hTextHandle, nTextLen) then
      {Failed to Retrieve Error String from Print Engine}
      Cr.FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR)
    else
    begin
      Cr.SetDLLHandle;
      pErrorText := StrAlloc(nTextLen);
      if not PEGetHandleString(hTextHandle, pErrorText, nTextLen) then
      begin
        StrDispose(pErrorText);
        {Failed to Retrieve Error from Print Engine}
        Cr.FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
      end
      else
      begin
        Cr.FLastErrorString := String(pErrorText);
        {Remove the Period if it exists}
        if Pos('.', Cr.FLastErrorString) > 0 then
          Cr.FLastErrorString := Copy(Cr.FLastErrorString, 1,
            Pos('.', Cr.FLastErrorString) - 1);
        StrDispose(pErrorText);
      end;
    end; {if not PEGetErrorText}
  end; {if Result = False}
end;
{------------------------------------------------------------------------------}
{ Check method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeTables.CheckDifferences(var DifNums: TStringList;
  var DifStrings: TStringList): boolean;
const
  PEDiff : array[0..23] of integer = (PE_TCD_OKAY, PE_TCD_DATABASENOTFOUND,
    PE_TCD_SERVERNOTFOUND, PE_TCD_SERVERNOTOPENED, PE_TCD_ALIASCHANGED,
    PE_TCD_INDEXESCHANGED, PE_TCD_DRIVERCHANGED, PE_TCD_DICTIONARYCHANGED,
    PE_TCD_FILETYPECHANGED, PE_TCD_RECORDSIZECHANGED, PE_TCD_ACCESSCHANGED,
    PE_TCD_PARAMETERSCHANGED, PE_TCD_LOCATIONCHANGED, PE_TCD_DATABASEOTHER,
    PE_TCD_NUMFIELDSCHANGED, PE_TCD_FIELDOTHER, PE_TCD_FIELDNAMECHANGED,
    PE_TCD_FIELDDESCCHANGED, PE_TCD_FIELDTYPECHANGED, PE_TCD_FIELDSIZECHANGED,
    PE_TCD_NATIVEFIELDTYPECHANGED, PE_TCD_NATIVEFIELDOFFSETCHANGED,
    PE_TCD_NATIVEFIELDSIZECHANGED, PE_TCD_FIELDDECPLACESCHANGED);
  TCDiff : array[0..23] of string = ('1000:Okay', '1001:Database Not Found',
    '1002:Server Not Found', '1003:Server Not Opened', '1004:Alias Changed',
    '1005:Indexes Changed', '1006:Driver Changed', '1007:Dictionary Changed',
    '1008:File Type Changed', '1009:Record Size Changed', '1010:Access Changed',
    '1011:Parameters Changed', '1012:Location Changed', '1013:Database Other',
    '1014:Number of Fields Changed', '1015:Field Other', '1016:Field Name Changed',
    '1017:Field Description Changed', '1018:Field Type Changed', '1019:Field Size Changed',
    '1020:Native Field Type Changed', '1021:Native Field Offset Changed',
    '1022:Native Field Size Changed', '1023:Field Decimal Places Changed');
var
  TableDifInfo : PETableDifferenceInfo;
  i            : integer;
  nDif         : integer;
  nTable       : integer;
  TableLoc     : PETableLocation;
  bProp        : boolean;
  sName1       : string;
  sPath1       : string;
  sLoc2        : string;
  sName2       : string;
  sPath2       : string;
begin
  Result := False;
  {Requires SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  {Check Propagate property}
  bProp := False;
  if (FPropagate = True) or (Cr.FSubreports.ListItem(0).FTables.FPropagate = True) then
    bProp := True;
  {If there are no Tables set, and Propagate is not set, Exit}
  if (Count = 0) and (bProp = False) then
    Exit;
  {Check that PrintJob is open}
  if not Cr.OpenPrintJob then
    Exit;

  {Get Table Number}
  nTable := ListItem(FIndex).FNumber;

  Cr.SetDLLHandle;
  {Get the Table Location from the Report}
  if not PEGetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.CheckDifferences <PEGetNthTableLocation>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sName1 := ExtractFileName(String(TableLoc.Location));
  sPath1 := ExtractFilePath(String(TableLoc.Location));

  {If Propagate is True, take the Table Path
   from the first table in the main report}
  if bProp then
  begin
    {Get Path from first table of Main report}
    sPath2 := sPath1;
    if (Cr.FSubreports.ListItem(0).FTables.Count > 0) then
      sPath2 := Trim(Cr.FSubreports.ListItem(0).FTables.ListItem(0).FPath);

    {If the Table Name is blank, use Table Name from Report}
    if ListItem(FIndex).FName = '' then
      sName2 := sName1
    {If Table has been set in VCL, retrieve the Name}
    else
      sName2 := ListItem(FIndex).FName;

    {Check the Path}
    if Length(sPath2) > 0 then
    begin
      {Convert Paths with BDE Aliases to directories}
      if sPath2[1] = ':' then
      begin
        if not GetPathFromAlias(sPath2, sPath2) then
        begin
          case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
              'Tables.CheckDifferences <GetPathFromAlias>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
      end;
      {Add trailing backslash if needed}
      sPath2 := AddBackSlash(sPath2);
    end;

    {Join the Name & Path}
    sLoc2 := sPath2 + sName2;
    {Check Length}
    if Length(sLoc2) > PE_TABLE_LOCATION_LEN then
      sLoc2 := Copy(sLoc2, 1, PE_TABLE_LOCATION_LEN);
  end
  {No Propagate}
  else
  begin
    {If the Table Name is blank, use Table Name from Report}
    if ListItem(FIndex).FName = '' then
      sName2 := sName1
    {If Table has been set in VCL, retrieve the Name}
    else
      sName2 := Trim(ListItem(FIndex).FName);

    {Table Path}
    sPath2 := Trim(ListItem(FIndex).FPath);
    {If Path is not blank...}
    if Length(sPath2) > 0 then
    begin
      {Convert Paths with BDE Aliases to directories}
      if sPath2[1] = ':' then
      begin
        if not GetPathFromAlias(sPath2, sPath2) then
        begin
          case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
              'Tables.CheckDifferences <GetPathFromAlias>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
      end;
      {Add trailing backslash if needed}
      sPath2 := AddBackSlash(sPath2);
    end
    {else use Report Path}
    else
      sPath2 := sPath1;

    {Join the Name & Path}
    sLoc2 := sPath2 + sName2;
    {Check Length}
    if Length(sLoc2) > PE_TABLE_LOCATION_LEN then
      sLoc2 := Copy(sLoc2, 1, PE_TABLE_LOCATION_LEN);
  end;
  {Location}
  StrCopy(TableLoc.Location, PChar(sLoc2));
  {SubName}
  StrCopy(TableLoc.SubLocation, PChar(ListItem(FIndex).FSubName));
  {ConnectBuffer}
  StrCopy(TableLoc.ConnectBuffer, PChar(ListItem(FIndex).FConnectBuffer));

  Cr.SetDLLHandle;
  {Set the Table Location}
  if not PESetNthTableLocation(Cr.FPrintJob, nTable, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'Tables.CheckDifferences <PESetNthTableLocation>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  Cr.SetDLLHandle;
  {Check Differences}
  if not PECheckNthTableDifferences(Cr.FPrintJob, nTable, TableDifInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.CheckDifferences <PECheckNthTableDifferences>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Extract the Differences from the returned Number}
  nDif := TableDifInfo.tableDifferences;
  for i := High(PEDiff) downto Low(PEDiff) do
  begin
    if nDif - PEDiff[i] > 0 then
    begin
      nDif := nDif - PEDiff[i];
      DifNums.Add(IntToStr(GetErrorNum(TCDiff[i])));
      DifStrings.Add(GetErrorStr(TCDiff[i]));
    end
    else if nDif - PEDiff[i] = 0 then
    begin
      DifNums.Add(IntToStr(GetErrorNum(TCDiff[i])));
      DifStrings.Add(GetErrorStr(TCDiff[i]));
      Break;
    end
    else
      Continue;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Read method GetNumber                                                        }
{------------------------------------------------------------------------------}
function TCrpeTables.GetNumber : TCrTableNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write method SetNumber                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetNumber(const Value: TCrTableNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
      'Tables.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetName                                                          }
{------------------------------------------------------------------------------}
function TCrpeTables.GetName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write method SetName                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetName(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FName := Value;
    {Check Length}
    if Length(ListItem(FIndex).FName) > PE_TABLE_LOCATION_LEN then
      ListItem(FIndex).FName := Copy(ListItem(FIndex).FName, 1, PE_TABLE_LOCATION_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetPath                                                          }
{------------------------------------------------------------------------------}
function TCrpeTables.GetPath : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPath;
end;
{------------------------------------------------------------------------------}
{ Write method SetPath                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetPath (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FPath := Value;
    {Check Length}
    if Length(ListItem(FIndex).FPath) > PE_TABLE_LOCATION_LEN then
      ListItem(FIndex).FPath := Copy(ListItem(FIndex).FPath, 1, PE_TABLE_LOCATION_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetSubName                                                       }
{------------------------------------------------------------------------------}
function TCrpeTables.GetSubName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSubName;
end;
{------------------------------------------------------------------------------}
{ Write method SetSubName                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetSubName (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FSubName := Value;
    {Check Length}
    if Length(ListItem(FIndex).FSubName) > PE_TABLE_LOCATION_LEN then
      ListItem(FIndex).FSubName := Copy(ListItem(FIndex).FSubName, 1, PE_TABLE_LOCATION_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetConnectBuffer                                                 }
{------------------------------------------------------------------------------}
function TCrpeTables.GetConnectBuffer : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FConnectBuffer;
end;
{------------------------------------------------------------------------------}
{ Write method SetConnectBuffer                                                }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetConnectBuffer (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FConnectBuffer := Value;
    {Check Length}
    if Length(ListItem(FIndex).FConnectBuffer) > PE_CONNECTION_BUFFER_LEN then
      ListItem(FIndex).FConnectBuffer :=
        Copy(ListItem(FIndex).FConnectBuffer, 1, PE_CONNECTION_BUFFER_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetPassword                                                      }
{------------------------------------------------------------------------------}
function TCrpeTables.GetPassword : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPassword;
end;
{------------------------------------------------------------------------------}
{ Write method SetPassword                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetPassword (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FPassword := Value;
    {Check Length}
    if Length(ListItem(FIndex).FPassword) > PE_PASSWORD_LEN then
      ListItem(FIndex).FPassword := Copy(ListItem(FIndex).FPassword, 1, PE_PASSWORD_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetTableType                                                     }
{------------------------------------------------------------------------------}
function TCrpeTables.GetTableType : TCrTableType;
begin
  Result := ttUnknown;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTableType;
end;
{------------------------------------------------------------------------------}
{ Read method GetDLLName                                                       }
{------------------------------------------------------------------------------}
function TCrpeTables.GetDLLName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDLLName;
end;
{------------------------------------------------------------------------------}
{ Read method GetDescriptiveName                                               }
{------------------------------------------------------------------------------}
function TCrpeTables.GetDescriptiveName : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDescriptiveName;
end;
{------------------------------------------------------------------------------}
{ Read method GetBytes                                                         }
{------------------------------------------------------------------------------}
function TCrpeTables.GetBytes : smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FBytes;
end;
{------------------------------------------------------------------------------}
{ Write method SetBytes                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetBytes (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FBytes := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetTag                                                           }
{------------------------------------------------------------------------------}
function TCrpeTables.GetTag : DWord;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTag;
end;
{------------------------------------------------------------------------------}
{ Write method SetTag                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetTag (const Value: DWord);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FTag := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetDataPointer                                                   }
{------------------------------------------------------------------------------}
function TCrpeTables.GetDataPointer : Pointer;
begin
  Result := nil;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataPointer;
end;
{------------------------------------------------------------------------------}
{ Write method SetDataPointer                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetDataPointer (const Value: Pointer);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataPointer := Value;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'Tables[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.Tables[nIndex]                                                }
{------------------------------------------------------------------------------}
function TCrpeTables.GetItem(const nIndex: integer): TCrpeTables;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSQL                                                               }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSQL.Create;
begin
  inherited Create;
  sQuery := TCrpeString.Create;
  FParams := TCrpeStoredProcParams.Create;
  FExpressions := TCrpeSQLExpressions.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSQL.Destroy;
begin
  sQuery.Free;
  FParams.Free;
  FExpressions.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.Clear;
begin
  sQuery.Clear;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.CopyFrom (Source: TCrpeSQL);
begin
  Clear;
  sQuery.Assign(Source.sQuery);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSQL.Retrieve : boolean;
var
  TableType       : PETableType;
  LogInfo         : PELogOnInfo;
  nTables, nIndex : Smallint;
  nTable          : integer;
  hText           : hWnd;
  nTextLen        : Smallint;
  pRptCurrent     : PChar;
  HasSQL          : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  HasSQL := False;

  Cr.SetDLLHandle;
  {Check for SQL Tables}
  nTables := PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Retrieve <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Retrieve <PEGetNthTableType>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    { try to find an SQL table }
    if (TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
    begin
      HasSQL := True;
      Break;
    end;
  end;

  if HasSQL then
  begin
    {Try using Connect}
    if Trim(Cr.SubItem.FConnect.FServerName) <> '' then
    begin
      for nIndex := 0 to (nTables - 1) do
      begin
        Cr.SetDLLHandle;
        if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'SQL.Retrieve <PEGetNthTableType>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        { try to find an SQL table }
        if (TableType.DBType = PE_DT_SQL) or
           (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
        begin
          StrCopy(LogInfo.ServerName, PChar(Cr.SubItem.FConnect.FServerName));
          StrCopy(LogInfo.UserID, PChar(Cr.SubItem.FConnect.FUserID));
          StrCopy(LogInfo.Password, PChar(Cr.SubItem.FConnect.FPassword));
          StrCopy(LogInfo.DatabaseName, PChar(Cr.SubItem.FConnect.FDatabaseName));
        end;
        Cr.SetDLLHandle;
        {Set LogonInfo}
        if not PESetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo, False) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'SQL.Retrieve <PESetNthTableLogOnInfo>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Cr.SetDLLHandle;
        {Test LogOn}
        Result := PETestNthTableConnectivity(Cr.FPrintJob, nIndex);
        if Result = False then
          Break;
      end;
    end;

    {Try LogOnInfo}
    if (Result = False) and (Cr.SubItem.FLogOnInfo.Count > 0) then
    begin
      for nIndex := 0 to (nTables - 1) do
      begin
        Cr.SetDLLHandle;
        if not PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'SQL.Retrieve <PEGetNthTableType>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        {Try to find an SQL table}
        if (TableType.DBType = PE_DT_SQL) or
           (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
        begin
          {Check if LogOnInfo count is not equal to table count}
          if nIndex > (Cr.SubItem.FLogOnInfo.Count - 1) then
            nTable := 0
          else
            nTable := nIndex;
          StrCopy(LogInfo.ServerName, PChar(Cr.SubItem.FLogOnInfo.ListItem(nTable).FServerName));
          StrCopy(LogInfo.UserID, PChar(Cr.SubItem.FLogOnInfo.ListItem(nTable).FUserID));
          StrCopy(LogInfo.Password, PChar(Cr.SubItem.FLogOnInfo.ListItem(nTable).FPassword));
          StrCopy(LogInfo.DatabaseName, PChar(Cr.SubItem.FLogOnInfo.ListItem(nTable).FDatabaseName));
        end;
        Cr.SetDLLHandle;
        {Set LogonInfo, propagating across all tables}
        if not PESetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo, False) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'SQL.Retrieve <PESetNthTableLogOnInfo>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Cr.SetDLLHandle;
        {Test LogOn}
        if not PETestNthTableConnectivity(Cr.FPrintJob, nIndex) then
          Break;
      end;
    end;

    {Get the SQL Query}
    nTextLen := 0;
    Cr.SetDLLHandle;
    if PEGetSQLQuery(Cr.FPrintJob, hText, nTextLen) then
    begin
      {Allocate memory for temporary pchar}
      pRptCurrent := StrAlloc(nTextLen);

      {Retrieve the Query from the handle}
      if (nTextLen > 1) then
      begin
        Cr.SetDLLHandle;
        if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
        begin
          StrDispose(pRptCurrent);
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'SQL.Retrieve <PEGetHandleString>') of
            cFalse   : Exit;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Cr.SubItem.FSQL.Query.SetText(pRptCurrent);
        Result := True;
      end;
      StrDispose(pRptCurrent);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSQL.Send : boolean;
var
  hText       : hWnd;
  nTextLen    : Smallint;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
  Changed     : boolean;
begin
  Result := False;
  if (sQuery.Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  Changed := False;

  {Retrieve the current Query from the Report}
  Cr.SetDLLHandle;
  nTextLen := 0;
  if not PEGetSQLQuery(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Send <PEGetSQLQuery>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp PChars}
  pRptCurrent := StrAlloc(nTextLen);

  {Get VCL Query as PChar}
  sTmp := RTrimList(sQuery);
  pTmp := PChar(sTmp);

  {Get the Query text}
  if (nTextLen > 1) then
  begin
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
    begin
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Send <PEGetHandleString>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Compare it to the new Query}
    if StrComp(pTmp, pRptCurrent) <> 0 then
      Changed := True;
  end;
  StrDispose(pRptCurrent);

  {Send the Query}
  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetSQLQuery(Cr.FPrintJob, pTmp) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Send <PESetSQLQuery>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ GetCrpe method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSQL.GetCrpe : TCrpe;
begin
  Result := Cr;
end;
{------------------------------------------------------------------------------}
{ Read method GetQuery                                                         }
{------------------------------------------------------------------------------}
function TCrpeSQL.GetQuery : TCrpeString;
begin
  Result := sQuery;
end;
{------------------------------------------------------------------------------}
{ Write method SetQuery                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.SetQuery (const ListVar: TCrpeString);
begin
  sQuery.Assign(ListVar);
end;
{------------------------------------------------------------------------------}
{ Read method GetParams                                                        }
{------------------------------------------------------------------------------}
function TCrpeSQL.GetParams : TCrpeStoredProcParams;
begin
  Result := FParams;
end;
{------------------------------------------------------------------------------}
{ Write method SetParams                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.SetParams (const Value: TCrpeStoredProcParams);
begin
  FParams.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetExpressions                                                   }
{------------------------------------------------------------------------------}
function TCrpeSQL.GetExpressions : TCrpeSQLExpressions;
begin
  Result := FExpressions;
end;
{------------------------------------------------------------------------------}
{ Write method SetExpressions                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.SetExpressions (const Value: TCrpeSQLExpressions);
begin
  FExpressions.Assign(Value);
end;


{******************************************************************************}
{ Class TCrpeStoredProcParamsItem                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeStoredProcParamsItem.Create;
begin
  inherited Create;
  FName      := '';
  FValue     := '';
  FParamType := spChar;
end;


{******************************************************************************}
{ Class TCrpeStoredProcParams                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeStoredProcParams.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeStoredProcParams.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.CopyFrom (Source: TCrpeStoredProcParams);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Name);
    ListItem(cnt).FValue := Source[cnt].Value;
    ListItem(cnt).FParamType := Source[cnt].ParamType;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.Add (ParamName: TCrStoredProcParamName): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(ParamName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
      'SQL.Params <' + ParamName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeStoredProcParamsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FName := ParamName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.Delete (nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'Params.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.IndexOf(ParamName: TCrStoredProcParamName): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FName, ParamName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.ListItem(nIndex: integer): TCrpeStoredProcParamsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.Retrieve : boolean;
var
  ParamInfo    : PEParameterInfo;
  nTextLen     : Smallint;
  nIndex,
  nParams      : Smallint;
  hText        : hWnd;
  lpRptCurrent : PChar;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Params not used in SCR 7+: use ParamFields instead}
  if Cr.FVersion.FMajor > 6 then
    Exit;
  {Clear the Param lists}
  Clear;

  {Get the number of Params}
  Cr.SetDLLHandle;
  nParams := PEGetNParams(Cr.FPrintJob);
  if (nParams = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Params.Retrieve <PEGetNParams>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Params}
  for nIndex := 0 to (nParams - 1) do
  begin
    {Get Param Name & Type}
    Cr.SetDLLHandle;
    if not PEGetNthParamInfo(Cr.FPrintJob, nIndex, ParamInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Params.Retrieve <PEGetNthParamInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Add(String(ParamInfo.Name));
    if ParamInfo.paramType = PE_PT_BIT then
      ListItem(FIndex).FParamType := spBit
    else if ParamInfo.paramType = PE_PT_TINYINT then
      ListItem(FIndex).FParamType := spTinyInt
    else if ParamInfo.paramType = PE_PT_BIGINT then
      ListItem(FIndex).FParamType := spBigInt
    else if ParamInfo.paramType = PE_PT_LONGVARBINARY then
      ListItem(FIndex).FParamType := spLongVarBinary
    else if ParamInfo.paramType = PE_PT_VARBINARY then
      ListItem(FIndex).FParamType := spVarBinary
    else if ParamInfo.paramType = PE_PT_BINARY then
      ListItem(FIndex).FParamType := spBinary
    else if ParamInfo.paramType = PE_PT_LONGVARCHAR then
      ListItem(FIndex).FParamType := spLongVarChar
    else if ParamInfo.paramType = PE_PT_CHAR then
      ListItem(FIndex).FParamType := spChar
    else if ParamInfo.paramType = PE_PT_NUMERIC then
      ListItem(FIndex).FParamType := spNumeric
    else if ParamInfo.paramType = PE_PT_DECIMAL then
      ListItem(FIndex).FParamType := spDecimal
    else if ParamInfo.paramType = PE_PT_INTEGER	then
      ListItem(FIndex).FParamType := spInteger
    else if ParamInfo.paramType = PE_PT_SMALLINT then
      ListItem(FIndex).FParamType := spSmallInt
    else if ParamInfo.paramType = PE_PT_FLOAT then
      ListItem(FIndex).FParamType := spFloat
    else if ParamInfo.paramType = PE_PT_REAL then
      ListItem(FIndex).FParamType := spReal
    else if ParamInfo.paramType = PE_PT_DOUBLE then
      ListItem(FIndex).FParamType := spDouble
    else if ParamInfo.paramType = PE_PT_DATE then
      ListItem(FIndex).FParamType := spDate
    else if ParamInfo.paramType = PE_PT_TIME then
      ListItem(FIndex).FParamType := spTime
    else if ParamInfo.paramType = PE_PT_TIMESTAMP then
      ListItem(FIndex).FParamType := spTimeStamp
    else if ParamInfo.paramType = PE_PT_VARCHAR then
      ListItem(FIndex).FParamType := spVarChar
    else
      ListItem(FIndex).FParamType := spChar;  {spChar by default}

    {Get Param Value}
    Cr.SetDLLHandle;
    nTextLen := 0;
    if not PEGetNthParam(Cr.FPrintJob, nIndex, hText, nTextLen) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Params.Retrieve <PEGetNthParam>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Allocate memory for temp pchar}
    lpRptCurrent := StrAlloc(nTextLen);
    {Get Param Value}
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, lpRptCurrent, nTextLen) then
    begin
      StrDispose(lpRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Params.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    ListItem(FIndex).FValue := String(lpRptCurrent);
    StrDispose(lpRptCurrent);
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.Send : boolean;
var
  ParamInfo   : PEParameterInfo;
  ParamNames  : TStringList;
  nIndex      : integer;
  nParams     : Smallint;
  nParam      : Smallint;
  nTextLen    : Smallint;
  hText       : hWnd;
  pRptCurrent : PChar;
  Changed     : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  {Params not used in SCR 7+: use ParamFields instead}
  if Cr.FVersion.FMajor > 6 then
    Exit;

  {Get number of Params}
  Cr.SetDLLHandle;
  nParams := PEGetNParams(Cr.FPrintJob);
  if nParams = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Params.Send <PEGetNParams>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp stringlist}
  ParamNames := TStringList.Create;

  {Loop through to get Param Names}
  for nIndex := 0 to (nParams - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthParamInfo(Cr.FPrintJob, nIndex, ParamInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Params.Send <PEGetNthParamInfo>') of
        cFalse   : Continue;
        cTrue    : begin
            ParamNames.Free;
            Abort;
          end;
        cDefault : begin
            ParamNames.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;
    ParamNames.Add(String(ParamInfo.Name));
  end;

  {Loop through the Params that were set}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Check Param name}
    if IsStrEmpty(ListItem(nIndex).FName) then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_PARAM_NAME,
        'SQL.Params[' + IntToStr(nIndex) + '] = ' + ListItem(nIndex).FName) of
        cFalse   : Continue;
        cTrue    : begin
            ParamNames.Free;
            Abort;
          end;
        cDefault : begin
            ParamNames.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;

    {Get the actual Param number}
    nParam := ParamNames.IndexOf(ListItem(nIndex).FName);
    if nParam < 0 then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_PARAM_NAME,
        'SQL.Params[' + IntToStr(nIndex) + '] = ' + ListItem(nIndex).FName) of
        cFalse   : Continue;
        cTrue    : begin
            ParamNames.Free;
            Abort;
          end;
        cDefault : begin
            ParamNames.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;

    {Retrieve the Param currently in the Report}
    nTextLen := 0;
    Cr.SetDLLHandle;
    if not PEGetNthParam(Cr.FPrintJob, nParam, hText, nTextLen) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Params.Send <PEGetNthParam>') of
        cFalse   : Continue;
        cTrue    : begin
            ParamNames.Free;
            Abort;
          end;
        cDefault : begin
            ParamNames.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;

    {Allocate memory for temp pchar}
    pRptCurrent := StrAlloc(nTextLen);
    {Get the Param Value}
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Params.Send <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : begin
            StrDispose(pRptCurrent);
            Abort;
          end;
        cDefault : begin
            StrDispose(pRptCurrent);
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;

    {Compare it to new value..If they are the same, do not send}
    if StrComp(PChar(ListItem(nIndex).FValue), pRptCurrent) <> 0 then
      Changed := True;
    StrDispose(pRptCurrent);

    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetNthParam(Cr.FPrintJob, nParam, PChar(ListItem(nIndex).FValue)) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SQL.Params.Send <PESetNthParam>') of
          cFalse   : Continue;
          cTrue    : begin
              ParamNames.Free;
              Abort;
            end;
          cDefault : begin
              ParamNames.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;
      Result := True;
    end;
  end; { for }
  ParamNames.Free;
end; { Send }
{------------------------------------------------------------------------------}
{ Read method GetName                                                          }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetName : TCrStoredProcParamName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write method SetName                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetName (const Value: TCrStoredProcParamName);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
      'SQL.Params.Name := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetParamType                                                     }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetParamType : TCrStoredProcParamType;
begin
  Result := spChar;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FParamType;
end;
{------------------------------------------------------------------------------}
{ Write method SetParamType                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetParamType (const Value: TCrStoredProcParamType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FParamType := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetParamValue                                                    }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetValue : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FValue;
end;
{------------------------------------------------------------------------------}
{ Write method SetParamValue                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetValue (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetAsDate                                                        }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetAsDate : TDateTime;
var
  dTmp : TDateTime;
begin
  Result := Now;
  if IndexInRange(FIndex, FList.Count) then
  begin
    {Get the Parameter Value}
    if not CrStrToDate(ListItem(FIndex).FValue, dTmp) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_AS_DATE,
        'SQL.Params[' + IntToStr(FIndex) + '] <' + ListItem(FIndex).FValue + '>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end
    else
      Result := dTmp;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Params[' + IntToStr(FIndex) + ']' + '<GetAsDate>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsDate                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetAsDate (const Value: TDateTime);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrDateToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsDateTime                                                    }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetAsDateTime : TDateTime;
var
  dtTmp : TDateTime;
begin
  Result := Now;
  if IndexInRange(FIndex, FList.Count) then
  begin
    {Get the Parameter Value}
    if not CrStrToDateTime(ListItem(FIndex).FValue, dtTmp) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_AS_DATETIME,
         'SQL.Params[' + IntToStr(FIndex) + '] <' +
         ListItem(FIndex).FValue + '>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end
    else
      Result := dtTmp;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Params[' + IntToStr(FIndex) + ']' + '<GetAsDateTime>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsDateTime                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetAsDateTime (const Value: TDateTime);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrDateTimeToStr(Value, True);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsBoolean                                                     }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetAsBoolean : boolean;
begin
  Result := False;
  if IndexInRange(FIndex, FList.Count) then
    Result := CrStrToBoolean(ListItem(FIndex).FValue)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Params[' + IntToStr(FIndex) + ']' + '<GetAsBoolean>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsBoolean                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetAsBoolean (const Value: boolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrBooleanToStr(Value, True);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsInteger                                                      }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetAsInteger : integer;
begin
  Result := 0;
  if IndexInRange(FIndex, Count) then
  begin
    if IsNumeric(ListItem(FIndex).FValue) then
      Result := StrToInt(ListItem(FIndex).FValue);
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Params[' + IntToStr(FIndex) + ']' + '<GetAsInteger>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsInteger                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetAsInteger (const Value: integer);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := IntToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsFloat                                                       }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetAsFloat : double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    try
      Result := StrToFloat(ListItem(FIndex).FValue);
    except
      on EConvertError do
        Result := 0;
    end;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Params[' + IntToStr(FIndex) + ']' + '<GetAsFloat>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsFloat                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetAsFloat (const Value: double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := FloatToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeStoredProcParams.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Params[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetItem                                                          }
{------------------------------------------------------------------------------}
function TCrpeStoredProcParams.GetItem(const nIndex: integer) : TCrpeStoredProcParams;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSQLExpressionsItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSQLExpressionsItem.Create;
begin
  inherited Create;
  FName    := '';
  FExpression := TCrpeString.Create;
end;
{------------------------------------------------------------------------------}
{ destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSQLExpressionsItem.Destroy;
begin
  FExpression.Free;
  inherited Destroy;
end;


{******************************************************************************}
{ Class TCrpeSQLExpressions                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSQLExpressions.Create;
begin
  inherited Create;
  FList := TList.Create;
  sTemp := TCrpeString.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSQLExpressions.Destroy;
begin
  Clear;
  FList.Free;
  sTemp.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  sTemp.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.CopyFrom (Source: TCrpeSQLExpressions);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Name);
    ListItem(cnt).FExpression.Assign(Source[cnt].Expression);
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.ListItem(nIndex: integer) : TCrpeSQLExpressionsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Add (ExpressionName: TCrExpressionName): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(ExpressionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'SQL.Expressions <' + ExpressionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSQLExpressionsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FName := ExpressionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SQL.Expressions.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Retrieve : boolean;
var
  NameHandle   : hWnd;
  NameLength   : smallint;
  TxtHandle    : hWnd;
  TxtLength    : Smallint;
  TxtBuffer    : PChar;
  nExpressions : Smallint;
  nExpression  : Smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {SQL Expressions only in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  {Clear Expressions}
  Clear;

  {Get number of Expressions}
  Cr.SetDLLHandle;
  nExpressions := PEGetNSQLExpressions(Cr.FPrintJob);
  if (nExpressions = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Retrieve <PEGetNSQLExpressions>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Expressions}
  for nExpression := 0 to (nExpressions - 1) do
  begin
    NameLength := 0;
    TxtLength := 0;
    {Retrieve Expression}
    Cr.SetDLLHandle;
    if not PEGetNthSQLExpression(Cr.FPrintJob, nExpression, NameHandle,
      NameLength, TxtHandle, TxtLength) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Expressions.Retrieve <PEGetNthSQLExpression>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Allocate memory for temp PChar}
    TxtBuffer := StrAlloc(NameLength);

    {Get Expression Name}
    Cr.SetDLLHandle;
    if not PEGetHandleString(NameHandle, TxtBuffer, NameLength) then
    begin
      StrDispose(TxtBuffer);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Expressions.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Add a new item to the Expressions object}
    Add(String(TxtBuffer));
    StrDispose(TxtBuffer);

    {Get Expression}
    TxtBuffer := StrAlloc(TxtLength);
    Cr.SetDLLHandle;
    if not PEGetHandleString(TxtHandle, TxtBuffer, TxtLength) then
    begin
      StrDispose(TxtBuffer);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Expressions.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    ListItem(FIndex).FExpression.SetText(TxtBuffer);
    StrDispose(TxtBuffer);
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Check method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Check : boolean;
var
  nTextLen    : Smallint;
  hText       : hWnd;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {SQL Expressions only in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  nTextLen := 0;

  {Obtain the Formula from the Report}
  Cr.SetDLLHandle;
  if not PEGetSQLExpression(Cr.FPrintJob, PChar(ListItem(FIndex).FName),
    hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Check <PEGetSQLExpression>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp PChar}
  pRptCurrent := StrAlloc(nTextLen);

  {Get the original Expression string}
  Cr.SetDLLHandle;
  if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Check <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Copy to PChar}
  sTmp := RTrimList(ListItem(FIndex).FExpression);
  pTmp := PChar(sTmp);

  {Set and Check the new Expression}
  Cr.SetDLLHandle;
  if not PESetSQLExpression(Cr.FPrintJob, PChar(ListItem(FIndex).FName), pTmp) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Check <PESetSQLExpression>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Check the Expression}
  Cr.SetDLLHandle;
  Result := PECheckSQLExpression(Cr.FPrintJob, PChar(ListItem(FIndex).FName));
  {Set the original Expression back in}
  if not PESetSQLExpression(Cr.FPrintJob, PChar(ListItem(FIndex).FName), pRptCurrent) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Check <PESetSQLExpression>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  StrDispose(pRptCurrent);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Send : boolean;
var
  sExpressionName : string;
  nTextLen        : Smallint;
  hText           : hWnd;
  nIndex          : Smallint;
  nExpressions    : Smallint;
  pRptCurrent     : PChar;
  Changed         : boolean;
  sTmp            : string;
  pTmp            : PChar;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  {SQL Expressions only in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  {Get the number of Expressions}
  Cr.SetDLLHandle;
  nExpressions := PEGetNSQLExpressions(Cr.FPrintJob);
  if (nExpressions = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Send <PEGetNSQLExpressions>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Expressions}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Get the Expression Name from the VCL}
    sExpressionName := ListItem(nIndex).FName;
    nTextLen := 0;

    {Retrieve the Expression currently in the Report}
    Cr.SetDLLHandle;
    if not PEGetSQLExpression(Cr.FPrintJob, PChar(sExpressionName),
      hText, nTextLen) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Expressions.Send <PEGetSQLExpression>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get the Expression}
    pRptCurrent := StrAlloc(nTextLen);
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
    begin
      Result := False;
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.Expressions.Send <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Trim of LF/CR characters}
    sTmp := RTrimList(ListItem(nIndex).FExpression);
    {Blank formulas are not sent}
    if Length(sTmp) = 0 then
    begin
      StrDispose(pRptCurrent);
      Continue;
    end;
    {Check for CrEmptyStr}
    if LowerCase(sTmp) = CrEmptyStr then
      sTmp := '';
    {Copy to PChar}
    pTmp := PChar(sTmp);

    {Compare it to the new formula...If they are the same, do not send}
    if StrComp(pTmp, pRptCurrent) <> 0 then
       Changed := True;
    StrDispose(pRptCurrent);

    {Send the Expression to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetSQLExpression(Cr.FPrintJob, PChar(sExpressionName), pTmp) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
             'SQL.Expressions.Send <PESetSQLExpression> [ExpressionName: ' + sExpressionName + ']') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.IndexOf(ExpressionName: TCrExpressionName): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FName, ExpressionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetName                                                   }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.GetName : TCrExpressionName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetName                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetName(const Value: TCrExpressionName);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
      'SQL.Expressions.Name := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetExpression                                             }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.GetExpression : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FExpression;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetExpression                                            }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetExpression(const ListVar: TCrpeString);
begin
  sTemp.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FExpression.Assign(ListVar);
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SQL.Expressions[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SQL.Expressions[nIndex]                                       }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.GetItem(nIndex: integer) : TCrpeSQLExpressions;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeParamFieldInfo                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldInfo.Create;
begin
  inherited Create;
  FAllowNull := cDefault;
  FAllowEditing := cDefault;
  FAllowMultipleValues := cDefault;
  FPartOfGroup := cDefault;
  FMutuallyExclusiveGroup := cDefault;
  FValueType := vtDiscrete;
  FGroupNum := -1;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.Clear;
begin
  FAllowNull := cDefault;
  FAllowEditing := cDefault;
  FAllowMultipleValues := cDefault;
  FPartOfGroup := cDefault;
  FMutuallyExclusiveGroup := cDefault;
  FValueType := vtDiscrete;
  FGroupNum := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.CopyFrom (Source: TCrpeParamFieldInfo);
begin
  Clear;
  FAllowNull := Source.FAllowNull;
  FAllowEditing := Source.FAllowEditing;
  FAllowMultipleValues := Source.FAllowMultipleValues;
  FPartOfGroup := Source.FPartOfGroup;
  FMutuallyExclusiveGroup := Source.FMutuallyExclusiveGroup;
  FValueType := Source.FValueType;
  FGroupNum := Source.FGroupNum;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.Retrieve : boolean;
var
  ParameterValueInfo : PEParameterValueInfo;
  pName              : PChar;
  pReportName        : PChar;
  nIndex             : integer;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {ParamField Info only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  {Copy ParamField Name and ReportName to PChar}
  pName := StrAlloc(Length(Pf.Name) + 1);
  pReportName := StrAlloc(Length(Pf.ReportName) + 1);
  StrCopy(pName, PChar(Pf.Name));
  StrCopy(pReportName, PChar(Pf.ReportName));

  {Locate Current Info object}
  nIndex := Pf.FIndex;

  {Retrieve Info}
  Cr.SetDLLHandle;
  if not PEGetParameterValueInfo(Cr.FPrintJob, pName, pReportName,
    ParameterValueInfo) then
  begin
    StrDispose(pName);
    StrDispose(pReportName);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       '<Retrieve> ParamFields[' + IntToStr(nIndex) + '].Info <PEGetParameterValueInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  StrDispose(pName);
  StrDispose(pReportName);

  {AllowNull}
  case ParameterValueInfo.isNullable of
    0: FAllowNull := cFalse;
    1: FAllowNull := cTrue;
    else {-1}
      FAllowNull := cDefault;
  end;
  {AllowEditing}
  case ParameterValueInfo.disallowEditing of
    0: FAllowEditing := cTrue;
    1: FAllowEditing := cFalse;
    else {-1}
      FAllowEditing := cDefault;
  end;
  {AllowMultipleValues}
  case ParameterValueInfo.allowMultipleValues of
    0: FAllowMultipleValues := cFalse;
    1: FAllowMultipleValues := cTrue;
    else {-1}
      FAllowMultipleValues := cDefault;
  end;
  {ValueType: We don't allow default because a definite
   value type is required for ParamField Ranges Retrieve/Send}
  case ParameterValueInfo.hasDiscreteValues of
    0: FValueType := vtRanges;
    1: FValueType := vtDiscrete;
    else {-1}
      FValueType := vtDiscrete;
  end;
  {partOfGroup}
  case ParameterValueInfo.partOfGroup of
    0: FPartOfGroup := cFalse;
    1: FPartOfGroup := cTrue;
    else {-1}
      FPartOfGroup := cDefault;
  end;
  {mutuallyExclusiveGroup}
  case ParameterValueInfo.mutuallyExclusiveGroup of
    0: FMutuallyExclusiveGroup := cFalse;
    1: FMutuallyExclusiveGroup := cTrue;
    else {-1}
      FMutuallyExclusiveGroup := cDefault;
  end;
  {groupNum}
  FGroupNum := ParameterValueInfo.groupNum;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.Send : boolean;
var
  ParameterValueInfo : PEParameterValueInfo;
  pName              : PChar;
  pReportName        : PChar;
  nIndex             : integer;
  Changed            : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {ParamField Info only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  Changed := False;

  {Copy ParamField Name and ReportName to PChar}
  pName := StrAlloc(Length(Pf.Name) + 1);
  pReportName := StrAlloc(Length(Pf.ReportName) + 1);
  StrCopy(pName, PChar(Pf.Name));
  StrCopy(pReportName, PChar(Pf.ReportName));

  {Locate Current Info object}
  nIndex := Pf.FIndex;

  {Get the current Report settings}
  Cr.SetDLLHandle;
  if not PEGetParameterValueInfo(Cr.FPrintJob, pName, pReportName,
    ParameterValueInfo) then
  begin
    StrDispose(pName);
    StrDispose(pReportName);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
       IntToStr(nIndex) + '].Info <PEGetParameterValueInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {AllowNull}
  if FAllowNull <> cDefault then
  begin
    if Ord(FAllowNull) <> ParameterValueInfo.isNullable then
    begin
      ParameterValueInfo.isNullable := Ord(FAllowNull);
      Changed := True;
    end;
  end;
  {AllowEditing}
  if FAllowEditing <> cDefault then
  begin
    if Ord(FAllowEditing) = ParameterValueInfo.disallowEditing then
    begin
      ParameterValueInfo.disallowEditing := Ord(FAllowEditing);
      Changed := True;
    end;
  end;
  {AllowMultipleValues}
  if FAllowMultipleValues <> cDefault then
  begin
    if Ord(FAllowMultipleValues) <> ParameterValueInfo.allowMultipleValues then
    begin
      ParameterValueInfo.allowMultipleValues := Ord(FAllowMultipleValues);
      Changed := True;
    end;
  end;
  {ValueType}
  if Ord(FValueType) <> ParameterValueInfo.hasDiscreteValues then
  begin
    ParameterValueInfo.hasDiscreteValues := Ord(FValueType);
    Changed := True;
  end;
  {partOfGroup}
  if FPartOfGroup <> cDefault then
  begin
    if Ord(FPartOfGroup) <> ParameterValueInfo.partOfGroup then
    begin
      ParameterValueInfo.partOfGroup := Ord(FPartOfGroup);
      Changed := True;
    end;
  end;
  {mutuallyExclusiveGroup}
  if FMutuallyExclusiveGroup <> cDefault then
  begin
    if Ord(FMutuallyExclusiveGroup) <> ParameterValueInfo.mutuallyExclusiveGroup then
    begin
      ParameterValueInfo.mutuallyExclusiveGroup := Ord(FMutuallyExclusiveGroup);
      Changed := True;
    end;
  end;
  {groupNum}
  if FGroupNum <> -1 then
  begin
    if FGroupNum <> ParameterValueInfo.groupNum then
    begin
      ParameterValueInfo.groupNum := FGroupNum;
      Changed := True;
    end;
  end;
  {Send the Parameter Info to the Report}
  if Changed then
  begin
    Cr.SetDLLHandle;
    if not PESetParameterValueInfo(Cr.FPrintJob, pName,
      pReportName, ParameterValueInfo) then
    begin
      StrDispose(pName);
      StrDispose(pReportName);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
         IntToStr(nIndex) + '].Info <PESetParameterValueInfo>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
  StrDispose(pName);
  StrDispose(pReportName);
end;
{------------------------------------------------------------------------------}
{ Read method GetAllowNull                                                     }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetAllowNull : TCrBoolean;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FAllowNull
  else
    Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ Write method SetAllowNull                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetAllowNull (const Value: TCrBoolean);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FAllowNull := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetAllowEditing                                                  }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetAllowEditing : TCrBoolean;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FAllowEditing
  else
    Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ Write method SetAllowEditing                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetAllowEditing (const Value: TCrBoolean);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FAllowEditing := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetAllowMultipleValues                                           }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetAllowMultipleValues : TCrBoolean;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FAllowMultipleValues
  else
    Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ Write method SetAllowMultipleValues                                          }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetAllowMultipleValues (const Value: TCrBoolean);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FAllowMultipleValues := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetValueType                                                     }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetValueType : TCrParamInfoValueType;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FValueType
  else
    Result := vtDiscrete;
end;
{------------------------------------------------------------------------------}
{ Write method SetValueType                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetValueType (const Value: TCrParamInfoValueType);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FValueType := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetPartOfGroup                                                   }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetPartOfGroup : TCrBoolean;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FPartOfGroup
  else
    Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ Write method SetPartOfGroup                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetPartOfGroup (const Value: TCrBoolean);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FPartOfGroup := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetMutuallyExclusiveGroup                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetMutuallyExclusiveGroup : TCrBoolean;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FMutuallyExclusiveGroup
  else
    Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ Write method SetMutuallyExclusiveGroup                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetMutuallyExclusiveGroup (const Value: TCrBoolean);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FMutuallyExclusiveGroup := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetGroupNum                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFieldInfo.GetGroupNum : smallint;
begin
  if IndexInRange(Pf.FIndex, Pf.Count) then
    Result := FGroupNum
  else
    Result := -1;
end;
{------------------------------------------------------------------------------}
{ Write method SetGroupNum                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetGroupNum (const Value: smallint);
begin
  if IndexValid(Pf.FIndex, Pf.Count) then
    FGroupNum := Value;
end;


{******************************************************************************}
{ Class TCrpeParamFieldRangesItem                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldRangesItem.Create;
begin
  inherited Create;
  FNumber      := -1;
  FRangeStart  := '';
  FRangeEnd    := '';
  FRangeBounds := IncludeStartAndEnd;
end;


{******************************************************************************}
{ Class TCrpeParamFieldRanges                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldRanges.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFieldRanges.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.CopyFrom (Source: TCrpeParamFieldRanges);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FRangeStart := Source[cnt].RangeStart;
    ListItem(cnt).FRangeEnd := Source[cnt].RangeEnd;
    ListItem(cnt).FRangeBounds := Source[cnt].RangeBounds;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.IndexOf(RangeNumber: TCrRangeNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = RangeNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.ListItem(nIndex: integer): TCrpeParamFieldRangesItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.Add (RangeNumber: TCrRangeNumber): integer;
var
  p1 : Pointer;
begin
  Result := -1;
  if IndexOf(RangeNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'ParamFields.Ranges[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeParamFieldRangesItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := RangeNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.Delete (nIndex : integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields.Ranges.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.Retrieve : boolean;
var
  pName          : PChar;
  pReportName    : PChar;
  nValues        : Smallint;
  nValue         : Smallint;
  startValueInfo : PEValueInfo;
  endValueInfo   : PEValueInfo;
  iRangeInfo     : Smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {ParameterFieldRanges only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  {Clear Ranges}
  Clear;

  {Only Retrieve if ValueType is vtRanges}
  if Pf.Info.ValueType <> vtRanges then
    Exit;

  {Copy ParamField Name and ReportName to PChar}
  pName := PChar(Pf.Name);
  pReportName := PChar(Pf.ReportName);

  Cr.SetDLLHandle;
  nValues := PEGetNParameterCurrentRanges(Cr.FPrintJob, pName, pReportName);
  if nValues = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Retrieve> ParamFields[' +
       IntToStr(Pf.FIndex) + '].Ranges <PEGetNParameterCurrentValues>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Loop through Ranges}
  for nValue := 0 to (nValues - 1) do
  begin
    iRangeInfo := 0;
    Cr.SetDLLHandle;
    if not PEGetNthParameterCurrentRange(Cr.FPrintJob, pName, pReportName,
      nValue, startValueInfo, endValueInfo, iRangeInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Retrieve> ParamFields[' +
       IntToStr(Pf.FIndex) + '].Ranges <PEGetNthParameterCurrentRange>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Store the Range Values}
    Add(nValue);
    ListItem(FIndex).FRangeStart := ValueInfoToStr(startValueInfo);
    ListItem(FIndex).FRangeEnd := ValueInfoToStr(endValueInfo);

    {Store Range Bounds info}
    if (iRangeInfo - PE_RI_NOLOWERBOUND > -1) then
    begin
      iRangeInfo := iRangeInfo - PE_RI_NOLOWERBOUND;
      if iRangeInfo - PE_RI_NOUPPERBOUND > -1 then
        ListItem(FIndex).FRangeBounds := ExcludeStartAndEnd
      else
        ListItem(FIndex).FRangeBounds := IncludeEndOnly;
    end
    else
    begin
      if iRangeInfo - PE_RI_INCLUDELOWERBOUND > -1 then
      begin
        iRangeInfo := iRangeInfo - PE_RI_INCLUDELOWERBOUND;
        if iRangeInfo - PE_RI_INCLUDEUPPERBOUND > -1 then
          ListItem(FIndex).FRangeBounds := IncludeStartAndEnd
        else
          ListItem(FIndex).FRangeBounds := IncludeStartOnly;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.Send : boolean;
var
  startValueInfo : PEValueInfo;
  endValueInfo   : PEValueInfo;
  pName          : PChar;
  pReportName    : PChar;
  nValues        : Smallint;
  nValue         : Smallint;
  iRangeInfo     : Smallint;
  rptStart       : TCrpeString;
  rptEnd         : TCrpeString;
  rptBounds      : TCrpeString;
  nIndex         : Smallint;
  Changed        : boolean;
  PType          : Smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {ParameterFieldRanges only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  Changed := False;

  {Only Send if ValueType is vtRanges}
  if Pf.Info.ValueType <> vtRanges then
    Exit;
  {Get ParamType}
  PType := Ord(Pf.ParamType);

  {Copy ParamField Name and ReportName to PChar}
  pName := PChar(Pf.Name);
  pReportName := PChar(Pf.ReportName);

  {Retrieve Number of Report Ranges}
  Cr.SetDLLHandle;
  nValues := PEGetNParameterCurrentRanges(Cr.FPrintJob, pName, pReportName);
  if nValues = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
       IntToStr(Pf.FIndex) + '].Ranges <PEGetNParameterCurrentRanges>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Initialize stringlists}
  rptStart := TCrpeString.Create;
  rptEnd := TCrpeString.Create;
  rptBounds := TCrpeString.Create;

  {Loop through the Ranges}
  for nValue := 0 to (nValues - 1) do
  begin
    iRangeInfo := 0;
    Cr.SetDLLHandle;
    if not PEGetNthParameterCurrentRange(Cr.FPrintJob, pName,
      pReportName, nValue, startValueInfo, endValueInfo, iRangeInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
         IntToStr(Pf.FIndex) + '].Ranges[' + IntToStr(nValue) + '] <PEGetNthParameterCurrentRange>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    rptStart.Add(ValueInfoToStr(startValueInfo));
    rptEnd.Add(ValueInfoToStr(endValueInfo));
    {Get Bounds info}
    if (iRangeInfo - PE_RI_NOLOWERBOUND > -1) then
    begin
      iRangeInfo := iRangeInfo - PE_RI_NOLOWERBOUND;
      if iRangeInfo - PE_RI_NOUPPERBOUND > -1 then
        rptBounds.Add(IntToStr(Ord(ExcludeStartAndEnd)))
      else
        rptBounds.Add(IntToStr(Ord(IncludeEndOnly)));
    end
    else
    begin
      if iRangeInfo - PE_RI_INCLUDELOWERBOUND > -1 then
      begin
        iRangeInfo := iRangeInfo - PE_RI_INCLUDELOWERBOUND;
        if iRangeInfo - PE_RI_INCLUDEUPPERBOUND > -1 then
          rptBounds.Add(IntToStr(Ord(IncludeStartAndEnd)))
        else
          rptBounds.Add(IntToStr(Ord(IncludeStartOnly)));
      end;
    end;
  end;

  {Compare Ranges for changes}
  for nIndex := 0 to Count - 1 do
  begin
    if (CompareStr(ListItem(nIndex).FRangeStart, rptStart[nIndex]) <> 0) or
       (CompareStr(ListItem(nIndex).FRangeEnd, rptEnd[nIndex]) <> 0) then
      Changed := True;
    {Compare RangeBounds}
    if ListItem(nIndex).FRangeBounds <> TCrRangeBounds(StrToInt(rptBounds[nIndex])) then
      Changed := True;
  end;
  {Clear Report range lists}
  rptStart.Free;
  rptEnd.Free;
  rptBounds.Free;

  if Changed then
  begin
    {Clear Report Ranges}
    Cr.SetDLLHandle;
    if not PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, pName, pReportName) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields [' +
         IntToStr(Pf.FIndex) + '].Ranges <PEClearParameterCurrentValuesAndRanges>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Loop through the lists}
    for nIndex := 0 to Count - 1 do
    begin
      {StartRange}
      startValueInfo.valueType := PType;
      if not StrToValueInfo(ListItem(nIndex).FRangeStart, startValueInfo) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
            '<Send> ParamFields[' + IntToStr(Pf.FIndex) + '].Ranges[' +
            IntToStr(nIndex) + '] <StrToValueInfo - StartRanges>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      {EndRange}
      endValueInfo.valueType := PType;
      if not StrToValueInfo (ListItem(nIndex).FRangeEnd, endValueInfo) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
            '<Send> ParamFields[' + IntToStr(Pf.FIndex) + '].Ranges[' +
            IntToStr(nIndex) + '] <StrToValueInfo - EndRanges>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      {RangeBounds}
      case ListItem(nIndex).FRangeBounds of
        IncludeStartAndEnd : iRangeInfo := PE_RI_INCLUDEUPPERBOUND and PE_RI_INCLUDELOWERBOUND;
        IncludeStartOnly   : iRangeInfo := PE_RI_INCLUDELOWERBOUND;
        IncludeEndOnly     : iRangeInfo := PE_RI_INCLUDEUPPERBOUND;
        ExcludeStartAndEnd : iRangeInfo := PE_RI_NOUPPERBOUND and PE_RI_NOLOWERBOUND;
      end;

      {Send New Range settings}
      startValueInfo.valueType := PType;
      endValueInfo.valueType := PType;
      Cr.SetDLLHandle;
      if not PEAddParameterCurrentRange(Cr.FPrintJob, pName,
        pReportName, startValueInfo, endValueInfo, iRangeInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
           IntToStr(Pf.FIndex) + '].Ranges[' + IntToStr(nIndex) +
           '] <PEAddParameterCurrentRange>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end; {Loop through VCL Ranges}
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ Read method GetNumber                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetNumber : TCrRangeNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write method SetNumber                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.SetNumber (const Value: TCrRangeNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'ParamFields.Ranges.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetRangeStart                                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetRangeStart : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FRangeStart;
end;
{------------------------------------------------------------------------------}
{ Write method SetRangeStart                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.SetRangeStart (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FRangeStart := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetRangeEnd                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetRangeEnd : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FRangeEnd;
end;
{------------------------------------------------------------------------------}
{ Write method SetRangeEnd                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.SetRangeEnd (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FRangeEnd := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetRangeBounds                                                   }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetRangeBounds : TCrRangeBounds;
begin
  Result := IncludeStartAndEnd;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FRangeBounds;
end;
{------------------------------------------------------------------------------}
{ Write method SetRangeBounds                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.SetRangeBounds (const Value: TCrRangeBounds);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FRangeBounds := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields.Ranges[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetItem                                                          }
{   - This is the default property and can be also set                         }
{      via Crpe1.ParamFields.Ranges[nIndex]                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetItem(const nIndex: integer) : TCrpeParamFieldRanges;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeParamFieldsItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldsItem.Create;
begin
  inherited Create;
  FNameAndReport       := '';
  FName                := '';
  FPrompt              := '';
  FValue               := '';
  FDefaultValue        := '';
  FCurrentValue        := '';
  FShowDialog          := False;
  FParamType           := pfNoValue;
  FReportName          := '';
  FNeedsCurrentValue   := False;
 {SCR7+}
  {Ranges}
  FRanges              := TCrpeParamFieldRanges.Create;
  {DefaultValues}
  FDList               := TCrpeString.Create;
  {CurrentValues}
  FCList               := TCrpeString.Create;
  {PickList}
  FPList               := TCrpeString.Create;
  {ParamField Info}
  FInfo                := TCrpeParamFieldInfo.Create;
  FParamSource         := psReport;
  FValueLimit          := cDefault;
  FValueMin            := '';
  FValueMax            := '';
  FEditMask            := '';
  {PickList Options}
  FPLDescriptionOnly   := cDefault;
  FPLSortMethod        := psmDefaultSort;
  FPLSortByDescription := cDefault;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFieldsItem.Destroy;
begin
  FRanges.Free;
  FDList.Free;
  FCList.Free;
  FPList.Free;
  FInfo.Free;
end;


{******************************************************************************}
{ Class TCrpeParamFields                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFields.Create;
begin
  inherited Create;
  FList := TList.Create;
  {Temp variables}
  TempInfo := TCrpeParamFieldInfo.Create;
  TempInfo.Pf := Self;
  TempRanges := TCrpeParamFieldRanges.Create;
  TempRanges.Pf := Self;
  sTemp := TCrpeString.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFields.Destroy;
begin
  Clear;
  FList.Free;
  {Temp variables}
  TempInfo.Free;
  TempRanges.Free;
  sTemp.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.Clear;
var
  cnt : smallint;
begin
  {Clear the ParamFieldsItems List}
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  {Free temp variables}
  sTemp.Clear;
  TempInfo.Clear;
  TempRanges.Clear;
  {Set Index}
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.CopyFrom (Source: TCrpeParamFields);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Name, Source[cnt].ReportName);
    ListItem(cnt).FName := Source[cnt].Name;
    ListItem(cnt).FPrompt := Source[cnt].Prompt;
    ListItem(cnt).FValue := Source[cnt].Value;
    ListItem(cnt).FDefaultValue := Source[cnt].DefaultValue;
    ListItem(cnt).FCurrentValue := Source[cnt].CurrentValue;
    ListItem(cnt).FShowDialog := Source[cnt].ShowDialog;
    ListItem(cnt).FParamType := Source[cnt].ParamType;
    ListItem(cnt).FReportName := Source[cnt].ReportName;
    ListItem(cnt).FNeedsCurrentValue := Source[cnt].NeedsCurrentValue;
    {Ranges}
    ListItem(cnt).FRanges.CopyFrom(Source[cnt].Ranges);
    {DefaultValues}
    ListItem(cnt).FDList.Assign(Source[cnt].DefaultValues);
    {CurrentValues}
    ListItem(cnt).FCList.Assign(Source[cnt].CurrentValues);
    {PickList}
    ListItem(cnt).FPList.Assign(Source[cnt].PickList);
    {ParamFields Info}
    ListItem(cnt).FInfo.CopyFrom(Source[cnt].Info);
    ListItem(cnt).FParamSource := Source[cnt].ParamSource;
    ListItem(cnt).FValueLimit := Source[cnt].ValueLimit;
    ListItem(cnt).FValueMin := Source[cnt].ValueMin;
    ListItem(cnt).FValueMax := Source[cnt].ValueMax;
    ListItem(cnt).FEditMask := Source[cnt].EditMask;
    {PickList Options}
    ListItem(cnt).FPLDescriptionOnly := Source[cnt].PLDescriptionOnly;
    ListItem(cnt).FPLSortMethod := Source[cnt].PLSortMethod;
    ListItem(cnt).FPLSortByDescription := Source[cnt].PLSortByDescription;
  end;
  TempInfo.CopyFrom(Source.TempInfo);
  TempRanges.CopyFrom(Source.TempRanges);
  sTemp.Assign(Source.sTemp);
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeParamFields.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeParamFields.Add (ParameterName: TCrParamFieldName;
  ReportName: TCrParamFieldReportName): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(ParameterName, ReportName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'ParamFields <' + ParameterName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    {Check lengths}
    if Length(ParameterName) > PE_PF_NAME_LEN then
      ParameterName := Copy(ParameterName, 1, PE_PF_NAME_LEN);
    if Length(ReportName) > PE_PF_REPORT_NAME_LEN then
      ReportName := Copy(ReportName, 1, PE_PF_REPORT_NAME_LEN);
    {Create new item}
    p1 := TCrpeParamFieldsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNameAndReport := ParameterName + ReportName;
    ListItem(FIndex).FName := ParameterName;
    ListItem(FIndex).FReportName := ReportName;
    ListItem(FIndex).FRanges.Pf := Self;
    ListItem(Findex).FRanges.Cr := Self.Cr;
    ListItem(FIndex).FInfo.Pf := Self;
    ListItem(Findex).FInfo.Cr := Self.Cr;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeParamFields.IndexOf(ParameterName: TCrParamFieldName;
  ReportName: TCrParamFieldReportName): integer;
var
  cnt : integer;
  s1  : string;
begin
  Result := -1;
  s1 := ParameterName + ReportName;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNameAndReport = s1 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ IndexOfName method                                                           }
{------------------------------------------------------------------------------}
function TCrpeParamFields.IndexOfName(ParameterName: TCrParamFieldName): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FName = ParameterName then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeParamFields.ListItem(nIndex: integer): TCrpeParamFieldsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeParamFields.Retrieve : boolean;
var
  ParameterInfo : PEParameterFieldInfo;
  ValueInfo     : PEValueInfo;
  nParam        : Smallint;
  nParams       : Smallint;
  sTmp          : string;
  {SCR 7}
  nType         : smallint;
  minValueInfo  : PEValueInfo;
  maxValueInfo  : PEValueInfo;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the ParamField lists}
  Clear;

  {Get the Parameter Names from the Report}
  Cr.SetDLLHandle;
  nParams := PEGetNParameterFields(Cr.FPrintJob);
  if nParams = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        '<Retrieve> ParamFields <PEGetNParameterFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Parameters}
  for nParam := 0 to (nParams - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthParameterField(Cr.FPrintJob, nParam, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          '<Retrieve> ParamFields[' + IntToStr(nParam) + '] <PEGetNthParameterField>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    sTmp := '';

    {Add new ParamFields Item}
    Add(String(ParameterInfo.Name), String(ParameterInfo.ReportName));
    {Parameter Prompt}
    ListItem(Findex).FPrompt := String(ParameterInfo.Prompt);

    {Parameter CurrentValueSet: ShowDialog}
    {ShowDialog is set to False by default...}
    ListItem(FIndex).FShowDialog := False;
    {if ParameterInfo.CurrentValueSet = 0 then
      ListItem(FIndex).FShowDialog := True;}  {not used}

    {Parameter needsCurrentValue}
    ListItem(FIndex).FNeedsCurrentValue := False;
    if ParameterInfo.needsCurrentValue > 0 then
      ListItem(FIndex).FNeedsCurrentValue := True;

    {Parameter Type}
    ListItem(FIndex).FParamType := pfNoValue;
    case ParameterInfo.valueType of
      PE_PF_NUMBER    : ListItem(FIndex).FParamType := pfNumber;
      PE_PF_CURRENCY  : ListItem(FIndex).FParamType := pfCurrency;
      PE_PF_BOOLEAN   : ListItem(FIndex).FParamType := pfBoolean;
      PE_PF_DATE      : ListItem(FIndex).FParamType := pfDate;
      PE_PF_STRING    : ListItem(FIndex).FParamType := pfString;
      PE_PF_DATETIME  : ListItem(FIndex).FParamType := pfDateTime;
      PE_PF_TIME      : ListItem(FIndex).FParamType := pfTime;
      PE_PF_INTEGER   : ListItem(FIndex).FParamType := pfInteger;
      PE_PF_COLOR     : ListItem(FIndex).FParamType := pfColor;
      PE_PF_CHAR      : ListItem(FIndex).FParamType := pfChar;
      PE_PF_LONG      : ListItem(FIndex).FParamType := pfLong;
      PE_PF_NOVALUE   : ListItem(FIndex).FParamType := pfNoValue;
    end;

    {Set ValueInfo type to ParameterInfo type}
    ValueInfo.ValueType := ParameterInfo.valueType;

    {Default Value}
    {Put DefaultValue in ValueInfo structure}
    Cr.SetDLLHandle;
    if not PEConvertPFInfoToVInfo(ParameterInfo.DefaultValue,
      ValueInfo.ValueType, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Retrieve> ParamFields[' +
         IntToStr(nParam) + '] <PEConvertPFInfoToVInfo - DefaultValue>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    ListItem(FIndex).FDefaultValue := ValueInfoToStr(ValueInfo);
    ListItem(FIndex).FValue := ListItem(FIndex).FDefaultValue;

    {Current Value}
    {Put CurrentValue in ValueInfo structure}
    Cr.SetDLLHandle;
    if not PEConvertPFInfoToVInfo(ParameterInfo.CurrentValue,
      ValueInfo.ValueType, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Retrieve> ParamFields[' +
         IntToStr(nParam) + '] <PEConvertPFInfoToVInfo - CurrentValue>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    ListItem(FIndex).FCurrentValue := ValueInfoToStr(ValueInfo);

    {SCR 7 features}
    if Cr.FVersion.FMajor > 6 then
    begin
      {Added SCR 7 properties to PEParameterFieldInfo structure}
      {MandatoryPrompt: ValueLimit}
      ListItem(FIndex).FValueLimit := cDefault;
      case ParameterInfo.isLimited of
        0: ListItem(FIndex).FValueLimit := cFalse;
        1: ListItem(FIndex).FValueLimit := cTrue;
      end;

      {Min and Max Size}
      if ParameterInfo.isLimited = 1 then
      begin
        Cr.SetDLLHandle;
        if not PEGetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
          ParameterInfo.ReportName, minValueInfo, maxValueInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Retrieve> ParamFields[' +
             IntToStr(nParam) + '] <PEGetParameterMinMaxValue>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        case ParameterInfo.valueType of
          PE_PF_NUMBER,
          PE_PF_CURRENCY :
            begin
              ListItem(FIndex).FValueMin := ValueInfoToStr(minValueInfo);
              ListItem(FIndex).FValueMax := ValueInfoToStr(maxValueInfo);
            end;
          PE_PF_STRING   :
            begin
              ListItem(FIndex).FValueMin := IntToStr(minValueInfo.viInteger);
              ListItem(FIndex).FValueMax := IntToStr(maxValueInfo.viInteger);
            end;
          PE_PF_DATE,
          PE_PF_DATETIME,
          PE_PF_TIME     :
            begin
              ListItem(FIndex).FValueMin := ValueInfoToStr(minValueInfo);
              ListItem(FIndex).FValueMax := ValueInfoToStr(maxValueInfo);
            end;
        end;
      end
      else
      begin
        case ParameterInfo.valueType of
          {Copy DefaultValue}
          PE_PF_NUMBER,
          PE_PF_CURRENCY,
          PE_PF_DATE,
          PE_PF_DATETIME,
          PE_PF_TIME     :
            begin
              ListItem(FIndex).FValueMin := ListItem(FIndex).FValue;
              ListItem(FIndex).FValueMax := ListItem(FIndex).FValue;
            end;
          {Use zero}
          PE_PF_STRING :
            begin
              ListItem(FIndex).FValueMin := '0';
              ListItem(FIndex).FValueMax := '0';
            end;
        end;
      end;

      {EditMask}
      ListItem(FIndex).FEditMask := String(ParameterInfo.EditMask);

      {Parameter Type (ParamSource)}
      Cr.SetDLLHandle;
      nType := PEGetNthParameterType(Cr.FPrintJob, nParam);
      if nType = -1 then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Retrieve> ParamFields[' +
             IntToStr(nParam) + '] <PEGetNthParameterType>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      ListItem(FIndex).FParamSource := psReport;
      case nType of
        PE_PO_REPORT     : ListItem(FIndex).FParamSource := psReport;
        PE_PO_STOREDPROC : ListItem(FIndex).FParamSource := psStoredProc;
        PE_PO_QUERY      : ListItem(FIndex).FParamSource := psQuery;
      end;

      {Parameter Field Info}
      ListItem(FIndex).FInfo.Retrieve;

      {Parameter Field Ranges}
      if ListItem(FIndex).FInfo.FValueType = vtRanges then
        ListItem(FIndex).FRanges.Retrieve;
    end;
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ RetrieveValues method                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFields.RetrieveValues: boolean;
var
  ValueInfo : PEValueInfo;
  nValues   : smallint;
  nValue    : smallint;
  sPF, sRPT : string;
  hValue    : HWnd;
  ValueLen  : smallint;
  pValue    : PChar;
  PLOption  : PEParameterPickListOption;
begin
  Result := False;
  {SCR 7 only}
  if Cr.FVersion.FMajor < 7 then
    Exit;
  {No Parameter Fields retrieved}
  if FIndex = -1 then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  sPF := ListItem(FIndex).FName;
  sRPT := ListItem(FIndex).FReportName;

  {Clear DefaultValues and PickLists}
  ListItem(FIndex).FDList.Clear;
  ListItem(FIndex).FPList.Clear;

  {Retrieve Parameter Field DefaultValues}
  Cr.SetDLLHandle;
  nValues := PEGetNParameterDefaultValues(Cr.FPrintJob, PChar(sPF),
    PChar(sRPT));
  if nValues = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
         IntToStr(FIndex) + '] <PEGetNParameterDefaultValues>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through Default Values}
  for nValue := 0 to (nValues - 1) do
  begin
    {Default Value item}
    Cr.SetDLLHandle;
    if not PEGetNthParameterDefaultValue(Cr.FPrintJob, PChar(sPF),
      PChar(sRPT), nValue, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
         IntToStr(FIndex) + '] <PEGetNthParameterDefaultValue>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    ListItem(FIndex).FDList.Add(ValueInfoToStr(ValueInfo));

    {Picklist ValueDescriptions}
    Cr.SetDLLHandle;
    if not PEGetNthParameterValueDescription(Cr.FPrintJob, PChar(sPF),
      PChar(sRPT), nValue, hValue, ValueLen) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
         IntToStr(FIndex) + '] <PEGetNthParameterValueDescription>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get PickList string}
    pValue := StrAlloc(ValueLen);
    Cr.SetDLLHandle;
    if not PEGetHandleString(hValue, pValue, ValueLen) then
    begin
      StrDispose(pValue);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
         IntToStr(FIndex) + '] <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    ListItem(FIndex).FPList.Add(String(pValue));
    StrDispose(pValue);
  end;

  {Retrieve Parameter PickList Options}
  Cr.SetDLLHandle;
  if not PEGetParameterPickListOption(Cr.FPrintJob, PChar(sPF),
    PChar(sRPT), PLOption) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
         IntToStr(FIndex) + '] <PEGetParameterPickListOption>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  ListItem(FIndex).FPLDescriptionOnly := cDefault;
  case PLOption.showDescOnly of
    0: ListItem(FIndex).FPLDescriptionOnly := cFalse;
    1: ListItem(FIndex).FPLDescriptionOnly := cTrue;
  end;

  ListItem(FIndex).FPLSortMethod := psmDefaultSort;
  case PLOption.sortMethod of
    PE_OR_NO_SORT                 : ListItem(FIndex).FPLSortMethod := psmNoSort;
    PE_OR_ALPHANUMERIC_ASCENDING  : ListItem(FIndex).FPLSortMethod := psmAlphaNumericAscending;
    PE_OR_ALPHANUMERIC_DESCENDING : ListItem(FIndex).FPLSortMethod := psmAlphaNumericDescending;
    PE_OR_NUMERIC_ASCENDING       : ListItem(FIndex).FPLSortMethod := psmNumericAscending;
    PE_OR_NUMERIC_DESCENDING      : ListItem(FIndex).FPLSortMethod := psmNumericDescending;
  end;

  ListItem(FIndex).FPLSortByDescription := cDefault;
  case PLOption.sortBasedOnDesc of
    0: ListItem(FIndex).FPLSortByDescription := cFalse;
    1: ListItem(FIndex).FPLSortByDescription := cTrue;
  end;

  {Retrieve Parameter Field CurrentValues/Ranges}
  if ListItem(FIndex).FInfo.FValueType = vtDiscrete then
  begin
    ListItem(FIndex).FCList.Clear;
    {Retrieve Values}
    Cr.SetDLLHandle;
    nValues := PEGetNParameterCurrentValues(Cr.FPrintJob, PChar(sPF),
      PChar(sRPT));
    if nValues = -1 then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
           IntToStr(FIndex) + '] <PEGetNParameterCurrentValues>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    for nValue := 0 to (nValues - 1) do
    begin
      Cr.SetDLLHandle;
      if not PEGetNthParameterCurrentValue(Cr.FPrintJob, PChar(sPF),
        PChar(sRPT), nValue, ValueInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<RetrieveValues> ParamFields[' +
           IntToStr(FIndex) + '] <PEGetNthParameterCurrentValue>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      ListItem(FIndex).FCList.Add(ValueInfoToStr(ValueInfo));
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeParamFields.Send : boolean;
var
  ParameterInfo    : PEParameterFieldInfo;
  ValueInfo        : PEValueInfo;
  nIndex, nIndex2  : smallint;
  nParams          : smallint;
  ParamNames       : TStringList;
  nParam           : smallint;
  strValue         : string;
  strPrompt        : string;
  bSetCurrent      : boolean;
  sTmp, sTmp2      : string;
  Changed          : boolean;
  {SCR 7}
  nValues          : smallint;
  nValue           : smallint;
  minValueInfo     : PEValueInfo;
  maxValueInfo     : PEValueInfo;
  fTmp, fTmp2      : Double;
  wTmp             : Word;
  nTmp, nTmp2      : smallint;
  i                : integer;
  rptValues1       : TCrpeString;
  rptPLValues      : TCrpeString;
  cntValues        : smallint;
  bShowDialog      : Bool;
  dt1, dt2         : TDateTime;
  hValue           : HWnd;
  ValueLen         : smallint;
  pValue           : PChar;
  rptPLOption      : PEParameterPickListOption;

  function GetParameterNumber(slNames: TStringList; PName, RptName: string;
    vclIndex: integer): integer;
  var
    n : integer;
    s : string;
  begin
    Result := -1;
    s := PName + RptName;
    for n := 0 to slNames.Count - 1 do
    begin
      {if we find a match...}
      if s = slNames[n] then
      begin
        {if another match was already found...}
        if Result > -1 then
        begin
          {if the index equals vclIndex, assume this is the correct one;
           this is to account for Reports that have Subreports with the
           same names and Parameters with the same names; if the Parameters
           were Retrieved, the index order will tell the Parameters apart}
          if n = vclIndex then
            Result := n;
        end
        else
          Result := n;
      end;
    end;
  end;

begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Get the number of Parameter Fields}
  Cr.SetDLLHandle;
  nParams := PEGetNParameterFields(Cr.FPrintJob);
  if nParams = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        '<Send> ParamFields <PEGetNParameterFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp stringlist}
  ParamNames := TStringList.Create;

  {Loop through to get Parameter Names}
  for nIndex := 0 to (nParams - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthParameterField(Cr.FPrintJob, nIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          '<Send> ParamFields[' + IntToStr(nIndex) + '] <PEGetNthParameterField>') of
        cFalse   : Continue;
        cTrue    : begin
            ParamNames.Free;
            Abort;
          end;
        cDefault : begin
            ParamNames.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;
    ParamNames.Add(String(ParameterInfo.Name) + String(ParameterInfo.ReportName));
  end;

  {Store the current Index}
  nIndex := FIndex;

  {Turn off the Prompt Dialog: only turn on if needed}
  if Cr.FVersion.FMajor > 6 then
  begin
    {Get the Current setting}
    Cr.SetDLLHandle;
    bShowDialog := PEGetAllowPromptDialog(Cr.FPrintJob);
    if bShowDialog <> False then
    begin
      Cr.SetDLLHandle;
      bShowDialog := Bool(False);
      if not PESetAllowPromptDialog(Cr.FPrintJob, bShowDialog) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'ParamFields.Send <PESetAllowPromptDialog>') of
          cFalse   : Exit;
          cTrue    :
            begin
              ParamNames.Free;
              Abort;
            end;
          cDefault :
            begin
              ParamNames.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;
    end;
  end; {Turn off Prompt Dialog}

  try
    {Loop through the Parameters that were set}
    for i := 0 to (Count - 1) do
    begin
      {Update the FIndex for Ranges and Info subclass routines}
      FIndex := i;
      Changed := False;
      {Check Parameter name}
      if IsStrEmpty(ListItem(i).FName) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_PARAMETER_NAME,
            '<Send> ParamFields[' + IntToStr(i) + '] = ' + ListItem(i).FName) of
          cFalse   : Continue;
          cTrue    :
            begin
              ParamNames.Free;
              Abort;
            end;
          cDefault :
            begin
              ParamNames.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;
      {Get the actual Parameter number}
      nParam := GetParameterNumber(ParamNames, ListItem(i).FName,
        ListItem(i).FReportName, i);
      if nParam = -1 then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_PARAMETER_NAME,
            '<Send> ParamFields[' + IntToStr(i) + '] = ' + ListItem(i).FName) of
          cFalse   : Continue;
          cTrue    : begin
              ParamNames.Free;
              Abort;
            end;
          cDefault : begin
              ParamNames.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Get the Parameter Field from the Report}
      Cr.SetDLLHandle;
      if not PEGetNthParameterField(Cr.FPrintJob, nParam, ParameterInfo) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
          IntToStr(i) + '] <PEGetNthParameterField>') of
          cFalse   : Continue;
          cTrue    : begin
              ParamNames.Free;
              Abort;
            end;
          cDefault : begin
              ParamNames.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {ParameterInfo requires SCR7+}
      if Cr.FVersion.FMajor > 6 then
        {Send Parameter Field Info}
        ListItem(i).FInfo.Send;

      {Parameter Prompt Value}
      strPrompt := String(ParameterInfo.Prompt);
      if CompareStr(strPrompt, ListItem(i).FPrompt) <> 0 then
      begin
        StrCopy(ParameterInfo.Prompt, PChar(ListItem(i).FPrompt));
        Changed := True;
      end;

      {ShowDialog Flag}
      bSetCurrent := False;
      if ParameterInfo.CurrentValueSet > 0 then
        bSetCurrent := True;
      if bSetCurrent = ListItem(i).FShowDialog then
      begin
        bSetCurrent := not ListItem(i).FShowDialog;
        Changed := True;
      end;

      {Set the ValueType}
      ValueInfo.ValueType := ParameterInfo.valueType;

      {Set Current Value}
      if bSetCurrent then
      begin
        {Check for nulls}
        if String(ParameterInfo.CurrentValue) = '' then
          sTmp := ''
        else
        begin
          {Put CurrentValue in ValueInfo structure}
          Cr.SetDLLHandle;
          if not PEConvertPFInfoToVInfo(ParameterInfo.CurrentValue,
            ValueInfo.ValueType, ValueInfo) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
               IntToStr(i) + '] <PEConvertPFInfoToVInfo>') of
              cFalse   : Continue;
              cTrue    :
                begin
                  ParamNames.Free;
                  Abort;
                end;
              cDefault :
                begin
                  ParamNames.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          sTmp := ValueInfoToStr(ValueInfo);
        end;
      end
      {Set Default Value}
      else
      begin
        {Check for nulls}
        if String(ParameterInfo.DefaultValue) = '' then
          sTmp := ''
        else
        begin
          {Get the Report Parameter Default Value}
          Cr.SetDLLHandle;
          if not PEConvertPFInfoToVInfo(ParameterInfo.DefaultValue,
            ValueInfo.ValueType, ValueInfo) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
              IntToStr(i) + '] <PEConvertPFInfoToVInfo>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          sTmp := ValueInfoToStr(ValueInfo);
        end;
      end;

      {VCL Value: the actual Value being passed}
      strValue := ListItem(i).FValue;
      {Ignore blanks}
      if strValue <> '' then
      begin
        {Check for intentional Null}
        if LowerCase(strValue) = CrEmptyStr then
        begin
          if strValue <> sTmp then
            Changed := True;
        end
        else
        begin
          {Compare Values: Date}
          case ValueInfo.valueType of
            PE_PF_DATE :
              begin
                dt1 := Now;
                dt2 := Now;
                CrStrToDate(strValue, dt1);
                CrStrToDate(sTmp, dt2);
                if dt1 <> dt2 then
                  Changed := True;
              end;
            PE_PF_DATETIME :
              begin
                dt1 := Now;
                dt2 := Now;
                CrStrToDateTime(strValue, dt1);
                CrStrToDateTime(sTmp, dt2);
                if dt1 <> dt2 then
                  Changed := True;
              end;
            PE_PF_TIME :
              begin
                dt1 := Now;
                dt2 := Now;
                CrStrToTime(strValue, dt1);
                CrStrToTime(sTmp, dt2);
                if dt1 <> dt2 then
                  Changed := True;
              end;
            PE_PF_NUMBER   :
              begin
                if CompareStr(strValue, sTmp) <> 0 then
                    Changed := True;
              end;
            PE_PF_CURRENCY :
              begin
                if CompareStr(strValue, sTmp) <> 0 then
                  Changed := True;
              end;
            PE_PF_BOOLEAN  :
              begin
                if CrStrToBoolean(strValue) <> CrStrToBoolean(sTmp) then
                  Changed := True;
              end;
            PE_PF_STRING   :
              begin
                if CompareStr(strValue, sTmp) <> 0 then
                  Changed := True;
              end;
          end;
        end;
      end;

      {Compare Values}
      if Changed then
      begin
        if strValue <> '' then
        begin
          if LowerCase(strValue) <> CrEmptyStr then
          begin
            {Try to convert VCL Value to PEValueInfo}
            if not StrToValueInfo(strValue, ValueInfo) then
            begin
              Result := False;
              sTmp := ECRPE_PARAMETER_STRING;
              case ValueInfo.valueType of
                PE_PF_NUMBER   : sTmp := ECRPE_PARAMETER_NUMBER;
                PE_PF_CURRENCY : sTmp := ECRPE_PARAMETER_CURRENCY;
                PE_PF_BOOLEAN  : sTmp := ECRPE_PARAMETER_BOOLEAN;
                PE_PF_DATE     : sTmp := ECRPE_PARAMETER_DATE;
                PE_PF_STRING   : sTmp := ECRPE_PARAMETER_STRING;
                PE_PF_DATETIME : sTmp := ECRPE_PARAMETER_DATETIME;
                PE_PF_TIME     : sTmp := ECRPE_PARAMETER_TIME;
              end;
              case Cr.GetErrorMsg(0,errNoOption,errVCL,sTmp,
                '<Send> ParamFields[' + IntToStr(i) + '] <StrToValueInfo>') of
                cFalse   : Continue;
                cTrue    :
                  begin
                    ParamNames.Free;
                    Abort;
                  end;
                cDefault :
                  begin
                    ParamNames.Free;
                    raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                  end;
              end;
            end;
          end;
        end;
      end;

      {SCR 7 features}
      if Cr.FVersion.FMajor > 6 then
      begin
        {MandatoryPrompt}
        wTmp := Ord(ListItem(i).FValueLimit);
        if wTmp <> Word(Ord(cDefault)) then
        begin
          if wTmp <> ParameterInfo.isLimited then
          begin
            ParameterInfo.isLimited := wTmp;
            Changed := True;
          end;
        end;
        {EditMask}
        sTmp := String(ParameterInfo.EditMask);
        if CompareStr(ListItem(i).FEditMask, sTmp) <> 0 then
        begin
          StrCopy(ParameterInfo.EditMask, PChar(ListItem(i).FEditMask));
          Changed := True;
        end;

        {Prompting Dialog}
        {If any Parameters need it, turn on Prompting Dialog}
        bShowDialog := Bool(True);
        if (ListItem(i).FShowDialog = True) then
        begin
          Cr.SetDLLHandle;
          if not PESetAllowPromptDialog(Cr.FPrintJob, bShowDialog) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
               IntToStr(i) + '] <PESetAllowPromptDialog>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;  {SCR 7: SetAllowPromptingDialog}
        end;

        {Should only set ValueMin/ValueMax if ValueLimit on}
        if ParameterInfo.isLimited = 1 then
        begin
          Cr.SetDLLHandle;
          if not PEGetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
            ParameterInfo.ReportName, minValueInfo, maxValueInfo) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
               IntToStr(i) + '] <PEGetParameterMinMaxValue>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          case ParameterInfo.valueType of
            PE_PF_NUMBER,
            PE_PF_CURRENCY :
              begin
                sTmp := ValueInfoToStr(minValueInfo);
                sTmp2 := ValueInfoToStr(maxValueInfo);
              end;
            PE_PF_STRING   :
              begin
                sTmp := IntToStr(minValueInfo.viInteger);
                sTmp2 := IntToStr(maxValueInfo.viInteger);
              end;
            PE_PF_DATE,
            PE_PF_DATETIME,
            PE_PF_TIME     :
              begin
                sTmp := ValueInfoToStr(minValueInfo);
                sTmp2 := ValueInfoToStr(maxValueInfo);
              end;
          end;

          {Min/Max}
          case ParameterInfo.valueType of
            PE_PF_NUMBER,
            PE_PF_CURRENCY :
              begin
                {MinSize}
                try
                  fTmp := StrToFloat(ListItem(i).FValueMin);
                except
                  fTmp := 0;
                end;
                try
                  fTmp2 := StrToFloat(sTmp);
                except
                  fTmp2 := 0;
                end;
                if fTmp <> fTmp2 then
                begin
                  ParameterInfo.MinSize := fTmp;
                  Changed := True;
                end;
                {MaxSize}
                try
                  fTmp := StrToFloat(ListItem(i).FValueMax);
                except
                  fTmp := 0;
                end;
                try
                  fTmp2 := StrToFloat(sTmp2);
                except
                  fTmp2 := 0;
                end;
                if fTmp <> fTmp2 then
                begin
                  ParameterInfo.MaxSize := fTmp;
                  Changed := True;
                end;
              end;
            PE_PF_STRING :
              begin
                {MinSize}
                try
                  nTmp := StrToInt(ListItem(i).FValueMin);
                except
                  nTmp := 0;
                end;
                try
                  nTmp2 := StrToInt(sTmp);
                except
                  nTmp2 := 0;
                end;
                if nTmp <> nTmp2 then
                begin
                  ParameterInfo.MinSize := nTmp;
                  Changed := True;
                end;
                {MaxSize}
                try
                  nTmp := StrToInt(ListItem(i).FValueMax);
                except
                  nTmp := 0;
                end;
                try
                  nTmp2 := StrToInt(sTmp2);
                except
                  nTmp2 := 0;
                end;
                if nTmp <> nTmp2 then
                begin
                  ParameterInfo.MaxSize := nTmp;
                  Changed := True;
                end;
              end;
            PE_PF_DATE,
            PE_PF_DATETIME,
            PE_PF_TIME :
              begin
                if (CompareStr(ListItem(i).FValueMin, sTmp) <> 0) or
                   (CompareStr(ListItem(i).FValueMax, sTmp2) <> 0) then
                begin
                  Changed := True;
                  {Convert MinValue to ValueInfo}
                  minValueInfo.ValueType := ParameterInfo.valueType;
                  if not StrToValueInfo(ListItem(i).FValueMin, minValueInfo) then
                  begin
                    Result := False;
                    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                       '<Send> ParamFields[' + IntToStr(i) + '] <StrToValueInfo - ValueMin>') of
                      cFalse   : Continue;
                      cTrue    : begin
                          ParamNames.Free;
                          Abort;
                        end;
                      cDefault : begin
                          ParamNames.Free;
                          raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                        end;
                    end;
                  end;
                  {Convert MaxValue to ValueInfo}
                  maxValueInfo.ValueType := ParameterInfo.valueType;
                  if not StrToValueInfo(ListItem(i).FValueMax, maxValueInfo) then
                  begin
                    Result := False;
                    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                       '<Send> ParamFields[' + IntToStr(i) + '] <StrToValueInfo - ValueMax>') of
                      cFalse   : Continue;
                      cTrue    : begin
                          ParamNames.Free;
                          Abort;
                        end;
                      cDefault : begin
                          ParamNames.Free;
                          raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                        end;
                    end;
                  end;
                  Cr.SetDLLHandle;
                  if not PESetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
                    ParameterInfo.reportName, minValueInfo, maxValueInfo) then
                  begin
                    Result := False;
                    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                      '<Send> ParamFields[' + IntToStr(i) + '] <PESetParameterMinMaxValue>') of
                      cFalse   : Continue;
                      cTrue    : begin
                          ParamNames.Free;
                          Abort;
                        end;
                      cDefault : begin
                          ParamNames.Free;
                          raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                        end;
                    end;
                  end;
                end; {if Time changed}
              end; {Value Type: Time}
          end; {Min/Max value type}
        end; {Set ValueMin/ValueMax}
      end; {SCR 7 only}

      if Changed then
      begin
        {Check if the Default or Current values are being changed}
        {Current Value: pass in a new value, no parameter prompt}
        if bSetCurrent then
        begin
          if strValue <> '' then
          begin
            if LowerCase(strValue) = CrEmptyStr then
              StrCopy(ParameterInfo.CurrentValue, '')
            else
            begin
              {Convert ValueInfo to ParamFieldInfo CurrentValue}
              Cr.SetDLLHandle;
              if not PEConvertVInfoToPFInfo(ValueInfo, ValueInfo.ValueType,
                ParameterInfo.CurrentValue) then
              begin
                Result := False;
                case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                   IntToStr(i) + '] <PEConvertVInfoToPFInfo - CurrentValue>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
            end;
          end;
          ParameterInfo.DefaultValueSet := 0;
          ParameterInfo.CurrentValueSet := 1;
        end
        {Default Value: change the prompt, but still prompt}
        else
        begin
          if strValue <> '' then
          begin
            if LowerCase(strValue) = CrEmptyStr then
              StrCopy(ParameterInfo.DefaultValue, '')
            else
            begin
              {Convert ValueInfo to ParamFieldInfo Default Value}
              Cr.SetDLLHandle;
              if not PEConvertVInfoToPFInfo(ValueInfo, ValueInfo.ValueType,
                ParameterInfo.DefaultValue) then
              begin
                Result := False;
                case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                   IntToStr(i) + '] <PEConvertVInfoToPFInfo - DefaultValue>') of
                  cFalse   : Continue;
                  cTrue    :
                    begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault :
                    begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
            end;
          end;
          ParameterInfo.DefaultValueSet := 1;
          ParameterInfo.CurrentValueSet := 0;
        end;

        {Set the Parameter field}
        Cr.SetDLLHandle;
        if not PESetNthParameterField(Cr.FPrintJob, nParam, ParameterInfo) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
             IntToStr(i) + '] <PESetNthParameterField>') of
            cFalse   : Continue;
            cTrue    : begin
                ParamNames.Free;
                Abort;
              end;
            cDefault : begin
                ParamNames.Free;
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;
        Result := True;
      end; {Changed = True}

      {SCR 7 feature: Parameter Field DefaultValues}
      if (Cr.FVersion.FMajor > 6) and (ListItem(i).FShowDialog = True) then
      begin
        {If there are none, do not pass in}
        if ListItem(i).FDList.Count = 0 then
          Continue;
        Changed := False;

        {Check for CrEmptyStr}
        {Clear all the Default Values from the Report}
        if (ListItem(i).FDList.Count = 1) and (LowerCase(ListItem(i).FDList[0]) = CrEmptyStr) then
        begin
          {Get the number of Default Values}
          Cr.SetDLLHandle;
          nValues := PEGetNParameterDefaultValues(Cr.FPrintJob,
            ParameterInfo.Name, ParameterInfo.ReportName);
          if nValues = -1 then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
               IntToStr(i) + '] <PEGetNParameterDefaultValues>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          for nValue := (nValues - 1) downto 0 do
          begin
            Cr.SetDLLHandle;
            if not PEDeleteNthParameterDefaultValue(Cr.FPrintJob,
              ParameterInfo.Name, ParameterInfo.ReportName, nValue) then
            begin
              Result := False;
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                 IntToStr(i) + '] <PEDeleteNthParameterDefaultValue>') of
                cFalse   : Continue;
                cTrue    : begin
                    ParamNames.Free;
                    Abort;
                  end;
                cDefault : begin
                    ParamNames.Free;
                    raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                  end;
              end;
            end;
          end;
          Continue;
        end;

        {Retrieve Report Values}
        rptValues1 := TCrpeString.Create;
        rptPLValues := TCrpeString.Create;
        {Get Number of DefaultValues}
        Cr.SetDLLHandle;
        nValues := PEGetNParameterDefaultValues(Cr.FPrintJob,
          ParameterInfo.Name, ParameterInfo.ReportName);
        if nValues = -1 then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
             IntToStr(i) + '] <PEGetNParameterDefaultValues>') of
            cFalse   : Continue;
            cTrue    : begin
                ParamNames.Free;
                rptValues1.Free;
                rptPLValues.Free;
                Abort;
              end;
            cDefault : begin
                ParamNames.Free;
                rptValues1.Free;
                rptPLValues.Free;
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;
        {Loop through DefaultValues}
        for nValue := 0 to (nValues - 1) do
        begin
          Cr.SetDLLHandle;
          if not PEGetNthParameterDefaultValue(Cr.FPrintJob, ParameterInfo.Name,
            ParameterInfo.ReportName, nValue, ValueInfo) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
               IntToStr(i) + '] <PEGetNthParameterDefaultValue>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  rptPLValues.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  rptPLValues.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          rptValues1.Add(ValueInfoToStr(ValueInfo));

          {Picklist ValueDescriptions}
          Cr.SetDLLHandle;
          if not PEGetNthParameterValueDescription(Cr.FPrintJob, ParameterInfo.Name,
            ParameterInfo.ReportName, nValue, hValue, ValueLen) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','ParamFields[' +
               IntToStr(FIndex) + '].Send <PEGetNthParameterValueDescription>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  rptPLValues.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  rptPLValues.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;

          {Get PickList string}
          pValue := StrAlloc(ValueLen);
          Cr.SetDLLHandle;
          if not PEGetHandleString(hValue, pValue, ValueLen) then
          begin
            StrDispose(pValue);
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','ParamFields[' +
               IntToStr(FIndex) + '].Send <PEGetHandleString>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  rptPLValues.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  rptPLValues.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          rptPLValues.Add(String(pValue));
          StrDispose(pValue);
        end;

        {Retrieve Parameter PickList Options}
        Cr.SetDLLHandle;
        if not PEGetParameterPickListOption(Cr.FPrintJob, ParameterInfo.Name,
          ParameterInfo.ReportName, rptPLOption) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','ParamFields[' +
               IntToStr(FIndex) + '].Send <PEGetParameterPickListOption>') of
            cFalse   : Continue;
            cTrue    : begin
                ParamNames.Free;
                rptValues1.Free;
                rptPLValues.Free;
                Abort;
              end;
            cDefault : begin
                ParamNames.Free;
                rptValues1.Free;
                rptPLValues.Free;
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;

        {Compare for changes}
        if ListItem(i).FDList.Count <> rptValues1.Count then
          Changed := True
        else
        begin
          for nIndex2 := 0 to ListItem(i).FDList.Count - 1 do
          begin
            {Compare DefaultValue strings}
            if CompareStr(ListItem(i).FDList[nIndex2], rptValues1[nIndex2]) <> 0 then
            begin
              Changed := True;
              Break;
            end;
            {Compare PickList strings}
            if (nIndex2 < ListItem(i).FPList.Count) and (nIndex2 < rptPLValues.Count) then
            begin
              if CompareStr(ListItem(i).FPList[nIndex2], rptPLValues[nIndex2]) <> 0 then
              begin
                Changed := True;
                Break;
              end;
            end;
          end;
        end;
        cntValues := rptValues1.Count; {Number of Report Values}
        rptValues1.Free;
        rptPLValues.Free;
        {Find the largest list}
        if cntValues > ListItem(i).FDList.Count then
          nTmp := cntValues
        else
          nTmp := ListItem(i).FDList.Count;

        {Check PickList options for changes}
        if ListItem(i).FPLDescriptionOnly <> cDefault then
        begin
          if Ord(ListItem(i).FPLDescriptionOnly) <> rptPLOption.showDescOnly then
          begin
            rptPLOption.showDescOnly := Ord(ListItem(i).FPLDescriptionOnly);
            Changed := True;
          end;
        end;
        if ListItem(i).FPLSortByDescription <> cDefault then
        begin
          if Ord(ListItem(i).FPLSortByDescription) <> rptPLOption.sortBasedOnDesc then
          begin
            rptPLOption.sortBasedOnDesc := Ord(ListItem(i).FPLSortByDescription);
            Changed := True;
          end;
        end;
        if ListItem(i).FPLSortMethod <> psmDefaultSort then
        begin
          if Ord(ListItem(i).FPLSortMethod) <> rptPLOption.sortMethod then
          begin
            rptPLOption.sortMethod := Ord(ListItem(i).FPLSortMethod);
            Changed := True;
          end;
        end;

        {DefaultValues changed}
        if Changed then
        begin
          {PickList Options}
          Cr.SetDLLHandle;
          if not PESetParameterPickListOption(Cr.FPrintJob, ParameterInfo.Name,
            ParameterInfo.ReportName, rptPLOption) then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','ParamFields[' +
               IntToStr(i) + '].Send <PESetParameterPickListOption>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          {Loop through the lists}
          for nIndex2 := 0 to (nTmp - 1) do
          begin
            {If the index is greater than the number of
             actual Report Values, add a new one}
            if nIndex2 >= cntValues then
            begin
              ValueInfo.ValueType := ParameterInfo.valueType;
              if not StrToValueInfo (ListItem(i).FDList[nIndex2], ValueInfo) then
              begin
                Result := False;
                case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                   '<Send> ParamFields[' + IntToStr(i) + '] <StrToValueInfo - DefaultValues>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
              Cr.SetDLLHandle;
              if not PEAddParameterDefaultValue(Cr.FPrintJob, ParameterInfo.Name,
                ParameterInfo.ReportName, ValueInfo) then
              begin
                Result := False;
                case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                   IntToStr(i) + '] <PEAddParameterDefaultValue>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
              if nIndex2 < ListItem(i).FPList.Count then
              begin
                Cr.SetDLLHandle;
                if not PESetNthParameterValueDescription(Cr.FPrintJob, ParameterInfo.Name,
                  ParameterInfo.ReportName, nIndex2, PChar(ListItem(i).FPList[nIndex2])) then
                begin
                  Result := False;
                  case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','ParamFields[' +
                     IntToStr(i) + '].Send <PESetNthParameterValueDescription>') of
                    cFalse   : Continue;
                    cTrue    : begin
                        ParamNames.Free;
                        Abort;
                      end;
                    cDefault : begin
                        ParamNames.Free;
                        raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                      end;
                  end;
                end;
              end;
            end
            {If the index is greater than the number of
             actual VCL DefaultValues, delete a value from the Report}
            else if (nIndex2 >= ListItem(i).FDList.Count) then
            begin
              Cr.SetDLLHandle;
              if not PEDeleteNthParameterDefaultValue(Cr.FPrintJob,
                ParameterInfo.Name, ParameterInfo.ReportName, nIndex2) then
              begin
                Result := False;
                case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                   IntToStr(i) + '] <PEDeleteNthParameterDefaultValue>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
            end
            {No Added or deleted values, but some have changed}
            else
            begin
              ValueInfo.ValueType := ParameterInfo.valueType;
              if not StrToValueInfo (ListItem(i).FDList[nIndex2], ValueInfo) then
              begin
                Result := False;
                case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                    '<Send> ParamFields[' + IntToStr(i) + '] <StrToValueInfo - DefaultValues>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
              {DefaultValue}
              Cr.SetDLLHandle;
              if not PESetNthParameterDefaultValue(Cr.FPrintJob, ParameterInfo.Name,
                ParameterInfo.ReportName, nIndex2, ValueInfo) then
              begin
                Result := False;
                case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                   IntToStr(i) + '] <PESetNthParameterDefaultValue>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
              {PickList Value}
              if nIndex2 < ListItem(i).FPList.Count then
              begin
                Cr.SetDLLHandle;
                if not PESetNthParameterValueDescription(Cr.FPrintJob, ParameterInfo.Name,
                  ParameterInfo.ReportName, nIndex2, PChar(ListItem(i).FPList[nIndex2])) then
                begin
                  Result := False;
                  case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                     IntToStr(i) + '] <PESetNthParameterDefaultValue>') of
                    cFalse   : Continue;
                    cTrue    : begin
                        ParamNames.Free;
                        Abort;
                      end;
                    cDefault : begin
                        ParamNames.Free;
                        raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                      end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end; {DefaultValues}

      {SCR 7 feature: Parameter Field CurrentValues/Ranges}
      if (Cr.FVersion.FMajor > 6) and (ListItem(i).FShowDialog = False) then
      begin
        if Info.FValueType = vtDiscrete then
        begin
          {If there are none, do not pass in}
          ListItem(i).FCList.Text := RTrimList(ListItem(i).FCList);
          if ListItem(i).FCList.Count = 0 then
            Continue;

          Changed := False;

          {Get Report Parameter values}
          rptValues1 := TCrpeString.Create;
          {Retrieve Number of CurrentValues}
          Cr.SetDLLHandle;
          nValues := PEGetNParameterCurrentValues(Cr.FPrintJob,
            ParameterInfo.Name, ParameterInfo.ReportName);
          if nValues = -1 then
          begin
            Result := False;
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
               IntToStr(i) + '] <PEGetNParameterCurrentValues>') of
              cFalse   : Continue;
              cTrue    : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  Abort;
                end;
              cDefault : begin
                  ParamNames.Free;
                  rptValues1.Free;
                  raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                end;
            end;
          end;
          {Loop through and retrieve CurrentValues}
          for nValue := 0 to (nValues - 1) do
          begin
            Cr.SetDLLHandle;
            if not PEGetNthParameterCurrentValue(Cr.FPrintJob, ParameterInfo.Name,
              ParameterInfo.ReportName, nValue, ValueInfo) then
            begin
              Result := False;
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                 IntToStr(i) + '] <PEGetNthParameterCurrentValue>') of
                cFalse   : Continue;
                cTrue    : begin
                    ParamNames.Free;
                    rptValues1.Free;
                    Abort;
                  end;
                cDefault : begin
                    ParamNames.Free;
                    rptValues1.Free;
                    raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                  end;
              end;
            end;
            rptValues1.Add(ValueInfoToStr(ValueInfo));
          end;

          {Compare for changes}
          if ListItem(i).FCList.Count <> rptValues1.Count then
            Changed := True
          else
          begin
            for nIndex2 := 0 to ListItem(i).FCList.Count - 1 do
            begin
              if CompareStr(ListItem(i).FCList[nIndex2], rptValues1[nIndex2]) <> 0 then
              begin
                Changed := True;
                Break;
              end;
            end;
          end;
          rptValues1.Free;

          {CurrentValues changed}
          if Changed then
          begin
            {Clear Report CurrentValues}
            Cr.SetDLLHandle;
            if not PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob,
              ParameterInfo.Name, ParameterInfo.ReportName) then
            begin
              Result := False;
              case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
                '<Send> ParamFields[' + IntToStr(i) + '] <PEClearParameterCurrentValuesAndRanges>') of
                cFalse   : Continue;
                cTrue    : begin
                    ParamNames.Free;
                    Abort;
                  end;
                cDefault : begin
                    ParamNames.Free;
                    raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                  end;
              end;
            end;
            {Check for CrEmptyStr}
            if (ListItem(i).FCList.Count = 1) and (LowerCase(ListItem(i).FCList[0]) = CrEmptyStr) then
              Continue;  {Do not send in any new values}
            {Loop through the lists}
            for nIndex2 := 0 to (ListItem(i).FCList.Count - 1) do
            begin
              {Convert CurrentValue to ValueInfo}
              ValueInfo.ValueType := ParameterInfo.valueType;
              if not StrToValueInfo (ListItem(i).FCList[nIndex2], ValueInfo) then
              begin
                Result := False;
                case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                    '<Send> ParamFields[' + IntToStr(i) + '] <StrToValueInfo - CurrentValues>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
              {Add CurrentValue}
              Cr.SetDLLHandle;
              if not PEAddParameterCurrentValue(Cr.FPrintJob, ParameterInfo.Name,
                ParameterInfo.ReportName, ValueInfo) then
              begin
                Result := False;
                case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'','<Send> ParamFields[' +
                   IntToStr(i) + '] <PEAddParameterCurrentValue>') of
                  cFalse   : Continue;
                  cTrue    : begin
                      ParamNames.Free;
                      Abort;
                    end;
                  cDefault : begin
                      ParamNames.Free;
                      raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                    end;
                end;
              end;
            end;
          end; {CurrentValues Changed = True}
        end
        {ParamField Ranges}
        else
          ListItem(i).FRanges.Send;
      end; {SCR 7: CurrentValues or Ranges}
    end; {for loop: through ParamField items}
  finally
    ParamNames.Free;
    {Restore the Index}
    if nIndex < Count then
      FIndex := nIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetParameterName                                                 }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetName : TCrParamFieldName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write method SetParameterName                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetName(const Value: TCrParamFieldName);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOfName(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'ParamFields.Name := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetPrompt                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetPrompt : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPrompt;
end;
{------------------------------------------------------------------------------}
{ Write method SetPrompt                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetPrompt (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FPrompt := Value;
    {Check Length}
    if Length(ListItem(FIndex).FPrompt) > PE_PF_PROMPT_LEN then
      ListItem(FIndex).FPrompt := Copy(ListItem(FIndex).FPrompt, 1, PE_PF_PROMPT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetValue                                                         }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetValue : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FValue;
end;
{------------------------------------------------------------------------------}
{ Write method SetValue                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetValue (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FValue := Value;
    {Check Length}
    if Length(ListItem(FIndex).FValue) > PE_PF_VALUE_LEN then
      ListItem(FIndex).FValue := Copy(ListItem(FIndex).FValue, 1, PE_PF_VALUE_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetDefaultValue                                                  }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetDefaultValue : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDefaultValue;
end;
{------------------------------------------------------------------------------}
{ Write method SetDefaultValue                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetDefaultValue (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FDefaultValue := Value;
    {Check Length}
    if Length(ListItem(FIndex).FDefaultValue) > PE_PF_VALUE_LEN then
      ListItem(FIndex).FDefaultValue := Copy(ListItem(FIndex).FDefaultValue, 1, PE_PF_VALUE_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetCurrentValue                                                  }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetCurrentValue : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FCurrentValue;
end;
{------------------------------------------------------------------------------}
{ Write method SetCurrentValue                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetCurrentValue (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FCurrentValue := Value;
    {Check Length}
    if Length(ListItem(FIndex).FCurrentValue) > PE_PF_VALUE_LEN then
      ListItem(FIndex).FCurrentValue := Copy(ListItem(FIndex).FCurrentValue, 1, PE_PF_VALUE_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetShowDialog                                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetShowDialog : boolean;
begin
  Result := False;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FShowDialog;
end;
{------------------------------------------------------------------------------}
{ Write method SetShowDialog                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetShowDialog (const Value: boolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FShowDialog := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetParamType                                                     }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetParamType : TCrParamFieldType;
begin
  Result := pfString;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FParamType;
end;
{------------------------------------------------------------------------------}
{ Write method SetParamType                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetParamType (const Value: TCrParamFieldType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FParamType := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetReportName                                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetReportName : TCrParamFieldReportName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FReportName;
end;
{------------------------------------------------------------------------------}
{ Read method GetNeedsCurrentValue                                             }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetNeedsCurrentValue : boolean;
begin
  Result := True;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNeedsCurrentValue;
end;
{------------------------------------------------------------------------------}
{ Read method GetParamSource                                                   }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetParamSource : TCrParamFieldSource;
begin
  Result := psReport;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FParamSource;
end;
{------------------------------------------------------------------------------}
{ Write method SetParamSource                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetParamSource (const Value: TCrParamFieldSource);
begin
  {nothing: read-only}
end;
{------------------------------------------------------------------------------}
{ Read method GetValueLimit                                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetValueLimit : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FValueLimit;
end;
{------------------------------------------------------------------------------}
{ Write method SetValueLimit                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetValueLimit (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValueLimit := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetValueMin                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetValueMin : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FValueMin;
end;
{------------------------------------------------------------------------------}
{ Write method SetValueMin                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetValueMin (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValueMin := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetValueMax                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetValueMax : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FValueMax;
end;
{------------------------------------------------------------------------------}
{ Write method SetValueMax                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetValueMax (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValueMax := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetEditMask                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetEditMask : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FEditMask;
end;
{------------------------------------------------------------------------------}
{ Write method SetEditMask                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetEditMask (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FEditMask := Value;
    {Check Length}
    if Length(ListItem(FIndex).FEditMask) > PE_PF_EDITMASK_LEN then
      ListItem(FIndex).FEditMask := Copy(ListItem(FIndex).FEditMask, 1, PE_PF_EDITMASK_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetInfo                                                          }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetInfo : TCrpeParamFieldInfo;
begin
  Result := TempInfo;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FInfo;
end;
{------------------------------------------------------------------------------}
{ Write method SetInfo                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetInfo (const Value: TCrpeParamFieldInfo);
begin
  TempInfo.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FInfo.Assign(Value)
end;
{------------------------------------------------------------------------------}
{ Read method GetDefaultValues                                                 }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetDefaultValues : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDList;
end;
{------------------------------------------------------------------------------}
{ Write method SetDefaultValues                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetDefaultValues (const ListVar: TCrpeString);
begin
  sTemp.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDList.Assign(ListVar);
end;
{------------------------------------------------------------------------------}
{ Read method GetCurrentValues                                                 }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetCurrentValues : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FCList;
end;
{------------------------------------------------------------------------------}
{ Write method SetCurrentValues                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetCurrentValues (const ListVar: TCrpeString);
begin
  sTemp.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FCList.Assign(ListVar);
end;
{------------------------------------------------------------------------------}
{ Read method GetPickList                                                      }
{------------------------------------------------------------------------------}
function  TCrpeParamFields.GetPickList : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPList;
end;
{------------------------------------------------------------------------------}
{ Write method SetPickList                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetPickList (const ListVar: TCrpeString);
begin
  sTemp.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPList.Assign(ListVar);
end;
{------------------------------------------------------------------------------}
{ Read method GetPLDescriptionOnly                                             }
{------------------------------------------------------------------------------}
function  TCrpeParamFields.GetPLDescriptionOnly : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPLDescriptionOnly;
end;
{------------------------------------------------------------------------------}
{ Write method SetPLDescriptionOnly                                            }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetPLDescriptionOnly (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPLDescriptionOnly := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetPLSortMethod                                                  }
{------------------------------------------------------------------------------}
function  TCrpeParamFields.GetPLSortMethod : TCrPickListSortMethod;
begin
  Result := psmDefaultSort;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPLSortMethod;
end;
{------------------------------------------------------------------------------}
{ Write method SetPLSortMethod                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetPLSortMethod (const Value: TCrPickListSortMethod);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPLSortMethod := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetPLSortByDescription                                           }
{------------------------------------------------------------------------------}
function  TCrpeParamFields.GetPLSortByDescription : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPLSortByDescription;
end;
{------------------------------------------------------------------------------}
{ Write method SetPLSortByDescription                                          }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetPLSortByDescription (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPLSortByDescription := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetRanges                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetRanges : TCrpeParamFieldRanges;
begin
  Result := TempRanges;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FRanges;
end;
{------------------------------------------------------------------------------}
{ Write method SetRanges                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetRanges (const Value: TCrpeParamFieldRanges);
begin
  TempRanges.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FRanges.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsNumber                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetAsNumber : double;
var
  sTmp : string;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    sTmp := Trim(ListItem(FIndex).FValue);
    if sTmp = '' then
      sTmp := '0';
    Result := CrStrToFloating(sTmp);
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsNumber                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAsNumber (const Value: double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrFloatingToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsCurrency                                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetAsCurrency : Currency;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := CrStrToFloating(ListItem(FIndex).FValue)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsCurrency                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAsCurrency (const Value: Currency);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrFloatingToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsBoolean                                                     }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetAsBoolean : boolean;
begin
  Result := False;
  if IndexInRange(FIndex, FList.Count) then
    Result := CrStrToBoolean(ListItem(FIndex).FValue)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsBoolean                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAsBoolean (const Value: boolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrBooleanToStr(Value, False);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsDate                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetAsDate : TDateTime;
var
  dtTmp : TDateTime;
begin
  Result := Now;
  if IndexInRange(FIndex, FList.Count) then
  begin
    if not CrStrToDate(ListItem(FIndex).FValue, dtTmp) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_AS_DATE,
          'ParamFields[' + IntToStr(FIndex) + '] <' +
         ListItem(FIndex).FValue + '>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := dtTmp;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsDate                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAsDate (const Value: TDateTime);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrDateToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsDateTime                                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetAsDateTime : TDateTime;
var
  dtTmp : TDateTime;
begin
  Result := Now;
  if IndexInRange(FIndex, FList.Count) then
  begin
    if not CrStrToDateTime(ListItem(FIndex).FValue, dtTmp) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_AS_DATETIME,
         'ParamFields[' + IntToStr(FIndex) + '] <' + ListItem(FIndex).FValue + '>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := dtTmp;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsDateTime                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAsDateTime (const Value: TDateTime);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrDateTimeToStr(Value, False);
end;
{------------------------------------------------------------------------------}
{ Read method GetAsTime                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetAsTime : TDateTime;
var
  dtTmp : TDateTime;
begin
  Result := Now;
  if IndexInRange(FIndex, FList.Count) then
  begin
    if not CrStrToTime(ListItem(FIndex).FValue, dtTmp) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_AS_TIME,
         'ParamFields[' + IntToStr(FIndex) + '] <' +
         ListItem(FIndex).FValue + '>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := dtTmp;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(FIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Write method SetAsTime                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAsTime (const Value: TDateTime);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FValue := CrTimeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetIndex (const nIndex: integer);
begin
  if (Count > 0) and (nIndex < Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'ParamFields[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.ParamFields[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetItem(const nIndex: integer): TCrpeParamFields;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSelection                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSelection.Create;
begin
  inherited Create;
  FFormula := TCrpeString.Create;
  FReplace := True;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSelection.Destroy;
begin
  FFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.Clear;
begin
  FFormula.Clear;
  FReplace := True;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.CopyFrom (Source: TCrpeSelection);
begin
  Clear;
  FFormula.Assign(Source.FFormula);
  FReplace := Source.FReplace;
end;
{------------------------------------------------------------------------------}
{ Member function Check                                                        }
{------------------------------------------------------------------------------}
function TCrpeSelection.Check : boolean;
var
  nTextLen    : Smallint;
  hText       : hWnd;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nTextLen := 0;

  {Obtain the Record Selection Formula from the Report}
  Cr.SetDLLHandle;
  if not PEGetSelectionFormula(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Check <PEGetSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the original Formula string}
  pRptCurrent := StrAlloc(nTextLen);
  Cr.SetDLLHandle;
  if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Check <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Copy to PChar}
  sTmp := RTrimList(FFormula);
  pTmp := PChar(sTmp);

  {Set the new Selection Formula}
  Cr.SetDLLHandle;
  if not PESetSelectionFormula(Cr.FPrintJob, pTmp) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Check <PESetSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check the Selection Formula}
  Cr.SetDLLHandle;
  Result := PECheckSelectionFormula(Cr.FPrintJob);

  {Set the original Formula back in}
  Cr.SetDLLHandle;
  if not PESetSelectionFormula(Cr.FPrintJob, pRptCurrent) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Check <PESetSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  StrDispose(pRptCurrent);
end; {Check}
{------------------------------------------------------------------------------}
{ Member function Retrieve                                                     }
{------------------------------------------------------------------------------}
function TCrpeSelection.Retrieve : boolean;
var
  hText       : hWnd;
  nTextLen    : Smallint;
  pRptCurrent : PChar;
  bReplace    : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nTextLen := 0;

  {Clear the SelectionFormula but keep Replace setting}
  bReplace := FReplace;
  Clear;
  FReplace := bReplace;

  {Retrieve the Selection Formula}
  Cr.SetDLLHandle;
  if not PEGetSelectionFormula(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Retrieve <PEGetSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;

  {If not blank, retrieve the Selection Text}
  pRptCurrent := StrAlloc(nTextLen);
  if (nTextLen > 1) then
  begin
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
    begin
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Selection.Retrieve <PEGetHandleString>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Formula.SetText(pRptCurrent);
    Result := True;
  end;
  StrDispose(pRptCurrent);
end; { Retrieve }
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSelection.Send : boolean;
var
  hText       : hWnd;
  nTextLen    : Smallint;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
  Changed     : boolean;
begin
  Result := False;
  if (FFormula.Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  nTextLen := 0;
  Changed := False;

  {Retrieve Record Selection Formula from Report}
  Cr.SetDLLHandle;
  if not PEGetSelectionFormula(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Send <PEGetSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Formula string from the Handle}
  pRptCurrent := StrAlloc(nTextLen);
  Cr.SetDLLHandle;
  if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.Send <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {If the Report Selection is not blank, and Replace is False,
   'and' the new selection to the end}
  if (nTextLen > 1) and (FReplace = False) then
  begin
    {Store the current Selection}
    sTmp := String(pRptCurrent);
    {Check for CrEmptyStr: can't "AND" on an empty string!}
    if LowerCase(FFormula.Text) <> CrEmptyStr then
    begin
      {If it doesn't have spaces, add the AND}
      if Trim(sTmp) <> '' then
         sTmp := sTmp + ' and ' + #13#10;
      sTmp := sTmp + FFormula.Text;
      Changed := True;
    end;
  end
  {No Selection formula currently in Report}
  else
  begin
    {Trim of LF/CR characters}
    sTmp := RTrimList(FFormula);
    {Check for CrEmptyStr}
    if LowerCase(sTmp) = CrEmptyStr then
      sTmp := '';
    {Copy to PChar}
    pTmp := PChar(sTmp);
    {Compare with Report: if changed assign formula to send}
    if StrComp(pTmp, pRptCurrent) <> 0 then
      Changed := True;
  end;
  StrDispose(pRptCurrent);

  {Send the Selection to the Report}
  if Changed then
  begin
    {Copy the text to be sent}
    pRptCurrent := StrAlloc(Length(sTmp) + 1);
    StrCopy(pRptCurrent, PChar(sTmp));

    {Send the Selection Formula into the Report}
    Cr.SetDLLHandle;
    if not PESetSelectionFormula(Cr.FPrintJob, pRptCurrent) then
    begin
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Selection.Send <PESetSelectionFormula>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    StrDispose(pRptCurrent);
    Result := True;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetFormula                                                }
{------------------------------------------------------------------------------}
function TCrpeSelection.GetFormula: TCrpeString;
begin
  Result := FFormula;
end; { GetFormula }
{------------------------------------------------------------------------------}
{ Write Access method SetFormula                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.SetFormula(const ListVar: TCrpeString);
begin
  FFormula.Assign(ListVar);
end; { SetFormula }
{------------------------------------------------------------------------------}
{ Read Access method GetReplace                                                }
{------------------------------------------------------------------------------}
function TCrpeSelection.GetReplace: Boolean;
begin
  Result := FReplace;
end; { GetReplace }
{------------------------------------------------------------------------------}
{ Write Access method SetReplace                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.SetReplace(const Value: Boolean);
begin
  FReplace := Value;
end; { SetReplace }


{******************************************************************************}
{ Class TCrpeGroupSelection                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupSelection.Create;
begin
  inherited Create;
  FFormula := TCrpeString.Create;
  FReplace := True;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupSelection.Destroy;
begin
  FFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.Clear;
begin
  FFormula.Clear;
  FReplace := True;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.CopyFrom (Source: TCrpeGroupSelection);
begin
  Clear;
  FFormula.Assign(Source.FFormula);
  FReplace := Source.FReplace;
end;
{------------------------------------------------------------------------------}
{ Member function Check                                                        }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.Check : boolean;
var
  nTextLen    : Smallint;
  hText       : hWnd;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nTextLen := 0;

  {Obtain the Group Selection Formula from the Report}
  Cr.SetDLLHandle;
  if not PEGetGroupSelectionFormula(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Check <PEGetGroupSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp PChar}
  pRptCurrent := StrAlloc(nTextLen);

  {Get the original Formula string}
  Cr.SetDLLHandle;
  if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Check <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Copy to PChar}
  sTmp := RTrimList(FFormula);
  pTmp := PChar(sTmp);

  {Set the new Selection Formula}
  Cr.SetDLLHandle;
  if not PESetGroupSelectionFormula(Cr.FPrintJob, pTmp) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Check <PESetGroupSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check the New Selection Formula}
  Cr.SetDLLHandle;
  Result := PECheckGroupSelectionFormula(Cr.FPrintJob);

  {Set the original Formula back in}
  Cr.SetDLLHandle;
  if not PESetGroupSelectionFormula(Cr.FPrintJob, pRptCurrent) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Check <PESetGroupSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  StrDispose(pRptCurrent);
end;
{------------------------------------------------------------------------------}
{ Member function Retrieve                                                     }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.Retrieve : boolean;
var
  hText       : hWnd;
  nTextLen    : Smallint;
  pRptCurrent : PChar;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  nTextLen := 0;

  {Clear the GroupSelection}
  Clear;

  {Retrieve the Group Selection Formula from the Report}
  Cr.SetDLLHandle;
  if not PEGetGroupSelectionFormula(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Retrieve <PEGetGroupSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp pchar}
  pRptCurrent := StrAlloc(nTextLen);
  {If it is not blank, get the text}
  if (nTextLen > 1) then
  begin
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
    begin
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupSelection.Retrieve <PEGetHandleString>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FFormula.SetText(pRptCurrent);
    Result := True;
  end;
  StrDispose(pRptCurrent);
end; { Retrieve }
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.Send : boolean;
var
  hText       : hWnd;
  nTextLen    : Smallint;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
  Changed     : boolean;
begin
  Result := False;
  if (FFormula.Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  nTextLen := 0;
  Changed := False;

  {Retrieve Group Selection Formula from Report}
  Cr.SetDLLHandle;
  if not PEGetGroupSelectionFormula(Cr.FPrintJob, hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Send <PEGetGroupSelectionFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp pchar}
  pRptCurrent := StrAlloc(nTextLen);

  {Get the Formula string from the Handle}
  Cr.SetDLLHandle;
  if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.Send <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {If the Report Group Selection is not blank, and Replace is False,
   'and' the new selection to the end}
  if (nTextLen > 1) and (FReplace = False) then
  begin
    {Store the current Selection}
    sTmp := String(pRptCurrent);
    {Check for CrEmptyStr: can't "AND" on an empty string!}
    if LowerCase(FFormula.Text) <> CrEmptyStr then
    begin
      {If it doesn't consist of spaces only, add the AND}
      if Trim(sTmp) <> '' then
         sTmp := sTmp + ' and ' + #13#10;
      sTmp := sTmp + FFormula.Text;
      Changed := True;
    end;
  end
  {No Group Selection formula currently in Report}
  else
  begin
    {Trim of LF/CR characters}
    sTmp := RTrimList(FFormula);
    {Check for CrEmptyStr}
    if LowerCase(sTmp) = CrEmptyStr then
      sTmp := '';
    {Copy to PChar}
    pTmp := PChar(sTmp);
    {Compare with Report: if changed assign formula to send}
    if StrComp(pTmp, pRptCurrent) <> 0 then
      Changed := True;
  end;
  StrDispose(pRptCurrent);

  {Send the Group Selection to the Report}
  if Changed then
  begin
    {ReAllocate memory for temp pchar}
    pRptCurrent := StrAlloc(Length(sTmp) + 1);
    {Copy the text to be sent}
    StrCopy(pRptCurrent, PChar(sTmp));

    {Send the Selection Formula into the Report}
    Cr.SetDLLHandle;
    if not PESetGroupSelectionFormula(Cr.FPrintJob, pRptCurrent) then
    begin
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupSelection.Send <PESetGroupSelectionFormula>') of
        cFalse   : Exit;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetFormula                                                }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.GetFormula: TCrpeString;
begin
  Result := FFormula;
end; { GetFormula }
{------------------------------------------------------------------------------}
{ Write Access method SetFormula                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.SetFormula(const ListVar: TCrpeString);
begin
  FFormula.Assign(ListVar);
end; { SetFormula }
{------------------------------------------------------------------------------}
{ Read Access method GetReplace                                                }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.GetReplace: Boolean;
begin
  Result := FReplace;
end; { GetReplace }
{------------------------------------------------------------------------------}
{ Write Access method SetReplace                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.SetReplace(const Value: Boolean);
begin
  FReplace := Value;
end; { SetReplace }


{******************************************************************************}
{ Class TCrpeFormulasItem                                                      }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeFormulasItem.Create;
begin
  inherited Create;
  FName := '';
  FFormula := TCrpeString.Create;
end;
{------------------------------------------------------------------------------}
{ destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeFormulasItem.Destroy;
begin
  FFormula.Free;
  inherited Destroy;
end;


{******************************************************************************}
{ Class TCrpeFormulas                                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeFormulas.Create;
begin
  inherited Create;
  FList := TList.Create;
  sTemp := TCrpeString.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeFormulas.Destroy;
begin
  Clear;
  FList.Free;
  sTemp.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  sTemp.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.CopyFrom (Source: TCrpeFormulas);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Name);
    ListItem(cnt).FFormula.Assign(Source[cnt].Formula);
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeFormulas.IndexOf(FormulaName: TCrFormulaName): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FName, FormulaName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeFormulas.ListItem(nIndex: integer): TCrpeFormulasItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Add (FormulaName: TCrFormulaName): integer;
var
  p1 : Pointer;
begin
  Result := -1;
  if IndexOf(FormulaName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'Formulas <' + FormulaName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeFormulasItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FName := FormulaName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'Formulas.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Retrieve : boolean;
var
  NameHandle : hWnd;
  NameLength : Smallint;
  TxtHandle  : hWnd;
  TxtLength  : Smallint;
  TxtBuffer  : PChar;
  nFormulas  : Smallint;
  nFormula   : Smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the Formula list}
  Clear;

  {Get number of Formulas}
  Cr.SetDLLHandle;
  nFormulas := PEGetNFormulas(Cr.FPrintJob);
  if (nFormulas = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Retrieve <PEGetNFormulas>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the formulas}
  for nFormula := 0 to (nFormulas - 1) do
  begin
    NameLength := 0;
    TxtLength := 0;
    {Retrieve formula}
    Cr.SetDLLHandle;
    if not PEGetNthFormula(Cr.FPrintJob, nFormula, NameHandle,
      NameLength, TxtHandle, TxtLength) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.Retrieve <PEGetNthFormula>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Allocate memory for temp pchar}
    TxtBuffer := StrAlloc(NameLength);

    {Get Formula Name}
    Cr.SetDLLHandle;
    if not PEGetHandleString(NameHandle, TxtBuffer, NameLength) then
    begin
      StrDispose(TxtBuffer);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Add a new Formula item to VCL}
    Add(String(TxtBuffer));
    StrDispose(TxtBuffer);

    {Allocate memory for temp pchar}
    TxtBuffer := StrAlloc(TxtLength);

    {Get Formula}
    Cr.SetDLLHandle;
    if not PEGetHandleString(TxtHandle, TxtBuffer, TxtLength) then
    begin
      StrDispose(TxtBuffer);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    ListItem(FIndex).FFormula.SetText(TxtBuffer);
    StrDispose(TxtBuffer);
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Check method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Check : boolean;
var
  nTextLen    : Smallint;
  hText       : hWnd;
  pRptCurrent : PChar;
  pTmp        : PChar;
  sTmp        : string;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  if FIndex = -1 then
    Exit;
  nTextLen := 0;

  {Obtain the Formula from the Report}
  Cr.SetDLLHandle;
  if not PEGetFormula(Cr.FPrintJob, PChar(Name), hText, nTextLen) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Check <PEGetFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Allocate memory for temp pchar}
  pRptCurrent := StrAlloc(nTextLen);

  {Get the original Formula string}
  Cr.SetDLLHandle;
  if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Check <PEGetHandleString>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Copy to PChar}
  sTmp := RTrimList(Formula);
  pTmp := PChar(sTmp);

  {Set and Check the new Selection Formula}
  Cr.SetDLLHandle;
  if not PESetFormula(Cr.FPrintJob, PChar(Name), pTmp) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Check <PESetFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  Cr.SetDLLHandle;
  Result := PECheckFormula(Cr.FPrintJob, PChar(Name));

  {Set the original Formula back in}
  Cr.SetDLLHandle;
  if not PESetFormula(Cr.FPrintJob, PChar(Name), pRptCurrent) then
  begin
    StrDispose(pRptCurrent);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Check <PESetFormula>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  StrDispose(pRptCurrent);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Send : boolean;
var
  sFormulaName : string;
  nTextLen     : Smallint;
  hText        : hWnd;
  nIndex       : Smallint;
  nFormulas    : Smallint;
  pRptCurrent  : PChar;
  pTmp         : PChar;
  sTmp         : string;
  Changed      : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Get the number of Formulas}
  Cr.SetDLLHandle;
  nFormulas := PEGetNFormulas(Cr.FPrintJob);
  if (nFormulas = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Send <PEGetNFormulas>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the formulas}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Get the Formula Name from the VCL}
    sFormulaName := ListItem(nIndex).FName;
    nTextLen := 0;

    {Retrieve the Formula currently in the Report}
    Cr.SetDLLHandle;
    if not PEGetFormula(Cr.FPrintJob, PChar(sFormulaName), hText, nTextLen) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.Send <PEGetFormula>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Allocate memory for the temp pchar}
    pRptCurrent := StrAlloc(nTextLen);

    {Get the Formula}
    Cr.SetDLLHandle;
    if not PEGetHandleString(hText, pRptCurrent, nTextLen) then
    begin
      Result := False;
      StrDispose(pRptCurrent);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.Send <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Trim of LF/CR characters}
    sTmp := RTrimList(ListItem(nIndex).FFormula);
    {Blank formulas are not sent}
    if Length(sTmp) = 0 then
    begin
      StrDispose(pRptCurrent);
      Continue;
    end;
    {Check for CrEmptyStr}
    if LowerCase(sTmp) = CrEmptyStr then
      sTmp := '';
    {Copy to PChar}
    pTmp := PChar(sTmp);

    {Compare it to the new formula...If they are the same, do not send}
    if StrComp(pTmp, pRptCurrent) <> 0 then
       Changed := True;
    StrDispose(pRptCurrent);

    {Send the Formula to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetFormula(Cr.FPrintJob, PChar(sFormulaName), pTmp) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
          'Formulas.Send <PESetFormula> [FormulaName: ' + sFormulaName + ']') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetName                                                   }
{------------------------------------------------------------------------------}
function TCrpeFormulas.GetName : TCrFormulaName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetName                                                  }
{  - SetName does not overwrite the value,                                     }
{    it acts as a lookup for the name specified                                }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetName(const Value: TCrFormulaName);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'Formulas.Name := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetFormula                                                }
{------------------------------------------------------------------------------}
function TCrpeFormulas.GetFormula : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FFormula;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetFormula                                               }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetFormula(const ListVar: TCrpeString);
begin
  sTemp.Clear;
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FFormula.Assign(ListVar);
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeFormulas.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'Formulas[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.Formulas[nIndex]                                              }
{------------------------------------------------------------------------------}
function TCrpeFormulas.GetItem(nIndex: integer) : TCrpeFormulas;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSortFieldsItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSortFieldsItem.Create;
begin
  inherited Create;
  FNumber     := -1;
  FField      := '';
  FDirection  := sdDefault;
  FDeleteSF   := False;
end;


{******************************************************************************}
{ Class TCrpeSortFields                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSortFields.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSortFields.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.CopyFrom (Source: TCrpeSortFields);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FField := Source[cnt].Field;
    ListItem(cnt).FDirection := Source[cnt].Direction;
    ListItem(cnt).FDeleteSF := Source[cnt].DeleteSF;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSortFields.Count : integer;
begin
  Result := FList.Count
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSortFields.IndexOf(SortFieldNumber : TCrSortFieldsNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = SortFieldNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSortFields.ListItem(nIndex: integer): TCrpeSortFieldsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSortFields.Add (SortFieldNumber : TCrSortFieldsNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SortFieldNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'SortFields <' + IntToStr(SortFieldNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSortFieldsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := SortFieldNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SortFields.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSortFields.Retrieve : boolean;
var
  nSortFields : Smallint;
  nIndex      : Smallint;
  nDirection  : Smallint;
  pSortField  : PChar;
  fieldHandle : HWnd;
  fieldLength : Smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the SortField lists}
  Clear;

  Cr.SetDLLHandle;
  nSortFields := PEGetNSortFields(Cr.FPrintJob);
  if (nSortFields = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Retrieve <PEGetNSortFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  for nIndex := 0 to (nSortFields - 1) do
  begin
    fieldLength := 0;
    Cr.SetDLLHandle;
    if not PEGetNthSortField(Cr.FPrintJob, nIndex, fieldHandle,
      fieldLength, nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SortFields.Retrieve <PEGetNthSortField>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Setup pchar for Sortfield name}
    pSortField := StrAlloc(fieldLength);
    {Get Sortfield name string}
    Cr.SetDLLHandle;
    if not PEGetHandleString(fieldHandle, pSortField, fieldLength) then
    begin
      StrDispose(pSortField);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SortFields.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Add(nIndex);
    ListItem(FIndex).FField := String(pSortField);
    ListItem(FIndex).FDirection := TCrSortDirection(nDirection);
    ListItem(FIndex).FDeleteSF := False;
    Result := True;
    StrDispose(pSortField);
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end; { Retrieve }
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSortFields.Send : boolean;
var
  nSortFields : smallint;
  nSortField  : smallint;
  nSortField2 : smallint;
  nDirection  : smallint;
  nDirection2 : smallint;
  nIndex      : smallint;
  nIndex2     : smallint;
  nRealIndex  : smallint;
  nAdded      : smallint;
  nDeleted    : smallint;
  sSortField  : string;
  pSortField  : PChar;
  fieldHandle : HWnd;
  fieldLength : smallint;
  Changed     : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  nDirection := 0;

  {Get Actual Number of SortFields from Report before deleted}
  Cr.SetDLLHandle;
  nSortFields := PEGetNSortFields(Cr.FPrintJob);
  if nSortFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Send <PEGetNSortFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through SortFields checking items marked for Deletion}
  nDeleted := 0;
  for nIndex := 0 to (Count - 1) do
  begin
    nRealIndex := nIndex - nDeleted;
    {If Delete is True}
    if (ListItem(nRealIndex).FDeleteSF = True) then
    begin
      {Get SortField Number}
      nSortField := ListItem(nRealIndex).FNumber;

      {Check range on SortField number}
      if nSortField > (nSortFields - nDeleted - 1) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SORTFIELD_NUMBER,
            'SortFields[' + IntToStr(nIndex) + '] = ' + IntToStr(ListItem(nIndex).FNumber)) of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Delete the SortField}
      Cr.SetDLLHandle;
      if not PEDeleteNthSortField(Cr.FPrintJob, nSortField) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SortFields.Send <PEDeleteNthSortField>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Adjust SortField numbers for items greater than Deleted one}
      for nIndex2 := 0 to (Count - 1) do
      begin
        {Get SortField Number}
        nSortField2 := ListItem(nIndex2).FNumber;
        if nSortField2 > nSortField then
        begin
          Dec(nSortField2);
          ListItem(nIndex2).FNumber := nSortField2;
        end;
      end;
      Delete(nRealIndex);
      Inc(nDeleted);
    end;
  end;

  {Get Actual Number of SortFields from Report after deleted}
  Cr.SetDLLHandle;
  nSortFields := PEGetNSortFields(Cr.FPrintJob);
  if nSortFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Send <PEGetNSortFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through SortFields to Change or Add}
  nAdded := 0;
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Get SortField Number}
    nSortField := ListItem(nIndex).FNumber;

    {If it is not a new SortField...}
    if nSortField < nSortFields then
    begin
      fieldLength := 0;
      {Retrieve SortField from Report}
      Cr.SetDLLHandle;
      if not PEGetNthSortField(Cr.FPrintJob, nSortField, fieldHandle,
        fieldLength, nDirection) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SortFields.Send <PEGetNthSortField>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Get Sortfield name string}
      pSortField := StrAlloc(fieldLength);
      Cr.SetDLLHandle;
      if not PEGetHandleString(fieldHandle, pSortField, fieldLength) then
      begin
        Result := False;
        StrDispose(pSortField);
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SortFields.Send <PEGetHandleString>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Check Field}
      sSortField := String(pSortField);
      if CompareStr(sSortField, ListItem(nIndex).FField) <> 0 then
      begin
        sSortField := ListItem(nIndex).FField;
        Changed := True;
      end; {CompareStr}
      StrDispose(pSortField);

      {Check Direction}
      nDirection2 := Ord(ListItem(nIndex).FDirection);
      if TCrSortDirection(nDirection2) <> sdDefault then
      begin
        if nDirection <> nDirection2 then
        begin
          nDirection := nDirection2;
          Changed := True;
        end;
      end;
    end
    {If it is a new SortField...}
    else
    begin
      Changed := True;
      sSortField := ListItem(nIndex).FField;

      {Check range on SortField number}
      if nSortField > (nSortFields + nAdded) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SORTFIELD_NUMBER,
            'SortFields[' + IntToStr(nIndex) + '] = ' + IntToStr(ListItem(nIndex).FNumber)) of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Copy the Direction}
      nDirection := Ord(ListItem(nIndex).FDirection);
      if TCrSortDirection(nDirection) = sdDefault then
        nDirection := Ord(sdAscending);
      Inc(nAdded);
    end;

    {Send SortField to Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetNthSortField(Cr.FPrintJob, nSortField,
        PChar(sSortField), nDirection) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SortFields.Send <PESetNthSortField>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetNumber: TCrSortFieldsNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end; { GetNumber }
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.SetNumber (const Value: TCrSortFieldsNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'SortFields.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetField                                                  }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetField : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FField;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetField                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.SetField (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FField := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDirection                                              }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetDirection : TCrSortDirection;
begin
  Result := sdDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDirection                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.SetDirection (const Value: TCrSortDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDelete                                                 }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetDelete : boolean;
begin
  Result := False;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDeleteSF;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDelete                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.SetDelete (const Value: boolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDeleteSF := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SortFields[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SortFields[nIndex]                                            }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetItem(nIndex: integer) : TCrpeSortFields;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGroupSortFieldsItem                                               }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupSortFieldsItem.Create;
begin
  inherited Create;
  FNumber     := -1;
  FField      := '';
  FDirection  := sdDefault;
  FDeleteGSF  := False;
end;


{******************************************************************************}
{ Class TCrpeGroupSortFields                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupSortFields.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupSortFields.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.CopyFrom (Source: TCrpeGroupSortFields);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FField := Source[cnt].Field;
    ListItem(cnt).FDirection := Source[cnt].Direction;
    ListItem(cnt).FDeleteGSF := Source[cnt].DeleteGSF;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.IndexOf(GroupSortFieldNumber : TCrGroupSortFieldsNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GroupSortFieldNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.ListItem(nIndex: integer): TCrpeGroupSortFieldsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.Add(GroupSortFieldNumber: TCrGroupSortFieldsNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GroupSortFieldNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'GroupSortFields <' + IntToStr(GroupSortFieldNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGroupSortFieldsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GroupSortFieldNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GroupSortFields.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.Retrieve : boolean;
var
  nGSortFields : smallint;
  nIndex       : smallint;
  nDirection   : smallint;
  pGSortField  : PChar;
  fieldHandle  : HWnd;
  fieldLength  : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the GroupSortField lists}
  Clear;

  Cr.SetDLLHandle;
  nGSortFields := PEGetNGroupSortFields(Cr.FPrintJob);
  if (nGSortFields = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.Retrieve <PEGetNGroupSortFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  for nIndex := 0 to (nGSortFields - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthGroupSortField(Cr.FPrintJob, nIndex, fieldHandle,
      fieldLength, nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupSortFields.Retrieve <PEGetNthGroupSortField>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get GroupSortField text}
    pGSortField := StrAlloc(fieldLength);
    Cr.SetDLLHandle;
    if not PEGetHandleString(fieldHandle, pGSortField, fieldLength) then
    begin
      StrDispose(pGSortField);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupSortFields.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Store values to VCL}
    Add(nIndex);
    ListItem(FIndex).FField := String(pGSortField);
    ListItem(FIndex).FDirection := TCrSortDirection(nDirection);
    ListItem(FIndex).FDeleteGSF := False;
    Result := True;
    StrDispose(pGSortField);
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end; { Retrieve }
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.Send : boolean;
var
  nGSortFields  : smallint;
  nGSortField   : smallint;
  nGSortField2  : smallint;
  nDirection    : smallint;
  nDirection2   : smallint;
  nIndex        : smallint;
  nIndex2       : smallint;
  nRealIndex    : smallint;
  nAdded        : smallint;
  nDeleted      : smallint;
  sGSortField   : string;
  pGSortField   : PChar;
  fieldHandle   : HWnd;
  fieldLength   : smallint;
  Changed       : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  nDirection := 0;

  {Get Actual Number of GroupSortFields from Report before deleted}
  Cr.SetDLLHandle;
  nGSortFields := PEGetNGroupSortFields(Cr.FPrintJob);
  if (nGSortFields = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       'GroupSortFields.Send <PEGetNGroupSortFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through SortFields checking items marked for Deletion}
  nDeleted := 0;
  for nIndex := 0 to (Count - 1) do
  begin
    nRealIndex := nIndex - nDeleted;
    {If Delete is True}
    if (ListItem(nRealIndex).FDeleteGSF = True) then
    begin
      {Get GroupSortField Number}
      nGSortField := ListItem(nRealIndex).FNumber;

      {Check range on GroupSortField number}
      if nGSortField > (nGSortFields - nDeleted - 1) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GROUPSORT_NUMBER,
            'GroupSortFields[' + IntToStr(nIndex) + '] = ' + IntToStr(ListItem(nIndex).FNumber)) of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Delete the SortField}
      Cr.SetDLLHandle;
      if not PEDeleteNthGroupSortField(Cr.FPrintJob, nGSortField) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GroupSortFields.Send <PEDeleteNthGroupSortField>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Adjust GroupSortField numbers for items greater than Deleted one}
      for nIndex2 := 0 to (Count - 1) do
      begin
        {Get GroupSortField Number}
        nGSortField2 := ListItem(nIndex2).FNumber;
        if nGSortField2 > nGSortField then
        begin
          Dec(nGSortField2);
          ListItem(nIndex2).FNumber := nGSortField2;
        end;
      end;
      Delete(nRealIndex);
      Inc(nDeleted);
    end;
  end;

  {Get Actual Number of GroupSortFields from Report after deleted}
  Cr.SetDLLHandle;
  nGSortFields := PEGetNGroupSortFields(Cr.FPrintJob);
  if (nGSortFields = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.Send <PEGetNGroupSortFields>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through GroupSortFields to Change or Add}
  nAdded := 0;
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Get GroupSortField Number}
    nGSortField := ListItem(nIndex).FNumber;

    {If it is not a new GSortField...}
    if nGSortField < nGSortFields then
    begin
      fieldLength := 0;
      {Retrieve GSortField from Report}
      Cr.SetDLLHandle;
      if not PEGetNthGroupSortField(Cr.FPrintJob, nGSortField,
        fieldHandle, fieldLength, nDirection) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GroupSortFields.Send <PEGetNthGroupSortField>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Setup pchar for GroupSortfield name}
      pGSortField := StrAlloc(fieldLength);
      {Get GSortfield name string}
      Cr.SetDLLHandle;
      if not PEGetHandleString(fieldHandle, pGSortField, fieldLength) then
      begin
        Result := False;
        StrDispose(pGSortField);
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GroupSortFields.Send <PEGetHandleString>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Check Field}
      sGSortField := String(pGSortField);
      if CompareStr(sGSortField, ListItem(nIndex).FField) <> 0 then
      begin
        sGSortField := ListItem(nIndex).FField;
        Changed := True;
      end;  {CompareStr}
      StrDispose(pGSortField);

      {Check Direction}
      nDirection2 := Ord(ListItem(nIndex).FDirection);
      if TCrSortDirection(nDirection2) <> sdDefault then
      begin
        if nDirection <> nDirection2 then
        begin
          nDirection := nDirection2;
          Changed := True;
        end;
      end;
    end
    {If it is a new GroupSortField...}
    else
    begin
      Changed := True;
      {Copy the Field}
      sGSortField := ListItem(nIndex).FField;

      {Check range on GroupSortField number}
      if nGSortField > (nGSortFields + nAdded) then
      begin
        Result := False;
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GROUPSORT_NUMBER,
           'GroupSortFields[' + IntToStr(nIndex) + '] = ' + IntToStr(ListItem(nIndex).FNumber)) of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Copy the Direction}
      nDirection := Ord(ListItem(nIndex).FDirection);
      if TCrSortDirection(nDirection) = sdDefault then
        nDirection := Ord(sdAscending);
      Inc(nAdded);
    end;

    {Send GroupSortField to Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetNthGroupSortField(Cr.FPrintJob, nGSortField,
        PChar(sGSortField), nDirection) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GroupSortFields.Send <PESetNthGroupSortField>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end; { if }
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function  TCrpeGroupSortFields.GetNumber : TCrGroupSortFieldsNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.SetNumber (const Value: TCrGroupSortFieldsNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'GroupSortFields.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetField                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.GetField : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FField;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetField                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.SetField (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FField := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDirection                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.GetDirection : TCrSortDirection;
begin
  Result := sdDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDirection                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.SetDirection (const Value: TCrSortDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDelete                                                 }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.GetDelete : boolean;
begin
  Result := False;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDeleteGSF;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDelete                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.SetDelete (const Value: boolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDeleteGSF := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GroupSortFields[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.GroupSortFields[nIndex]                                       }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.GetItem(nIndex: integer) : TCrpeGroupSortFields;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGroupConditionItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupConditionItem.Create;
begin
  inherited Create;
  FNumber     := -1;
  FField      := '';
  FCondition  := AnyChange;
  FDirection  := gdDefault;
  FGroupType  := gtOther;
end;


{******************************************************************************}
{ Class TCrpeGroupCondition                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupCondition.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupCondition.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.CopyFrom (Source: TCrpeGroupCondition);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FField := Source[cnt].Field;
    ListItem(cnt).FCondition := Source[cnt].Condition;
    ListItem(cnt).FDirection := Source[cnt].Direction;
    ListItem(cnt).FGroupType := Source[cnt].GroupType;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.Add (GroupNumber: TCrGroupConditionNumber): integer;
var
  p1 : Pointer;
begin
  Result := -1;
  if IndexOf(GroupNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'GroupCondition <' + IntToStr(GroupNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGroupConditionItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GroupNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GroupCondition.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.IndexOf(GroupNumber: TCrGroupConditionNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GroupNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.ListItem(nIndex: integer): TCrpeGroupConditionItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.Retrieve : boolean;
var
  nGroups      : Smallint;
  nIndex       : Smallint;
  nSection     : Smallint;
  nDirection   : Smallint;
  nCondition   : Smallint;
  pGroupField  : PChar;
  condHandle   : HWnd;
  condLength   : Smallint;
  int1,int2    : Smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the GroupCondition lists}
  Clear;

  {Set Section Code to first Group}
  nSection := 3000;
  {Get the number of Groups}
  Cr.SetDLLHandle;
  nGroups := PEGetNGroups(Cr.FPrintJob);
  if (nGroups = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupCondition.Retrieve <PEGetNGroups>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {The Print Engine can't handle more than 24 groups!}
  if nGroups > 25 then
    nGroups := 24;

  {Loop through the Groups}
  for nIndex := 0 to (nGroups - 1) do
  begin
    condLength := 0;
    Cr.SetDLLHandle;
    if not PEGetGroupCondition(Cr.FPrintJob, nSection, condHandle,
      condLength, nCondition, nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupCondition.Retrieve <PEGetGroupCondition>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get the GroupCondition string}
    pGroupField := StrAlloc(condLength);
    Cr.SetDLLHandle;
    if not PEGetHandleString(condHandle, pGroupField, condLength) then
    begin
      StrDispose(pGroupField);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupCondition.Retrieve <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    Add(nIndex + 1);
    ListItem(FIndex).FField := String(pGroupField);
    StrDispose(pGroupField);
    ListItem(FIndex).FDirection := TCrGroupDirection(nDirection);
    {Condition with Type Mask; This obtains the Type of
     Group Condition Field from the Condition variable}
    int1 := nCondition and PE_GC_TYPEMASK;  //$0F00
    case int1 of
      {"Others" have no conditions}
      PE_GC_TYPEOTHER:  // $0000
      begin
        ListItem(FIndex).FGroupType := gtOther;
        ListItem(FIndex).FCondition := AnyChange;
      end;
      PE_GC_TYPEDATE:   //$0200;
      begin
        ListItem(FIndex).FGroupType := gtDate;
        {Condition with Condition Mask; This obtains the
         condition of the group from the Condition variable}
        int2 := nCondition and PE_GC_CONDITIONMASK;  //$00FF
        case int2 of
          PE_GC_DAILY        : ListItem(FIndex).FCondition := dateDaily;
          PE_GC_WEEKLY       : ListItem(FIndex).FCondition := dateWeekly;
          PE_GC_BIWEEKLY     : ListItem(FIndex).FCondition := dateBiWeekly;
          PE_GC_SEMIMONTHLY  : ListItem(FIndex).FCondition := dateSemiMonthly;
          PE_GC_MONTHLY      : ListItem(FIndex).FCondition := dateMonthly;
          PE_GC_QUARTERLY    : ListItem(FIndex).FCondition := dateQuarterly;
          PE_GC_SEMIANNUALLY : ListItem(FIndex).FCondition := dateSemiAnnually;
          PE_GC_ANNUALLY     : ListItem(FIndex).FCondition := dateAnnually;
          else
            ListItem(FIndex).FCondition := AnyChange;
        end;
      end;
      PE_GC_TYPEBOOLEAN:  //$0400:
      begin
        ListItem(FIndex).FGroupType := gtBoolean;
        int2 := nCondition and PE_GC_CONDITIONMASK;  //$00FF
        case int2 of
          PE_GC_TOYES     : ListItem(FIndex).FCondition := boolToYes;
          PE_GC_TONO      : ListItem(FIndex).FCondition := boolToNo;
          PE_GC_EVERYYES  : ListItem(FIndex).FCondition := boolEveryYes;
          PE_GC_EVERYNO   : ListItem(FIndex).FCondition := boolEveryNo;
          PE_GC_NEXTISYES : ListItem(FIndex).FCondition := boolNextIsYes;
          PE_GC_NEXTISNO  : ListItem(FIndex).FCondition := boolNextIsNo;
          else
            ListItem(FIndex).FCondition := AnyChange;
        end;
      end;
      PE_GC_TYPETIME:  //$0800:
      begin
        ListItem(FIndex).FGroupType := gtTime;
        int2 := nCondition and PE_GC_CONDITIONMASK;  //$00FF
        case int2 of
          PE_GC_BYSECOND : ListItem(FIndex).FCondition := timeBySecond;
          PE_GC_BYMINUTE : ListItem(FIndex).FCondition := timeByMinute;
          PE_GC_BYHOUR   : ListItem(FIndex).FCondition := timeByHour;
          PE_GC_BYAMPM   : ListItem(FIndex).FCondition := timeByAMPM;
          else
            ListItem(FIndex).FCondition := AnyChange;
        end;
      end;
    end;
    {Move to the next Group}
    Inc(nSection);
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.Send : boolean;
var
  nIndex      : Smallint;
  nSection    : Smallint;
  nCondition  : Smallint;
  nGroupType  : Smallint;
  nGroups     : Smallint;
  GroupNum    : Smallint;
  Changed     : boolean;
  {variables for Rpt settings}
  rDirection  : Smallint;
  rCondition  : Smallint;
  pGroupField : PChar;
  rGroupField : string;
  condHandle  : HWnd;
  condLength  : Smallint;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  nCondition := 0;

  {Get the number of Groups}
  Cr.SetDLLHandle;
  nGroups := PEGetNGroups(Cr.FPrintJob);
  if (nGroups = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupCondition.Send <PEGetNGroups>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Groups}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Read Group Number}
    GroupNum := ListItem(nIndex).FNumber;
    if GroupNum > (nGroups) then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GROUP_CONDITION,
         'GroupCondition[' + IntToStr(nIndex) + ']') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Decrement so Group1 is Group number 0, etc.}
    Dec(GroupNum);
    {SectionCode}
    nSection := PE_GROUPHEADER + (GroupNum);

    {Get GroupCondition settings from Report}
    condLength := 0;
    Cr.SetDLLHandle;
    if not PEGetGroupCondition(Cr.FPrintJob, nSection, condHandle,
      condLength, rCondition, rDirection) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupCondition.Send <PEGetGroupCondition>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get the GroupField string from Report}
    pGroupField := StrAlloc(condLength);
    Cr.SetDLLHandle;
    if not PEGetHandleString(condHandle, pGroupField, condLength) then
    begin
      Result := False;
      StrDispose(pGroupField);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupCondition.Send <PEGetHandleString>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    rGroupField := String(pGroupField);
    StrDispose(pGroupField);
    {Store the Report Condition setting}
    {Condition with Type Mask; This obtains the Type of
     Group Condition Field from the Condition variable}
    nGroupType := rCondition and PE_GC_TYPEMASK;
    case nGroupType of
      {"Others" have no conditions}
      PE_GC_TYPEOTHER  : rCondition := PE_GC_ANYCHANGE;
      PE_GC_TYPEDATE   : rCondition := rCondition and PE_GC_CONDITIONMASK;
      PE_GC_TYPEBOOLEAN: rCondition := rCondition and PE_GC_CONDITIONMASK;
      PE_GC_TYPETIME   : rCondition := rCondition and PE_GC_CONDITIONMASK;
    end;

    {Convert the VCL Condition setting}
    case ListItem(nIndex).FGroupType of
      gtOther   : nCondition := 0;                                {0}
      gtDate    : nCondition := Ord(ListItem(nIndex).FCondition) - 1; {constants: 0..7}
      gtBoolean : nCondition := Ord(ListItem(nIndex).FCondition) - 8; {constants: 1..6}
      gtTime    : nCondition := Ord(ListItem(nIndex).FCondition) - 7; {constants: 8-11}
    end;
    {If the Condition doesn't match the type, raise an error}
    if nCondition < 0 then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GROUP_TYPE,
         'GroupCondition[' + IntToStr(nIndex) + ']') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Check to see if any have changed}
    {GroupField}
    if CompareStr(ListItem(nIndex).FField, rGroupField) <> 0 then
    begin
      rGroupField := ListItem(nIndex).FField;
      Changed := True;
    end;
    {Condition}
    if nCondition <> rCondition then
    begin
      rCondition := nCondition;
      Changed := True;
    end;
    {Direction}
    if ListItem(nIndex).FDirection <> gdDefault then
    begin
      if Ord(ListItem(nIndex).FDirection) <> rDirection then
      begin
        rDirection := Ord(ListItem(nIndex).FDirection);
        Changed := True;
      end;
    end;

    {Send GroupCondition to Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetGroupCondition(Cr.FPrintJob, nSection, PChar(rGroupField),
        rCondition, rDirection) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GroupCondition.Send <PESetGroupCondition>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.GetNumber : TCrGroupConditionNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.SetNumber (const Value: TCrGroupConditionNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'GroupCondition.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetField                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.GetField : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FField;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetField                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.SetField (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FField := Value;
    {Check Length}
    if Length(ListItem(FIndex).FField) > PE_FIELD_NAME_LEN then
      ListItem(FIndex).FField := Copy(ListItem(FIndex).FField, 1, PE_FIELD_NAME_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGroupType                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.GetGroupType : TCrGroupType;
begin
  Result := gtOther;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGroupType;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGroupType                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.SetGroupType (const Value: TCrGroupType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGroupType := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetCondition                                              }
{------------------------------------------------------------------------------}
function  TCrpeGroupCondition.GetCondition : TCrGroupCondition;
begin
  Result := AnyChange;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FCondition;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetCondition                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.SetCondition (const Value: TCrGroupCondition);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FCondition := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDirection                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.GetDirection : TCrGroupDirection;
begin
  Result := gdDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDirection                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.SetDirection (const Value: TCrGroupDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGroupCondition.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupCondition.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GroupCondition[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.GroupCondition[nIndex]                                        }
{------------------------------------------------------------------------------}
function  TCrpeGroupCondition.GetItem(nIndex: integer) : TCrpeGroupCondition;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGroupOptionsItem                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupOptionsItem.Create;
begin
  inherited Create;
  FNumber            := -1;
  FField             := '';
  FCondition         := AnyChange;
  FDirection         := gdDefault;
  FGroupType         := gtOther;
  FRepeatGH          := cDefault;
  FKeepTogether      := cDefault;
  FTopNOptions       := tnDefault;
  FTopNGroups        := -1;
  FTopNSortField     := '';
  FTopNDiscardOthers := cDefault;
end;


{******************************************************************************}
{ Class TCrpeGroupOptions                                                      }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupOptions.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupOptions.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.CopyFrom (Source: TCrpeGroupOptions);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FField := Source[cnt].Field;
    ListItem(cnt).FCondition := Source[cnt].Condition;
    ListItem(cnt).FDirection := Source[cnt].Direction;
    ListItem(cnt).FGroupType := Source[cnt].GroupType;
    ListItem(cnt).FRepeatGH := Source[cnt].RepeatGH;
    ListItem(cnt).FKeepTogether := Source[cnt].KeepTogether;
    ListItem(cnt).FTopNOptions := Source[cnt].TopNOptions;
    ListItem(cnt).FTopNGroups := Source[cnt].TopNGroups;
    ListItem(cnt).FTopNSortField := Source[cnt].TopNSortField;
    ListItem(cnt).FTopNDiscardOthers := Source[cnt].TopNDiscardOthers;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.Add (GroupNumber: TCrGroupOptionsNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GroupNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'GroupOptions <' + IntToStr(GroupNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGroupOptionsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GroupNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GroupOptions.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.ListItem(nIndex: integer): TCrpeGroupOptionsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.IndexOf(GroupNumber : TCrGroupOptionsNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GroupNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.Retrieve : boolean;
var
  GroupOptions : PEGroupOptions;
  nGroups      : smallint;
  nIndex       : smallint;
  int1,int2    : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {GroupOptions only available in SCR 6+}
  if Cr.FVersion.FMajor < 6 then
    Exit;

  {Clear the GroupOptions lists}
  Clear;
  {Get the number of Groups}
  Cr.SetDLLHandle;
  nGroups := PEGetNGroups(Cr.FPrintJob);
  if (nGroups = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupOptions.Retrieve <PEGetNGroups>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {The Print Engine can't handle more than 25 groups!}
  if nGroups > 25 then
    nGroups := 25;

  {Loop through the Groups}
  for nIndex := 0 to (nGroups - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetGroupOptions(Cr.FPrintJob, nIndex, GroupOptions) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupOptions.Retrieve <PEGetGroupOptions>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    Add(nIndex + 1);
    ListItem(FIndex).FField := String(GroupOptions.fieldName);
    if GroupOptions.SortDirection in [0..4] then
      ListItem(FIndex).FDirection := TCrGroupDirection(GroupOptions.sortDirection);
    if GroupOptions.repeatGroupHeader in [0..2] then
      ListItem(FIndex).FRepeatGH := TCrBoolean(GroupOptions.repeatGroupHeader);
    if GroupOptions.keepGroupTogether in [0..2] then
      ListItem(FIndex).FKeepTogether := TCrBoolean(GroupOptions.keepGroupTogether);
    if GroupOptions.discardOtherGroups in [0..2] then
      ListItem(FIndex).FTopNDiscardOthers := TCrBoolean(GroupOptions.discardOtherGroups);
    if GroupOptions.topOrBottomNGroups in [0..4] then
      ListItem(FIndex).FTopNOptions := TCrTopNOptions(GroupOptions.topOrBottomNGroups);
    ListItem(FIndex).FTopNGroups := GroupOptions.nTopOrBottomGroups;
    ListItem(FIndex).FTopNSortField := String(GroupOptions.topOrBottomNSortFieldName);

    {Condition with Type Mask; This obtains the Type of
     Group Condition Field from the Condition variable}
    int1 := GroupOptions.condition and PE_GC_TYPEMASK;  //$0F00
    case int1 of
      {"Others" have no conditions}
      PE_GC_TYPEOTHER:  // $0000
      begin
        ListItem(FIndex).FGroupType := gtOther;
        ListItem(FIndex).FCondition := AnyChange;
      end;
      PE_GC_TYPEDATE:   //$0200;
      begin
        ListItem(FIndex).FGroupType := gtDate;  {gtDate}
        {Condition with Condition Mask; This obtains the
         condition of the group from the Condition variable}
        int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
        case int2 of
          PE_GC_DAILY        : ListItem(FIndex).FCondition := dateDaily;
          PE_GC_WEEKLY       : ListItem(FIndex).FCondition := dateWeekly;
          PE_GC_BIWEEKLY     : ListItem(FIndex).FCondition := dateBiWeekly;
          PE_GC_SEMIMONTHLY  : ListItem(FIndex).FCondition := dateSemiMonthly;
          PE_GC_MONTHLY      : ListItem(FIndex).FCondition := dateMonthly;
          PE_GC_QUARTERLY    : ListItem(FIndex).FCondition := dateQuarterly;
          PE_GC_SEMIANNUALLY : ListItem(FIndex).FCondition := dateSemiAnnually;
          PE_GC_ANNUALLY     : ListItem(FIndex).FCondition := dateAnnually;
          else
            ListItem(FIndex).FCondition := AnyChange;
        end;
      end;
      PE_GC_TYPEBOOLEAN:  //$0400:
      begin
        ListItem(FIndex).FGroupType := gtBoolean;
        int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
        case int2 of
          PE_GC_TOYES     : ListItem(FIndex).FCondition := boolToYes;
          PE_GC_TONO      : ListItem(FIndex).FCondition := boolToNo;
          PE_GC_EVERYYES  : ListItem(FIndex).FCondition := boolEveryYes;
          PE_GC_EVERYNO   : ListItem(FIndex).FCondition := boolEveryNo;
          PE_GC_NEXTISYES : ListItem(FIndex).FCondition := boolNextIsYes;
          PE_GC_NEXTISNO  : ListItem(FIndex).FCondition := boolNextIsNo;
          else
            ListItem(FIndex).FCondition := AnyChange;
        end;
      end;
      PE_GC_TYPETIME:  //$0800:
      begin
        ListItem(FIndex).FGroupType := gtTime;
        int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
        case int2 of
          PE_GC_BYSECOND : ListItem(FIndex).FCondition := timeBySecond;
          PE_GC_BYMINUTE : ListItem(FIndex).FCondition := timeByMinute;
          PE_GC_BYHOUR   : ListItem(FIndex).FCondition := timeByHour;
          PE_GC_BYAMPM   : ListItem(FIndex).FCondition := timeByAMPM;
          else
            ListItem(FIndex).FCondition := AnyChange;
        end;
      end;
    end;
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.Send : boolean;
var
  GroupOptions   : PEGroupOptions;
  nIndex,
  GroupNum,
  nGroups        : smallint;
  rField         : string;
  rTopNSortField : string;
  rCondition     : smallint;
  nCondition     : smallint;
  Changed        : boolean;
  int1           : smallint;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  {GroupOptions only available in SCR 6+}
  if Cr.FVersion.FMajor < 6 then
    Exit;

  {Get the number of Groups}
  Cr.SetDLLHandle;
  nGroups := PEGetNGroups(Cr.FPrintJob);
  if (nGroups = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupOptions.Send <PEGetNGroups>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Groups}
  for nIndex := 0 to (Count - 1) do
  begin
    nCondition := 0;
    Changed := False;
    {Read Group Number}
    GroupNum := ListItem(nIndex).FNumber;
    if GroupNum > (nGroups) then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GROUP_OPTIONS,
          'GroupOptions[' + IntToStr(nIndex) + ']') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Decrement so Group1 is Group number 0, etc.}
    Dec(GroupNum);

    {Get the GroupOptions from the Report}
    Cr.SetDLLHandle;
    if not PEGetGroupOptions(Cr.FPrintJob, GroupNum, GroupOptions) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupOptions.Send <PEGetGroupOptions>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Store the Report Condition setting}
    {Condition with Type Mask; This obtains the Type of
     Group Condition Field from the Condition variable}
    rCondition := GroupOptions.condition;
    int1 := rCondition and PE_GC_TYPEMASK;
    case int1 of
      {"Others" have no conditions}
      PE_GC_TYPEOTHER  : rCondition := PE_GC_ANYCHANGE;
      PE_GC_TYPEDATE   : rCondition := rCondition and PE_GC_CONDITIONMASK;
      PE_GC_TYPEBOOLEAN: rCondition := rCondition and PE_GC_CONDITIONMASK;
      PE_GC_TYPETIME   : rCondition := rCondition and PE_GC_CONDITIONMASK;
    end;

    {Convert the VCL Condition setting}
    case ListItem(nIndex).FGroupType of
      gtOther   : nCondition := 0;
      gtDate    : nCondition := Ord(ListItem(nIndex).FCondition) - 1; {constants: 0..7/vcl: 1..8}
      gtBoolean : nCondition := Ord(ListItem(nIndex).FCondition) - 8; {constants: 1..6/vcl: 9..14}
      gtTime    : nCondition := Ord(ListItem(nIndex).FCondition) - 7; {constants: 8..11/vcl: 15..18}
    end;
    {If the Condition doesn't match the type, raise an error}
    if nCondition < 0 then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GROUP_TYPE,
         'GroupOptions[' + IntToStr(nIndex) + ']') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Check to see if any have changed}
    {GroupField}
    rField := String(GroupOptions.fieldName);
    if CompareStr(ListItem(nIndex).FField, rField) <> 0 then
    begin
      StrCopy(GroupOptions.fieldName, PChar(ListItem(nIndex).FField));
      Changed := True;
    end;
    {Condition}
    if nCondition <> rCondition then
    begin
      GroupOptions.condition := nCondition;
      Changed := True;
    end
    else
      GroupOptions.condition := rCondition;
    {Direction}
    if ListItem(nIndex).FDirection <> gdDefault then  {less than gdDefault}
    begin
      if Ord(ListItem(nIndex).FDirection) <> GroupOptions.sortDirection then
      begin
        GroupOptions.sortDirection := Ord(ListItem(nIndex).FDirection);
        Changed := True;
      end;
    end;
    {RepeatGH}
    if ListItem(nIndex).FRepeatGH <> cDefault then  {less than cDefault}
    begin
      if Ord(ListItem(nIndex).FRepeatGH) <> GroupOptions.repeatGroupHeader then
      begin
        GroupOptions.repeatGroupHeader := Ord(ListItem(nIndex).FRepeatGH);
        Changed := True;
      end;
    end;
    {KeepTogether}
    if ListItem(nIndex).FKeepTogether <> cDefault then
    begin
      if Ord(ListItem(nIndex).FKeepTogether) <> GroupOptions.keepGroupTogether then
      begin
        GroupOptions.keepGroupTogether := Ord(ListItem(nIndex).FKeepTogether);
        Changed := True;
      end;
    end;
    {TopNDiscardOthers}
    if ListItem(nIndex).FTopNDiscardOthers <> cDefault then
    begin
      if Ord(ListItem(nIndex).FTopNDiscardOthers) <> GroupOptions.discardOtherGroups then
      begin
        GroupOptions.discardOtherGroups := Ord(ListItem(nIndex).FTopNDiscardOthers);
        Changed := True;
      end;
    end;
    {TopNOptions}
    if ListItem(nIndex).FTopNOptions <> tnDefault then  {less than tnDefault}
    begin
      if Ord(ListItem(nIndex).FTopNOptions) <> GroupOptions.topOrBottomNGroups then
      begin
        GroupOptions.topOrBottomNGroups := Ord(ListItem(nIndex).FTopNOptions);
        Changed := True;
      end;
    end;
    {TopNGroups}
    if ListItem(nIndex).FTopNGroups > -1 then  {check for Default}
    begin
      if Ord(ListItem(nIndex).FTopNGroups) <> GroupOptions.nTopOrBottomGroups then
      begin
        GroupOptions.nTopOrBottomGroups := Ord(ListItem(nIndex).FTopNGroups);
        Changed := True;
      end;
    end;
    {TopNSortField}
    rTopNSortField := String(GroupOptions.topOrBottomNSortFieldName);
    if CompareStr(ListItem(nIndex).FTopNSortField, rTopNSortField) <> 0 then
    begin
      StrCopy(GroupOptions.topOrBottomNSortFieldName, PChar(ListItem(nIndex).FTopNSortField));
      Changed := True;
    end;

    {Send GroupOptions to Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetGroupOptions(Cr.FPrintJob, GroupNum, GroupOptions) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GroupOptions.Send <PESetGroupOptions>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetNumber : TCrGroupOptionsNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetNumber (const Value: TCrGroupOptionsNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'GroupOptions.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetField                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetField : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FField;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetField                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetField (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FField := Value;
    {Check Length}
    if Length(ListItem(FIndex).FField) > PE_FIELD_NAME_LEN then
      ListItem(FIndex).FField := Copy(ListItem(FIndex).FField, 1, PE_FIELD_NAME_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGroupType                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetGroupType : TCrGroupType;
begin
  Result := gtOther;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGroupType;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGroupType                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetGroupType (const Value: TCrGroupType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGroupType := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetCondition                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetCondition : TCrGroupCondition;
begin
  Result := AnyChange;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FCondition;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetCondition                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetCondition (const Value: TCrGroupCondition);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FCondition := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDirection                                              }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetDirection : TCrGroupDirection;
begin
  Result := gdDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDirection                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetDirection (const Value: TCrGroupDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetRepeatGH                                               }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetRepeatGH : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FRepeatGH;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetRepeatGH                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetRepeatGH (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FRepeatGH := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetKeepTogether                                           }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetKeepTogether : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetKeepTogether                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetKeepTogether (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FKeepTogether := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTopNOptions                                            }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetTopNOptions : TCrTopNOptions;
begin
  Result := tnDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTopNOptions;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetTopNOptions                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetTopNOptions (const Value: TCrTopNOptions);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FTopNOptions := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTopNGroups                                             }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetTopNGroups : smallint;
begin
  Result := -1;  {Default: no change}
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTopNGroups;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetTopNGroups                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetTopNGroups (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FTopNGroups := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTopNSortField                                          }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetTopNSortField : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTopNSortField;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetTopNSortField                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetTopNSortField (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FTopNSortField := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTopNDiscardOthers                                      }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetTopNDiscardOthers : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTopNDiscardOthers;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDiscardOthers                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetTopNDiscardOthers (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FTopNDiscardOthers := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupOptions.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GroupOptions[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.GroupOptions[nIndex]                                          }
{------------------------------------------------------------------------------}
function TCrpeGroupOptions.GetItem(nIndex: integer) : TCrpeGroupOptions;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSectionFormatItem                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormatItem.Create;
begin
  inherited Create;
  FSection              := '';
  FSuppress             := cDefault;
  FNewPageBefore        := cDefault;
  FNewPageAfter         := cDefault;
  FKeepTogether         := cDefault;
  FSuppressBlankSection := cDefault;
  FResetPageNAfter      := cDefault;
  FPrintAtBottomOfPage  := cDefault;
  FBackgroundColor      := clNone;
  FUnderlaySection      := cDefault;
  FFreeFormPlacement    := cDefault;
end;


{******************************************************************************}
{ Class TCrpeSectionFormat                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormat.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFormat.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.Clear;
var
  cnt : smallint;
begin
  {Free the Formula memory}
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ CopyFrom method                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.CopyFrom (Source: TCrpeSectionFormat);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Section);
    ListItem(cnt).FSuppress := Source[cnt].Suppress;
    ListItem(cnt).FNewPageBefore := Source[cnt].NewPageBefore;
    ListItem(cnt).FNewPageAfter := Source[cnt].NewPageAfter;
    ListItem(cnt).FKeepTogether := Source[cnt].KeepTogether;
    ListItem(cnt).FSuppressBlankSection := Source[cnt].SuppressBlankSection;
    ListItem(cnt).FResetPageNAfter := Source[cnt].ResetPageNAfter;
    ListItem(cnt).FPrintAtBottomOfPage := Source[cnt].PrintAtBottomOfPage;
    ListItem(cnt).FBackgroundColor := Source[cnt].BackgroundColor;
    ListItem(cnt).FUnderlaySection := Source[cnt].UnderlaySection;
    ListItem(cnt).FFreeFormPlacement := Source[cnt].FreeFormPlacement;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.Add (SectionName: TCrSectionFormatSection): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SectionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'SectionFormat <' + SectionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSectionFormatItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FSection := SectionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionFormat.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.IndexOf(SectionName: TCrSectionFormatSection): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.ListItem(nIndex: integer): TCrpeSectionFormatItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.Retrieve : boolean;
var
  SecOpt       : PESectionOptions;
  nSections    : smallint;
  slSectionsN,
  slSectionsS  : TStringList;
  nIndex       : smallint;
  nCode        : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the Section Format strings}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SectionFormat.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
       'SectionFormat.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  {Loop through the Sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    nCode := StrToInt(slSectionsN[nIndex]);
    Cr.SetDLLHandle;
    if not PEGetSectionFormat(Cr.FPrintJob, nCode, SecOpt) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SectionFormat.Retrieve <PEGetSectionFormat>') of
        cFalse   : Continue;
        cTrue    : begin
            slSectionsN.Free;
            slSectionsS.Free;
            Abort;
          end;
        cDefault : begin
            slSectionsN.Free;
            slSectionsS.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;

    {Section}
    Add(slSectionsS[nIndex]);
    {Visible}
    case SecOpt.visible of
      0: ListItem(FIndex).FSuppress := cTrue;
      1: ListItem(FIndex).FSuppress := cFalse;
    end;
    {NewPageBefore}
    if SecOpt.newPageBefore in [0..1] then
      ListItem(FIndex).FNewPageBefore := TCrBoolean(SecOpt.newPageBefore);
    {NewPageAfter}
    if SecOpt.newPageAfter in [0..1] then
      ListItem(FIndex).FNewPageAfter := TCrBoolean(SecOpt.newPageAfter);
    {KeepTogether}
    if SecOpt.keepTogether in [0..1] then
      ListItem(FIndex).FKeepTogether := TCrBoolean(SecOpt.keepTogether);
    {SuppressBlankSection}
    if SecOpt.suppressBlankSection in [0..1] then
      ListItem(FIndex).FSuppressBlankSection := TCrBoolean(SecOpt.suppressBlankSection);
    {ResetPageNAfter}
    if SecOpt.resetPageNAfter in [0..1] then
      ListItem(FIndex).FResetPageNAfter := TCrBoolean(SecOpt.resetPageNAfter);
    {PrintAtBottomOfPage}
    if SecOpt.printAtBottomOfPage in [0..1] then
      ListItem(FIndex).FPrintAtBottomOfPage := TCrBoolean(SecOpt.printAtBottomOfPage);
    {UnderlaySection}
    if SecOpt.underlaySection in [0..1] then
      ListItem(FIndex).FUnderlaySection := TCrBoolean(SecOpt.underlaySection);
    {FreeFormPlacement}
    if SecOpt.freeFormPlacement in [0..1] then
      ListItem(FIndex).FFreeFormPlacement := TCrBoolean(SecOpt.freeFormPlacement);
    {BackgroundColor}
    if SecOpt.backgroundColor = PE_NO_COLOR then
      ListItem(FIndex).FBackgroundColor := clNone
    else
      ListItem(FIndex).FBackgroundColor := SecOpt.backgroundColor;
    Result := True;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.Send : boolean;
var
  SecOpt           : PESectionOptions;
  nIndex,
  nCode            : Smallint;
  Changed          : boolean;
  nTmp1,nTmp2      : smallint;
  nColor1, nColor2 : TColor;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Get SectionFormat from Report}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'SectionFormat.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Cr.SetDLLHandle;
    if not PEGetSectionFormat(Cr.FPrintJob, nCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SectionFormat.Send <PEGetSectionFormat>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Visible}
    nTmp1 := SecOpt.visible;
    nTmp2 := 2;
    case ListItem(nIndex).FSuppress of
      cFalse   : nTmp2 := 1;   {translate "Suppress" to "Visible" by inverting}
      cTrue    : nTmp2 := 0;
      cDefault : nTmp2 := 2;
    end;
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.visible := nTmp2;
        Changed := True;
      end;
    end;

    {NewPageBefore}
    nTmp1 := SecOpt.newPageBefore;
    nTmp2 := Ord(ListItem(nIndex).FNewPageBefore);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.newPageBefore := nTmp2;
        Changed := True;
      end;
    end;

    {NewPageAfter}
    nTmp1 := SecOpt.newPageAfter;
    nTmp2 := Ord(ListItem(nIndex).FNewPageAfter);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.newPageAfter := nTmp2;
        Changed := True;
      end;
    end;

    {KeepTogether}
    nTmp1 := SecOpt.keepTogether;
    nTmp2 := Ord(ListItem(nIndex).FKeepTogether);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.keepTogether := nTmp2;
        Changed := True;
      end;
    end;

    {SuppressBlankSection}
    nTmp1 := SecOpt.suppressBlankSection;
    nTmp2 := Ord(ListItem(nIndex).FSuppressBlankSection);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.suppressBlankSection := nTmp2;
        Changed := True;
      end;
    end;

    {ResetPageNAfter}
    nTmp1 := SecOpt.resetPageNAfter;
    nTmp2 := Ord(ListItem(nIndex).FResetPageNAfter);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.resetPageNAfter := nTmp2;
        Changed := True;
      end;
    end;

    {PrintAtBottomOfPage}
    nTmp1 := SecOpt.printAtBottomOfPage;
    nTmp2 := Ord(ListItem(nIndex).FPrintAtBottomOfPage);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.printAtBottomOfPage := nTmp2;
        Changed := True;
      end;
    end;

    {UnderlaySection}
    nTmp1 := SecOpt.underlaySection;
    nTmp2 := Ord(ListItem(nIndex).FUnderlaySection);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.underlaySection := nTmp2;
        Changed := True;
      end;
    end;

    {FreeFormPlacement}
    nTmp1 := SecOpt.freeFormPlacement;
    nTmp2 := Ord(ListItem(nIndex).FFreeFormPlacement);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.freeFormPlacement := nTmp2;
        Changed := True;
      end;
    end;

    {BackgroundColor}
    if SecOpt.backgroundColor = PE_NO_COLOR then
      nColor1 := clNone
    else
      nColor1 := RGBToColor(SecOpt.backgroundColor);
    nColor2 := ListItem(nIndex).FBackgroundColor;
    if nColor2 <> clUnchangedColor then
    begin
      if nColor1 <> nColor2 then
      begin
        if nColor2 = clNone then
          SecOpt.backgroundColor := PE_NO_COLOR
        else
          SecOpt.backgroundColor := ColorToRGB(nColor2);
        Changed := True;
      end;
    end;

    {Send SectionFormat to Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetSectionFormat(Cr.FPrintJob, nCode, SecOpt) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SectionFormat.Send <PESetSectionFormat>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetSection : TCrSectionFormatSection;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetSection (const Value: TCrSectionFormatSection);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'SectionFormat.Section := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetHide                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.GetSuppress : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSuppress;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetHide                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetSuppress (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSuppress := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNewPageBefore                                          }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetNewPageBefore : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageBefore;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNewPageBefore                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetNewPageBefore (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageBefore := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNewPageAfter                                           }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetNewPageAfter : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageAfter;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNewPageAfter                                          }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetNewPageAfter (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageAfter := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetKeepTogether                                           }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetKeepTogether : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetKeepTogether                                          }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetKeepTogether (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FKeepTogether := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSuppressBlankSection                                   }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetSuppressBlankSection : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSuppressBlankSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSuppressBlankSection                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetSuppressBlankSection (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSuppressBlankSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetResetPageNAfter                                        }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetResetPageNAfter : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FResetPageNAfter;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetResetPageNAfter                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetResetPageNAfter (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FResetPageNAfter := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetPrintAtBottomOfPage                                    }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetPrintAtBottomOfPage : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetPrintAtBottomOfPage                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetPrintAtBottomOfPage (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPrintAtBottomOfPage := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetBackgroundColor                                        }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetBackgroundColor : TColor;
begin
  Result := clNone;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FBackgroundColor;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetBackgroundColor                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetBackgroundColor (const Value: TColor);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FBackgroundColor := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetUnderlaySection                                        }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetUnderlaySection : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUnderlaySection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetUnderlaySection                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetUnderlaySection (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FUnderlaySection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetFreeFormPlacement                                      }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetFreeFormPlacement : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FFreeFormPlacement;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetFreeFormPlacement                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetFreeFormPlacement (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FFreeFormPlacement := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    SetSection(SectionCodeToStr(Value));
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionFormat[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function  TCrpeSectionFormat.GetItem(nIndex: integer) : TCrpeSectionFormat;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSectionFormatFormulasItem                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormatFormulasItem.Create;
begin
  inherited Create;
  FSection              := '';
  FSuppress             := TCrpeString.Create;
  FNewPageBefore        := TCrpeString.Create;
  FNewPageAfter         := TCrpeString.Create;
  FKeepTogether         := TCrpeString.Create;
  FSuppressBlankSection := TCrpeString.Create;
  FResetPageNAfter      := TCrpeString.Create;
  FPrintAtBottomOfPage  := TCrpeString.Create;
  FBackgroundColor      := TCrpeString.Create;
  FUnderlaySection      := TCrpeString.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFormatFormulasItem.Destroy;
begin
  FSuppress.Free;
  FNewPageBefore.Free;
  FNewPageAfter.Free;
  FKeepTogether.Free;
  FSuppressBlankSection.Free;
  FResetPageNAfter.Free;
  FPrintAtBottomOfPage.Free;
  FBackgroundColor.Free;
  FUnderlaySection.Free;
  inherited Destroy;
end;


{******************************************************************************}
{ Class TCrpeSectionFormatFormulas                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormatFormulas.Create;
begin
  inherited Create;
  FList := TList.Create;
  sTemp := TCrpeString.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFormatFormulas.Destroy;
begin
  Clear;
  FList.Free;
  sTemp.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  sTemp.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.CopyFrom (Source: TCrpeSectionFormatFormulas);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Section);
    ListItem(cnt).FSuppress.Assign(Source[cnt].Suppress);
    ListItem(cnt).FNewPageBefore.Assign(Source[cnt].NewPageBefore);
    ListItem(cnt).FNewPageAfter.Assign(Source[cnt].NewPageAfter);
    ListItem(cnt).FKeepTogether.Assign(Source[cnt].KeepTogether);
    ListItem(cnt).FSuppressBlankSection.Assign(Source[cnt].SuppressBlankSection);
    ListItem(cnt).FResetPageNAfter.Assign(Source[cnt].ResetPageNAfter);
    ListItem(cnt).FPrintAtBottomOfPage.Assign(Source[cnt].PrintAtBottomOfPage);
    ListItem(cnt).FBackgroundColor.Assign(Source[cnt].BackgroundColor);
    ListItem(cnt).FUnderlaySection.Assign(Source[cnt].UnderlaySection);
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.Add (SectionName: TCrSectionFormatFormulasSection): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SectionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'SectionFormatFormulas <' + SectionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSectionFormatFormulasItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FSection := SectionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionFormatFormulas.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.IndexOf(SectionName: TCrSectionFormatFormulasSection): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.ListItem(nIndex: integer): TCrpeSectionFormatFormulasItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.Retrieve : boolean;
const
  PESFormulaType: array[0..8] of Smallint =(
    PE_FFN_SECTION_VISIBILITY, PE_FFN_PRINT_AT_BOTTOM_OF_PAGE,
    PE_FFN_NEW_PAGE_BEFORE, PE_FFN_NEW_PAGE_AFTER,
    PE_FFN_RESET_PAGE_N_AFTER, PE_FFN_KEEP_SECTION_TOGETHER,
    PE_FFN_SUPPRESS_BLANK_SECTION, PE_FFN_UNDERLAY_SECTION,
    PE_FFN_SECTION_BACK_COLOUR);
var
  nSections    : smallint;
  slSectionsN  : TStringList;
  slSectionsS  : TStringList;
  nIndex       : smallint;
  nIndex2      : smallint;
  nCode        : smallint;
  nFormulaName : smallint;
  TxtHandle    : HWnd;
  TxtLength    : smallint;
  TxtBuffer    : PChar;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the Section Format Formula strings}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SectionFormatFormulas.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
       'SectionFormatFormulas.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  {Loop through the Sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    nCode := StrToInt(slSectionsN[nIndex]);
    {Add a New Item: specify Section}
    Add(slSectionsS[nIndex]);

    {Loop through Formula Names}
    for nIndex2 := Low(PESFormulaType) to High(PESFormulaType) do
    begin
      nFormulaName := PESFormulaType[nIndex2];
      TxtLength := 0;
      {PH,PF,Subreport RHb,RFb: some options do not have formulas}
      if ((nCode div 1000) = PE_SECT_PAGE_HEADER) or
         ((nCode div 1000) = PE_SECT_PAGE_FOOTER) or
         ((nCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
         ((nCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
      begin
        if (nFormulaName = PE_FFN_NEW_PAGE_BEFORE) or
           (nFormulaName = PE_FFN_NEW_PAGE_AFTER) or
           (nFormulaName = PE_FFN_KEEP_SECTION_TOGETHER) or
           (nFormulaName = PE_FFN_PRINT_AT_BOTTOM_OF_PAGE) then
          Continue;
      end;

      {Get SectionFormatFormula}
      Cr.SetDLLHandle;
      if not PEGetSectionFormatFormula(Cr.FPrintJob, nCode, nFormulaName,
        TxtHandle, TxtLength) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
           'SectionFormatFormulas.Retrieve <PEGetSectionFormatFormula>') of
          cFalse   : Continue;
          cTrue    : begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          cDefault : begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Get Formula}
      TxtBuffer := StrAlloc(TxtLength);
      Cr.SetDLLHandle;
      if not PEGetHandleString(TxtHandle, TxtBuffer, TxtLength) then
      begin
        Result := False;
        StrDispose(TxtBuffer);
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SectionFormatFormulas.Retrieve <PEGetHandleString>') of
          cFalse   : Continue;
          cTrue    : begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          cDefault : begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Copy Formula text to VCL}
      case nFormulaName of
        PE_FFN_SECTION_VISIBILITY      : ListItem(FIndex).FSuppress.SetText(TxtBuffer);
        PE_FFN_NEW_PAGE_BEFORE         : ListItem(FIndex).FNewPageBefore.SetText(TxtBuffer);
        PE_FFN_NEW_PAGE_AFTER          : ListItem(FIndex).FNewPageAfter.SetText(TxtBuffer);
        PE_FFN_KEEP_SECTION_TOGETHER   : ListItem(FIndex).FKeepTogether.SetText(TxtBuffer);
        PE_FFN_SUPPRESS_BLANK_SECTION  : ListItem(FIndex).FSuppressBlankSection.SetText(TxtBuffer);
        PE_FFN_RESET_PAGE_N_AFTER      : ListItem(FIndex).FResetPageNAfter.SetText(TxtBuffer);
        PE_FFN_PRINT_AT_BOTTOM_OF_PAGE : ListItem(FIndex).FPrintAtBottomOfPage.SetText(TxtBuffer);
        PE_FFN_UNDERLAY_SECTION        : ListItem(FIndex).FUnderlaySection.SetText(TxtBuffer);
        PE_FFN_SECTION_BACK_COLOUR     : ListItem(FIndex).FBackgroundColor.SetText(TxtBuffer);
      end;
      StrDispose(TxtBuffer);
      Result := True;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.Send : boolean;
const
  PESFormulaType: array[0..8] of Smallint =(
    PE_FFN_SECTION_VISIBILITY, PE_FFN_PRINT_AT_BOTTOM_OF_PAGE,
    PE_FFN_NEW_PAGE_BEFORE, PE_FFN_NEW_PAGE_AFTER,
    PE_FFN_RESET_PAGE_N_AFTER, PE_FFN_KEEP_SECTION_TOGETHER,
    PE_FFN_SUPPRESS_BLANK_SECTION, PE_FFN_UNDERLAY_SECTION,
    PE_FFN_SECTION_BACK_COLOUR);
var
  nIndex, nIndex2,
  nCode            : smallint;
  nFormulaName     : smallint;
  Changed          : boolean;
  TxtHandle        : HWnd;
  TxtLength        : smallint;
  TxtBuffer        : PChar;
  pTmp             : PChar;
  sTmp             : string;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Loop through Sections}
  for nIndex := 0 to (Count - 1) do
  begin
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'SectionFormatFormulas.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Loop through Formula Names}
    for nIndex2 := Low(PESFormulaType) to High(PESFormulaType) do
    begin
      Changed := False;
      {Get Formula Name}
      nFormulaName := PESFormulaType[nIndex2];
      TxtLength := 0;
      {PH,PF,Subreport RHb,RFb: some options do not have formulas}
      if ((nCode div 1000) = PE_SECT_PAGE_HEADER) or
         ((nCode div 1000) = PE_SECT_PAGE_FOOTER) or
         ((nCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
         ((nCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
      begin
        if (nFormulaName = PE_FFN_NEW_PAGE_BEFORE) or
           (nFormulaName = PE_FFN_NEW_PAGE_AFTER) or
           (nFormulaName = PE_FFN_KEEP_SECTION_TOGETHER) or
           (nFormulaName = PE_FFN_PRINT_AT_BOTTOM_OF_PAGE) then
          Continue;
      end;

      {Get Formula from Report}
      Cr.SetDLLHandle;
      if not PEGetSectionFormatFormula(Cr.FPrintJob, nCode,
        nFormulaName, TxtHandle, TxtLength) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
           'SectionFormatFormulas.Send <PEGetSectionFormatFormula>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Get Formula}
      TxtBuffer := StrAlloc(TxtLength);
      Cr.SetDLLHandle;
      if not PEGetHandleString(TxtHandle, TxtBuffer, TxtLength) then
      begin
        Result := False;
        StrDispose(TxtBuffer);
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SectionFormatFormulas.Send <PEGetHandleString>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Trim off the CR/LF characters}
      case nFormulaName of
        PE_FFN_SECTION_VISIBILITY      : sTmp := RTrimList(ListItem(nIndex).FSuppress);
        PE_FFN_NEW_PAGE_BEFORE         : sTmp := RTrimList(ListItem(nIndex).FNewPageBefore);
        PE_FFN_NEW_PAGE_AFTER          : sTmp := RTrimList(ListItem(nIndex).FNewPageAfter);
        PE_FFN_KEEP_SECTION_TOGETHER   : sTmp := RTrimList(ListItem(nIndex).FKeepTogether);
        PE_FFN_SUPPRESS_BLANK_SECTION  : sTmp := RTrimList(ListItem(nIndex).FSuppressBlankSection);
        PE_FFN_RESET_PAGE_N_AFTER      : sTmp := RTrimList(ListItem(nIndex).FResetPageNAfter);
        PE_FFN_PRINT_AT_BOTTOM_OF_PAGE : sTmp := RTrimList(ListItem(nIndex).FPrintAtBottomOfPage);
        PE_FFN_UNDERLAY_SECTION        : sTmp := RTrimList(ListItem(nIndex).FUnderlaySection);
        PE_FFN_SECTION_BACK_COLOUR     : sTmp := RTrimList(ListItem(nIndex).FBackgroundColor);
      end;

      {Blank formulas are not sent}
      if Length(sTmp) = 0 then
      begin
        StrDispose(TxtBuffer);
        Continue;
      end;

      {Check for CrEmptyStr}
      if LowerCase(sTmp) = CrEmptyStr then
        sTmp := '';
      {Copy to PChar}
      pTmp := PChar(sTmp);
      {Compare it to the new Formula...If they are the same, do not send}
      if StrComp(pTmp, TxtBuffer) <> 0 then
        Changed := True;
      StrDispose(TxtBuffer);

      {Send SectionFormatFormula to Report}
      if Changed then
      begin
        Cr.SetDLLHandle;
        if not PESetSectionFormatFormula(Cr.FPrintJob, nCode,
          nFormulaName, pTmp) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'SectionFormatFormulas.Send <PESetSectionFormatFormula>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;
    end;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetSection : TCrSectionFormatFormulasSection;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetSection (const Value: TCrSectionFormatFormulasSection);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'SectionFormatFormulas.Section := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read method GetSuppress                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetSuppress : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSuppress;
end;
{------------------------------------------------------------------------------}
{ Write method SetSuppress                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetSuppress (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSuppress.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetNewPageBefore                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetNewPageBefore : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageBefore;
end;
{------------------------------------------------------------------------------}
{ Write method SetNewPageBefore                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetNewPageBefore (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageBefore.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetNewPageAfter                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetNewPageAfter : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageAfter;
end;
{------------------------------------------------------------------------------}
{ Write method SetNewPageAfter                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetNewPageAfter (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageAfter.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetKeepTogether                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetKeepTogether : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ Write method SetKeepTogether                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetKeepTogether (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FKeepTogether.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetSuppressBlankSection                                          }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetSuppressBlankSection : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSuppressBlankSection;
end;
{------------------------------------------------------------------------------}
{ Write method SetSuppressBlankSection                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetSuppressBlankSection (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSuppressBlankSection.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetResetPageNAfter                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetResetPageNAfter : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FResetPageNAfter;
end;
{------------------------------------------------------------------------------}
{ Write method SetResetPageNAfter                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetResetPageNAfter (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FResetPageNAfter.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetPrintAtBottomOfPage                                           }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetPrintAtBottomOfPage : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ Write method SetPrintAtBottomOfPage                                          }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetPrintAtBottomOfPage (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPrintAtBottomOfPage.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetBackgroundColor                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetBackgroundColor : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FBackgroundColor;
end;
{------------------------------------------------------------------------------}
{ Write method SetBackgroundColor                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetBackgroundColor (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FBackgroundColor.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetUnderlaySection                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetUnderlaySection : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUnderlaySection;
end;
{------------------------------------------------------------------------------}
{ Write method SetUnderlaySection                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetUnderlaySection (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FUnderlaySection.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    SetSection(SectionCodeToStr(Value));
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2);
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionFormatFormulas[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetItem(nIndex: integer) : TCrpeSectionFormatFormulas;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeAreaFormatItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormatItem.Create;
begin
  inherited Create;
  FSection := '';
  FHide := cDefault;
  FNewPageBefore := cDefault;
  FNewPageAfter := cDefault;
  FKeepTogether := cDefault;
  FResetPageNAfter := cDefault;
  FPrintAtBottomOfPage := cDefault;
  FSuppress := cDefault;
end;


{******************************************************************************}
{ Class TCrpeAreaFormat                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormat.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeAreaFormat.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.Clear;
var
  cnt : smallint;
begin
  {Free the Formula memory}
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.CopyFrom (Source: TCrpeAreaFormat);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Section);
    ListItem(cnt).FHide := Source[cnt].Hide;
    ListItem(cnt).FNewPageBefore := Source[cnt].NewPageBefore;
    ListItem(cnt).FNewPageAfter := Source[cnt].NewPageAfter;
    ListItem(cnt).FKeepTogether := Source[cnt].KeepTogether;
    ListItem(cnt).FResetPageNAfter := Source[cnt].ResetPageNAfter;
    ListItem(cnt).FPrintAtBottomOfPage := Source[cnt].PrintAtBottomOfPage;
    ListItem(cnt).FSuppress := Source[cnt].Suppress;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.Retrieve : boolean;
var
  SecOpt       : PESectionOptions;
  nSections    : smallint;
  slSectionsN,
  slSectionsS  : TStringList;
  nIndex       : smallint;
  nCode        : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the Area Format strings}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, True) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
       'AreaFormat.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  {Loop through the Sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    nCode := StrToInt(slSectionsN[nIndex]);
    Cr.SetDLLHandle;
    if not PEGetAreaFormat(Cr.FPrintJob, nCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'AreaFormat.Retrieve <PEGetAreaFormat>') of
        cFalse   : Continue;
        cTrue    : begin
            slSectionsN.Free;
            slSectionsS.Free;
            Abort;
          end;
        cDefault : begin
            slSectionsN.Free;
            slSectionsS.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;

    {Section}
    Add(slSectionsS[nIndex]);
    {Visible}
    case SecOpt.visible of
      0: ListItem(FIndex).FSuppress := cTrue;
      1: ListItem(FIndex).FSuppress := cFalse;
    end;
    {NewPageBefore}
    if SecOpt.newPageBefore in [0..1] then
      ListItem(FIndex).FNewPageBefore := TCrBoolean(SecOpt.newPageBefore);
    {NewPageAfter}
    if SecOpt.newPageAfter in [0..1] then
      ListItem(FIndex).FNewPageAfter := TCrBoolean(SecOpt.newPageAfter);
    {KeepTogether}
    if SecOpt.keepTogether in [0..1] then
      ListItem(FIndex).FKeepTogether := TCrBoolean(SecOpt.keepTogether);
    {ResetPageNAfter}
    if SecOpt.resetPageNAfter in [0..1] then
      ListItem(FIndex).FResetPageNAfter := TCrBoolean(SecOpt.resetPageNAfter);
    {PrintAtBottomOfPage}
    if SecOpt.printAtBottomOfPage in [0..1] then
      ListItem(FIndex).FPrintAtBottomOfPage := TCrBoolean(SecOpt.printAtBottomOfPage);
    {ShowArea}
    case SecOpt.showArea of
      0: ListItem(FIndex).FHide := cTrue;
      1: ListItem(FIndex).FHide := cFalse;
    end;
    Result := True;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.Add (SectionName: TCrAreaFormatSection): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SectionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'AreaFormat <' + SectionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeAreaFormatItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FSection := SectionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'AreaFormat.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.Send : boolean;
var
  SecOpt       : PESectionOptions;
  nIndex,
  nCode        : smallint;
  Changed      : boolean;
  nTmp1,nTmp2  : smallint;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Loop through Area settings}
  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
         'AreaFormat.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get AreaFormat settings from Report}
    Cr.SetDLLHandle;
    if not PEGetAreaFormat(Cr.FPrintJob, nCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'AreaFormat.Send <PEGetAreaFormat>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Visible}
    nTmp1 :=  SecOpt.visible;
    nTmp2 := 2;
    case ListItem(nIndex).FSuppress of
      cFalse   : nTmp2 := 1; {translate "Suppress" to "Visible" by inverting}
      cTrue    : nTmp2 := 0;
      cDefault : nTmp2 := 2;
    end;
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.visible := nTmp2;
        Changed := True;
      end;
    end;

    {NewPageBefore}
    nTmp1 := SecOpt.newPageBefore;
    nTmp2 := Ord(ListItem(nIndex).FNewPageBefore);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.newPageBefore := nTmp2;
        Changed := True;
      end;
    end;

    {NewPageAfter}
    nTmp1 := SecOpt.newPageAfter;
    nTmp2 := Ord(ListItem(nIndex).FNewPageAfter);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.newPageAfter := nTmp2;
        Changed := True;
      end;
    end;

    {KeepTogether}
    nTmp1 := SecOpt.keepTogether;
    nTmp2 := Ord(ListItem(nIndex).FKeepTogether);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.keepTogether := nTmp2;
        Changed := True;
      end;
    end;

    {ResetPageNAfter}
    nTmp1 := SecOpt.resetPageNAfter;
    nTmp2 := Ord(ListItem(nIndex).FResetPageNAfter);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.resetPageNAfter := nTmp2;
        Changed := True;
      end;
    end;

    {PrintAtBottomOfPage}
    nTmp1 := SecOpt.printAtBottomOfPage;
    nTmp2 := Ord(ListItem(nIndex).FPrintAtBottomOfPage);
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.printAtBottomOfPage := nTmp2;
        Changed := True;
      end;
    end;

    {ShowArea}
    nTmp1 :=  SecOpt.showArea;
    nTmp2 := 2;
    case ListItem(nIndex).FHide of
      cFalse   : nTmp2 := 1;   {translate "Hide" to "showArea" by inverting}
      cTrue    : nTmp2 := 0;
      cDefault : nTmp2 := 2;
    end;
    if nTmp2 < 2 then
    begin
      if nTmp1 <> nTmp2 then
      begin
        SecOpt.showArea := nTmp2;
        Changed := True;
      end;
    end;

    {Send AreaFormat to Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetAreaFormat(Cr.FPrintJob, nCode, SecOpt) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'AreaFormat.Send <PESetAreaFormat>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.IndexOf(SectionName: TCrAreaFormatSection): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.ListItem(nIndex: integer): TCrpeAreaFormatItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.GetSection : TCrAreaFormatSection;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetSection (const Value: TCrAreaFormatSection);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'AreaFormat.Section := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetHide                                                   }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.GetHide : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FHide;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetHide                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetHide (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FHide := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNewPageBefore                                          }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetNewPageBefore : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageBefore;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNewPageBefore                                         }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetNewPageBefore (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageBefore := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNewPageAfter                                           }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetNewPageAfter : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageAfter;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNewPageAfter                                          }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetNewPageAfter (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageAfter := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetKeepTogether                                           }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetKeepTogether : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetKeepTogether                                          }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetKeepTogether (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FKeepTogether := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetResetPageNAfter                                        }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetResetPageNAfter : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FResetPageNAfter;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetResetPageNAfter                                       }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetResetPageNAfter (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FResetPageNAfter := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetPrintAtBottomOfPage                                    }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetPrintAtBottomOfPage : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetPrintAtBottomOfPage                                   }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetPrintAtBottomOfPage (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPrintAtBottomOfPage := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSuppress                                               }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetSuppress : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSuppress;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSuppress                                              }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetSuppress (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSuppress := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    SetSection(SectionCodeToStr(Value));
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'AreaFormat[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function  TCrpeAreaFormat.GetItem(nIndex: integer) : TCrpeAreaFormat;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeAreaFormatFormulasItem                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormatFormulasItem.Create;
begin
  inherited Create;
  FSection              := '';
  FSuppress             := TCrpeString.Create;
  FHide                 := TCrpeString.Create;
  FNewPageBefore        := TCrpeString.Create;
  FNewPageAfter         := TCrpeString.Create;
  FKeepTogether         := TCrpeString.Create;
  FResetPageNAfter      := TCrpeString.Create;
  FPrintAtBottomOfPage  := TCrpeString.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeAreaFormatFormulasItem.Destroy;
begin
  FSuppress.Free;
  FHide.Free;
  FNewPageBefore.Free;
  FNewPageAfter.Free;
  FKeepTogether.Free;
  FResetPageNAfter.Free;
  FPrintAtBottomOfPage.Free;
  inherited Destroy;
end;


{******************************************************************************}
{ Class TCrpeAreaFormatFormulas                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormatFormulas.Create;
begin
  inherited Create;
  FList := TList.Create;
  sTemp := TCrpeString.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeAreaFormatFormulas.Destroy;
begin
  Clear;
  FList.Free;
  sTemp.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  sTemp.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.CopyFrom (Source: TCrpeAreaFormatFormulas);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Section);
    ListItem(cnt).FSuppress.Assign(Source[cnt].Suppress);
    ListItem(cnt).FHide.Assign(Source[cnt].Hide);
    ListItem(cnt).FNewPageBefore.Assign(Source[cnt].NewPageBefore);
    ListItem(cnt).FNewPageAfter.Assign(Source[cnt].NewPageAfter);
    ListItem(cnt).FKeepTogether.Assign(Source[cnt].KeepTogether);
    ListItem(cnt).FResetPageNAfter.Assign(Source[cnt].ResetPageNAfter);
    ListItem(cnt).FPrintAtBottomOfPage.Assign(Source[cnt].PrintAtBottomOfPage);
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.IndexOf(SectionName: TCrAreaFormatFormulasSection): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.ListItem(nIndex: integer): TCrpeAreaFormatFormulasItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.Add (SectionName: TCrAreaFormatFormulasSection): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SectionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'SectionFormatFormulas <' + SectionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeAreaFormatFormulasItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FSection := SectionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'AreaFormatFormulas.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.Retrieve : boolean;
const
  PEAFormulaType: array[0..6] of Smallint =(
    PE_FFN_AREASECTION_VISIBILITY, PE_FFN_SHOW_AREA,
    PE_FFN_NEW_PAGE_BEFORE, PE_FFN_NEW_PAGE_AFTER,
    PE_FFN_KEEP_SECTION_TOGETHER, PE_FFN_RESET_PAGE_N_AFTER,
    PE_FFN_PRINT_AT_BOTTOM_OF_PAGE);
var
  nSections    : smallint;
  slSectionsN,
  slSectionsS  : TStringList;
  nIndex       : smallint;
  nIndex2      : smallint;
  nCode        : smallint;
  nFormulaName : smallint;
  TxtHandle    : HWnd;
  TxtLength    : smallint;
  TxtBuffer    : PChar;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the Area Format Formula strings}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormatFormulas.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, True) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
       'AreaFormatFormulas.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  {Loop through the Sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    nCode := StrToInt(slSectionsN[nIndex]);
    {Add Section item to AreaFormatFormulas}
    Add(slSectionsS[nIndex]);

    {Loop through Formula Names}
    for nIndex2 := Low(PEAFormulaType) to High(PEAFormulaType) do
    begin
      nFormulaName := PEAFormulaType[nIndex2];
      TxtLength := 0;
      {Report Header : NewPageBefore does not have a formula}
      if ((nCode div 1000) = PE_SECT_REPORT_HEADER) and
          (nFormulaName = PE_FFN_NEW_PAGE_BEFORE) then
        Continue;
      {Report Footer : NewPageAfter does not have a formula}
      if ((nCode div 1000) = PE_SECT_REPORT_FOOTER) and
          (nFormulaName = PE_FFN_NEW_PAGE_AFTER) then
        Continue;
      {Page Header & Footer : some options do not have formulas}
      if ((nCode div 1000) = PE_SECT_PAGE_HEADER) or
         ((nCode div 1000) = PE_SECT_PAGE_FOOTER) then
      begin
        if (nFormulaName = PE_FFN_SHOW_AREA) or
           (nFormulaName = PE_FFN_NEW_PAGE_BEFORE) or
           (nFormulaName = PE_FFN_NEW_PAGE_AFTER) or
           (nFormulaName = PE_FFN_KEEP_SECTION_TOGETHER) or
           (nFormulaName = PE_FFN_PRINT_AT_BOTTOM_OF_PAGE) then
          Continue;
      end;

      Cr.SetDLLHandle;
      if not PEGetAreaFormatFormula(Cr.FPrintJob, nCode, nFormulaName, TxtHandle, TxtLength) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
           'AreaFormatFormulas.Retrieve <PEGetAreaFormatFormula>') of
          cFalse   : Continue;
          cTrue    : begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          cDefault : begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Get Formula}
      TxtBuffer := StrAlloc(TxtLength);
      Cr.SetDLLHandle;
      if not PEGetHandleString(TxtHandle, TxtBuffer, TxtLength) then
      begin
        Result := False;
        StrDispose(TxtBuffer);
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'AreaFormatFormulas.Retrieve <PEGetHandleString>') of
          cFalse   : Continue;
          cTrue    : begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          cDefault : begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
        end;
      end;

      {Copy Formula text to VCL}
      case nFormulaName of
        PE_FFN_AREASECTION_VISIBILITY  : ListItem(FIndex).FSuppress.SetText(TxtBuffer);
        PE_FFN_SHOW_AREA               : ListItem(FIndex).FHide.SetText(TxtBuffer);
        PE_FFN_NEW_PAGE_BEFORE         : ListItem(FIndex).FNewPageBefore.SetText(TxtBuffer);
        PE_FFN_NEW_PAGE_AFTER          : ListItem(FIndex).FNewPageAfter.SetText(TxtBuffer);
        PE_FFN_KEEP_SECTION_TOGETHER   : ListItem(FIndex).FKeepTogether.SetText(TxtBuffer);
        PE_FFN_RESET_PAGE_N_AFTER      : ListItem(FIndex).FResetPageNAfter.SetText(TxtBuffer);
        PE_FFN_PRINT_AT_BOTTOM_OF_PAGE : ListItem(FIndex).FPrintAtBottomOfPage.SetText(TxtBuffer);
      end;
      StrDispose(TxtBuffer);
      Result := True;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.Send : boolean;
const
  PEAFormulaType: array[0..6] of Smallint =(
    PE_FFN_AREASECTION_VISIBILITY, PE_FFN_SHOW_AREA,
    PE_FFN_NEW_PAGE_BEFORE, PE_FFN_NEW_PAGE_AFTER,
    PE_FFN_KEEP_SECTION_TOGETHER, PE_FFN_RESET_PAGE_N_AFTER,
    PE_FFN_PRINT_AT_BOTTOM_OF_PAGE);
var
  nIndex, nIndex2,
  nCode            : smallint;
  nFormulaName     : smallint;
  Changed          : boolean;
  TxtHandle        : HWnd;
  TxtLength        : smallint;
  TxtBuffer        : PChar;
  pTmp             : PChar;
  sTmp             : string;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Loop through Sections}
  for nIndex := 0 to (Count - 1) do
  begin
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'AreaFormatFormulas.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Loop through Formulas}
    for nIndex2 := Low(PEAFormulaType) to High(PEAFormulaType) do
    begin
      Changed := False;
      {Get Formula Name}
      nFormulaName := PEAFormulaType[nIndex2];
      TxtLength := 0;

      {Report Header : NewPageBefore does not have a formula}
      if ((nCode div 1000) = PE_SECT_REPORT_HEADER) and
          (nFormulaName = PE_FFN_NEW_PAGE_BEFORE) then
        Continue;
      {Report Footer : NewPageAfter does not have a formula}
      if ((nCode div 1000) = PE_SECT_REPORT_FOOTER) and
          (nFormulaName = PE_FFN_NEW_PAGE_AFTER) then
        Continue;
      {Page Header & Footer : some options do not have formulas}
      if ((nCode div 1000) = PE_SECT_PAGE_HEADER) or
         ((nCode div 1000) = PE_SECT_PAGE_FOOTER) then
      begin
        if (nFormulaName = PE_FFN_SHOW_AREA) or
           (nFormulaName = PE_FFN_NEW_PAGE_BEFORE) or
           (nFormulaName = PE_FFN_NEW_PAGE_AFTER) or
           (nFormulaName = PE_FFN_KEEP_SECTION_TOGETHER) or
           (nFormulaName = PE_FFN_PRINT_AT_BOTTOM_OF_PAGE) then
          Continue;
      end;

      {Get Formula from Report}
      Cr.SetDLLHandle;
      if not PEGetAreaFormatFormula(Cr.FPrintJob, nCode, nFormulaName,
        TxtHandle, TxtLength) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'AreaFormatFormulas.Send <PEGetAreaFormatFormula>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Get Formula}
      TxtBuffer := StrAlloc(TxtLength);
      Cr.SetDLLHandle;
      if not PEGetHandleString(TxtHandle, TxtBuffer, TxtLength) then
      begin
        Result := False;
        StrDispose(TxtBuffer);
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'AreaFormatFormulas.Send <PEGetHandleString>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Get Formula text from VCL}
      case nFormulaName of
        PE_FFN_AREASECTION_VISIBILITY  : sTmp := RTrimList(ListItem(nIndex).FSuppress);
        PE_FFN_SHOW_AREA               : sTmp := RTrimList(ListItem(nIndex).FHide);
        PE_FFN_NEW_PAGE_BEFORE         : sTmp := RTrimList(ListItem(nIndex).FNewPageBefore);
        PE_FFN_NEW_PAGE_AFTER          : sTmp := RTrimList(ListItem(nIndex).FNewPageAfter);
        PE_FFN_KEEP_SECTION_TOGETHER   : sTmp := RTrimList(ListItem(nIndex).FKeepTogether);
        PE_FFN_RESET_PAGE_N_AFTER      : sTmp := RTrimList(ListItem(nIndex).FResetPageNAfter);
        PE_FFN_PRINT_AT_BOTTOM_OF_PAGE : sTmp := RTrimList(ListItem(nIndex).FPrintAtBottomOfPage);
      end;

      {Blank formulas are not sent}
      if Length(sTmp) = 0 then
      begin
        StrDispose(TxtBuffer);
        Continue;
      end;

      {Check for CrEmptyStr}
      if LowerCase(sTmp) = CrEmptyStr then
        sTmp := '';
      {Copy to PChar}
      pTmp := PChar(sTmp);

      {Compare it to the new Formula...If they are the same, do not send}
      if StrComp(pTmp, TxtBuffer) <> 0 then
        Changed := True;
      StrDispose(TxtBuffer);

      {Send AreaFormatFormula to Report}
      if Changed then
      begin
        Cr.SetDLLHandle;
        if not PESetAreaFormatFormula(Cr.FPrintJob, nCode,
          nFormulaName, pTmp) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'AreaFormatFormulas.Send <PESetAreaFormatFormula>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;
    end;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetSection : TCrAreaFormatFormulasSection;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetSection (const Value: TCrAreaFormatFormulasSection);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'AreaFormatFormulas.Section := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ Read method GetSuppress                                                      }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetSuppress : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSuppress;
end;
{------------------------------------------------------------------------------}
{ Write method SetSuppress                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetSuppress (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSuppress.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetHide                                                          }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetHide : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FHide;
end;
{------------------------------------------------------------------------------}
{ Write method SetHide                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetHide (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FHide.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetNewPageBefore                                                 }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetNewPageBefore : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageBefore;
end;
{------------------------------------------------------------------------------}
{ Write method SetNewPageBefore                                                }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetNewPageBefore (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageBefore.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetNewPageAfter                                                  }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetNewPageAfter : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNewPageAfter;
end;
{------------------------------------------------------------------------------}
{ Write method SetNewPageAfter                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetNewPageAfter (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNewPageAfter.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetKeepTogether                                                  }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetKeepTogether : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ Write method SetKeepTogether                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetKeepTogether (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FKeepTogether.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetResetPageNAfter                                               }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetResetPageNAfter : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FResetPageNAfter;
end;
{------------------------------------------------------------------------------}
{ Write method SetResetPageNAfter                                              }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetResetPageNAfter (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FResetPageNAfter.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read method GetPrintAtBottomOfPage                                           }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetPrintAtBottomOfPage : TCrpeString;
begin
  Result := sTemp;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ Write method SetPrintAtBottomOfPage                                          }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetPrintAtBottomOfPage (const Value: TCrpeString);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPrintAtBottomOfPage.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    SetSection(SectionCodeToStr(Value));
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'AreaFormatFormulas[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetItem(nIndex: integer) : TCrpeAreaFormatFormulas;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSectionFontItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFontItem.Create;
begin
  inherited Create;
  FSection       := '';
  FScope         := fsBoth;
  FName          := '';
  FPitch         := fpDefault;
  FFamily        := ffDefault;
  FCharSet       := fcDefault;
  FSize          := 0;
  FItalic        := cDefault;
  FUnderlined    := cDefault;
  FStrikeThrough := cDefault;
  FWeight        := fwDefault;
end;


{******************************************************************************}
{ Class TCrpeSectionFont                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFont.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFont.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.CopyFrom (Source: TCrpeSectionFont);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Section);
    ListItem(cnt).FScope := Source[cnt].Scope;
    ListItem(cnt).FName := Source[cnt].Name;
    ListItem(cnt).FPitch := Source[cnt].Pitch;
    ListItem(cnt).FFamily := Source[cnt].Family;
    ListItem(cnt).FCharSet := Source[cnt].CharSet;
    ListItem(cnt).FSize := Source[cnt].Size;
    ListItem(cnt).FItalic := Source[cnt].Italic;
    ListItem(cnt).FUnderlined := Source[cnt].Underlined;
    ListItem(cnt).FStrikeThrough := Source[cnt].StrikeThrough;
    ListItem(cnt).FWeight := Source[cnt].Weight;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.Add(SectionName: TCrSectionFontSection): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SectionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'SectionFont <' + SectionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSectionFontItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FSection := SectionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionFont.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.IndexOf(SectionName: TCrSectionFontSection): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FSection = SectionName then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.ListItem(nIndex: integer): TCrpeSectionFontItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.Retrieve : boolean;
var
  nSections    : smallint;
  slSectionsS,
  slSectionsN  : TStringList;
  nIndex       : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the SectionFont lists}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SectionFont.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'SectionFont.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Sections to set Font Information}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Set Section Font Values to default}
    Add(slSectionsS[nIndex]);
    Result := True;
  end;
  slSectionsS.Free;
  slSectionsN.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.Send : boolean;
var
  nIndex         : smallint;
  nCode          : smallint;
  nScope         : smallint;
  sFont          : string;
  nFamily        : smallint;
  nPitch         : smallint;
  nCharSet       : smallint;
  nSize          : smallint;
  nItalic        : smallint;
  nUnderlined    : smallint;
  nStrikeThrough : smallint;
  nWeight        : smallint;
  Changed        : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Loop through SectionFont items}
  for nIndex := 0 to (Count - 1) do
  begin
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'SectionFont.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Scope}
    nScope := PE_FIELDS or PE_TEXT;
    case ListItem(nIndex).FScope of
      fsFields : nScope := PE_FIELDS;
      fsText   : nScope := PE_TEXT;
      fsBoth   : nScope := PE_FIELDS or PE_TEXT;
    end;
    {Name}
    sFont := ListItem(nIndex).FName;
    {Family}
    nFamily := FF_DONTCARE;
    case ListItem(nIndex).FFamily of
      ffDefault : nFamily := FF_DONTCARE;
      ffRoman   : nFamily := FF_ROMAN;
      ffSwiss   : nFamily := FF_SWISS;
      ffModern  : nFamily := FF_MODERN;
      ffScript  : nFamily := FF_SCRIPT;
      ffDecorative : nFamily := FF_DECORATIVE;
    end;
    {Pitch}
    nPitch := DEFAULT_PITCH;
    case ListItem(nIndex).FPitch of
      fpDefault  : nPitch := DEFAULT_PITCH;
      fpVariable : nPitch := VARIABLE_PITCH;
      fpFixed    : nPitch := FIXED_PITCH;
    end;
    {CharSet}
    nCharSet := DEFAULT_CHARSET;
    case ListItem(nIndex).FCharSet of
      fcAnsi        : nCharSet := ANSI_CHARSET;
      fcDefault     : nCharSet := DEFAULT_CHARSET;
      fcSymbol      : nCharSet := SYMBOL_CHARSET;
      fcShiftJis    : nCharSet := SHIFTJIS_CHARSET;
      fcHangeul     : nCharSet := HANGEUL_CHARSET;
      fcChineseBig5 : nCharSet := CHINESEBIG5_CHARSET;
      fcOEM         : nCharSet := OEM_CHARSET;
    end;
    {Size}
    nSize := ListItem(nIndex).FSize;
    {Italic}
    nItalic := PE_UNCHANGED;
    case ListItem(nIndex).FItalic of
      cFalse   : nItalic := 0;
      cTrue    : nItalic := 1;
      cDefault : nItalic := PE_UNCHANGED;
    end;
    {Underlined}
    nUnderlined := PE_UNCHANGED;
    case ListItem(nIndex).FUnderlined of
      cFalse   : nUnderlined := 0;
      cTrue    : nUnderlined := 1;
      cDefault : nUnderlined := PE_UNCHANGED;
    end;
    {StrikeThrough}
    nStrikeThrough := PE_UNCHANGED;
    case ListItem(nIndex).FStrikeThrough of
      cFalse   : nStrikeThrough := 0;
      cTrue    : nStrikeThrough := 1;
      cDefault : nStrikeThrough := PE_UNCHANGED;
    end;
    {Weight}
    nWeight := FW_DONTCARE;   {no change}
    case ListItem(nIndex).FWeight of
      fwDefault    : nWeight := FW_DONTCARE;
      fwThin       : nWeight := FW_THIN;
      fwExtraLight : nWeight := FW_EXTRALIGHT;
      fwLight      : nWeight := FW_LIGHT;
      fwNormal     : nWeight := FW_NORMAL;
      fwMedium     : nWeight := FW_MEDIUM;
      fwSemiBold   : nWeight := FW_SEMIBOLD;
      fwBold       : nWeight := FW_BOLD;
      fwExtraBold  : nWeight := FW_EXTRABOLD;
      fwHeavy      : nWeight := FW_HEAVY;
    end;

    if (sFont = '') and (nFamily = FF_DONTCARE) and
       (nPitch = DEFAULT_PITCH) and (nCharSet = DEFAULT_CHARSET) and
       (nSize = 0) and (nItalic = PE_UNCHANGED) and (nUnderlined = PE_UNCHANGED) and
       (nStrikeThrough = PE_UNCHANGED) and (nWeight = FW_DONTCARE) then
      Changed := False
    else
      Changed := True;

    {Send the Font to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetFont(Cr.FPrintJob, nCode, nScope, PChar(sFont), nFamily,
        nPitch, nCharSet, nSize, nItalic, nUnderlined, nStrikethrough, nWeight) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SectionFont.Send <PESetFont>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetSection : TCrSectionFontSection;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetSection (const Value: TCrSectionFontSection);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'SectionFont.Section := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetScope                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetScope : TCrFontScope;
begin
  Result := fsBoth;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FScope;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetScope                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetScope (const Value: TCrFontScope);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FScope := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetName                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetName : TFontName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetName                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetName (const Value: TFontName);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FName := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetPitch                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetPitch : TFontPitch;
begin
  Result := fpDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPitch;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetPitch                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetPitch (const Value: TFontPitch);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPitch := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetFamily                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetFamily : TCrFontFamily;
begin
  Result := ffDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FFamily;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetFamily                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetFamily (const Value: TCrFontFamily);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FFamily := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetCharSet                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetCharSet : TCrFontCharSet;
begin
  Result := fcDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FCharSet;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetCharSet                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetCharSet (const Value: TCrFontCharSet);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FCharSet := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSize                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetSize : smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSize;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSize                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetSize (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSize := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetItalic                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetItalic : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FItalic;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetItalic                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetItalic (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FItalic := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetUnderlined                                             }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetUnderlined : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUnderlined;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetUnderlined                                            }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetUnderlined (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FUnderlined := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetStrikeThrough                                          }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetStrikeThrough : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FStrikeThrough;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetStrikeThrough                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetStrikeThrough (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FStrikeThrough := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetWeight                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetWeight : TCrFontWeight;
begin
  Result := fwDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FWeight;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetWeight                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetWeight (const Value: TCrFontWeight);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FWeight := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection[FIndex], nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    SetSection(SectionCodeToStr(Value));
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionFont[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetItem(nIndex: integer) : TCrpeSectionFont;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSectionHeightItem                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionHeightItem.Create;
begin
  inherited Create;
  FSection := '';
  FHeight := -1;
end;


{******************************************************************************}
{ Class TCrpeSectionHeight                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionHeight.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionHeight.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.Clear;
var
  cnt : smallint;
begin
  {Free the Formula memory}
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.CopyFrom (Source: TCrpeSectionHeight);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Section);
    ListItem(cnt).FHeight := Source[cnt].Height;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.Retrieve : boolean;
var
  nSections    : smallint;
  slSectionsN,
  slSectionsS  : TStringList;
  nHeight      : smallint;
  nIndex       : smallint;
  nCode        : smallint;
  bRet         : Bool;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the SectionHeight lists}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SectionHeight.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'SectionHeight.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Sections to set Font Information}
  for nIndex := 0 to (nSections - 1) do
  begin
    nCode := StrToInt(slSectionsN[nIndex]);
    {SCR5 and 6}
    Cr.SetDLLHandle;
    if Cr.FVersion.FMajor < 7 then
      bRet := PEGetMinimumSectionHeight(Cr.FPrintJob, nCode, nHeight)
    {SCR7}
    else
      bRet := PEGetSectionHeight(Cr.FPrintJob, nCode, nHeight);
    if not bRet then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SectionHeight.Retrieve <PEGetSectionHeight>') of
        cFalse   : Continue;
        cTrue    : begin
            slSectionsN.Free;
            slSectionsS.Free;
            Abort;
          end;
        cDefault : begin
            slSectionsN.Free;
            slSectionsS.Free;
            raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
      end;
    end;
    Add(slSectionsS[nIndex]);
    ListItem(FIndex).FHeight := nHeight;
    Result := True;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.Add (SectionName: TCrSectionHeightSection): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(SectionName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'SectionHeight.Add <' + SectionName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSectionHeightItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FSection := SectionName;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionHeight.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.IndexOf(SectionName: TCrSectionHeightSection): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if CompareText(ListItem(cnt).FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem Method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.ListItem(nIndex: integer): TCrpeSectionHeightItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.Send : boolean;
var
  nIndex,
  nHeightNew,
  nCode,
  nHeight  : Smallint;
  bRet     : Bool;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  nHeight := 0;

  for nIndex := 0 to (Count - 1) do
  begin
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'SectionHeight.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {SCR5 & 6}
    Cr.SetDLLHandle;
    if Cr.FVersion.FMajor < 7 then
      bRet := PEGetMinimumSectionHeight(Cr.FPrintJob, nCode, nHeight)
    {SCR7+}
    else
      bRet := PEGetSectionHeight(Cr.FPrintJob, nCode, nHeight);
    if not bRet then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SectionHeight.Send <PEGetSectionHeight>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    nHeightNew := ListItem(nIndex).FHeight;

    {If Changed, set new Height}
    // Be aware that setting the height smaller than the
    // original section height that the Report was designed with,
    // will cause an error!}
    if nHeightNew <> nHeight then
    begin
      {SCR5 & 6}
      Cr.SetDLLHandle;
      if Cr.FVersion.FMajor < 7 then
        bRet := PESetMinimumSectionHeight(Cr.FPrintJob, nCode, nHeightNew)
      {SCR7+}
      else
        bRet := PESetSectionHeight(Cr.FPrintJob, nCode, nHeightNew);
      if not bRet then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'SectionHeight.Send <PESetSectionHeight>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.GetSection : TCrSectionHeightSection;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.SetSection (const Value: TCrSectionHeightSection);
var
  nIndex : integer;
begin
  if Value = '' then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'SectionHeight.Section := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetHeight                                                 }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.GetHeight : smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FHeight;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetHeight                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.SetHeight (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FHeight := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    SetSection(SectionCodeToStr(Value));
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionHeight.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SectionHeight[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionHeight[nIndex]                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionHeight.GetItem(nIndex: integer) : TCrpeSectionHeight;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSessionInfoItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSessionInfoItem.Create;
begin
  inherited Create;
  FTable         := -1;
  FUserID        := '';
  FDBPassword    := '';
  FUserPassword  := '';
  FHandle        := 0;
end;


{******************************************************************************}
{ Class TCrpeSessionInfo                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSessionInfo.Create;
begin
  inherited Create;
  FList := TList.Create;
  FPropagate := True;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSessionInfo.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.Clear;
var
  cnt : smallint;
begin
  {Free the Formula memory}
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FPropagate := True;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.CopyFrom (Source: TCrpeSessionInfo);
var
  cnt : integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Table);
    ListItem(cnt).FUserID := Source[cnt].UserID;
    ListItem(cnt).FDBPassword := Source[cnt].DBPassword;
    ListItem(cnt).FUserPassword := Source[cnt].UserPassword;
    ListItem(cnt).FHandle := Source[cnt].Handle;
  end;
  FPropagate := Source.Propagate;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.Count: integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.IndexOf (TableNumber: TCrSessionInfoTable): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FTable = TableNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.ListItem(nIndex: integer): TCrpeSessionInfoItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.Add (TableNumber: TCrSessionInfoTable): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(TableNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'SessionInfo <' + IntToStr(TableNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeSessionInfoItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FTable := TableNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SessionInfo.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.Retrieve : boolean;
var
  SInfo    : PESessionInfo;
  nTables  : smallint;
  nIndex   : smallint;
  bProp    : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the SessionInfo object but keep Propagate setting}
  bProp := FPropagate;
  Clear;
  FPropagate := bProp;

  {Get the number of Tables}
  Cr.SetDLLHandle;
  nTables := PEGetNTables(Cr.FPrintJob);
  if (nTables = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.Retrieve <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    Cr.SetDLLHandle;
    if not PEGetNthTableSessionInfo(Cr.FPrintJob, nIndex, SInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SessionInfo.Retrieve <PEGetNthTableSessionInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Add(nIndex);
    ListItem(FIndex).FUserID := String(SInfo.UserID);
    ListItem(FIndex).FDBPassword := String(SInfo.Password);
    ListItem(FIndex).FUserPassword := '';
    ListItem(FIndex).FHandle := 0;
    FPropagate := True;
    Result := True;
  end;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.Send : boolean;
var
  SessInfo  : PESessionInfo;
  nTables   : smallint;
  nTable    : smallint;
  sPassword : string;
  nIndex    : integer;
  cnt       : smallint;
  xUserID   : string;
  Changed   : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  Changed := False;

  Cr.SetDLLHandle;
  nTables := PEGetNTables(Cr.FPrintJob);
  if (nTables = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       'SessionInfo.Send <PEGetNTables>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FPropagate then
    cnt := 0
  else
    cnt := (Count - 1);

  for nIndex := 0 to cnt do
  begin
    {TableNumber}
    nTable := ListItem(nIndex).FTable;
    {Check for invalid Table number}
    if nTable > (nTables - 1) then
    begin
      Result := False;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SESSIONINFO_NUMBER,
          'SessionInfo[' + IntToStr(nIndex) + ']') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get SessionInfo from Report}
    Cr.SetDLLHandle;
    if not PEGetNthTableSessionInfo(Cr.FPrintJob, nTable, SessInfo) then
    begin
      Result := False;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SessionInfo.Send <PEGetNthTableSessionInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {UserID}
    xUserID := String(SessInfo.UserID);
    if ListItem(nIndex).FUserID <> '' then
    begin
      if CompareStr(xUserID, ListItem(nIndex).FUserID) <> 0 then
      begin
        StrCopy(SessInfo.UserId, PChar(ListItem(nIndex).FUserID));
        Changed := True;
      end;
    end;

    {UserPassword}
    sPassword := Trim(ListItem(nIndex).FUserPassword);
    {DBPassword}
    if not IsStrEmpty(ListItem(nIndex).FDBPassword) then
      sPassword := ListItem(nIndex).FUserPassword + Chr(10) + ListItem(nIndex).FDBPassword;
    {Check Length}
    if Length(sPassword) > PE_SESS_PASSWORD_LEN then
      sPassword := Copy(sPassword, 1, PE_SESS_PASSWORD_LEN);
    if not IsStrEmpty(sPassword) then
    begin
      StrCopy(SessInfo.Password, PChar(sPassword));
      Changed := True;
    end;

    {Handle}
    if ListItem(nIndex).FHandle > 0 then
    begin
      SessInfo.SessionHandle := ListItem(nIndex).FHandle;
      Changed := True;
    end;

    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetNthTableSessionInfo(Cr.FPrintJob, nTable, SessInfo, FPropagate) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
             'SessionInfo.Send <PESetNthTableSessionInfo>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Access method GetTable                                                       }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.Test : boolean;
var
  SessInfo    : PESessionInfo;
  nTable      : integer;
  FPropagate  : Bool;
  sPassword   : string;
  hTextHandle : HWnd;
  nTextLen    : Smallint;
  pErrorText  : PChar;
begin
  Result := False;
  {If there are no SessionInfo items set, Exit}
  if (Count = 0) then
    Exit;
  {Check that PrintJob is open}
  if not Cr.OpenPrintJob then
    Exit;
  FPropagate := False;

  {Get the current Table Number}
  nTable := ListItem(FIndex).FTable;

  {Get SessionInfo from Report}
  Cr.SetDLLHandle;
  if not PEGetNthTableSessionInfo(Cr.FPrintJob, nTable, SessInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.Test <PEGetNthTableSessionInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {UserID}
  if ListItem(FIndex).FUserID <> '' then
    StrCopy(SessInfo.UserId, PChar(ListItem(FIndex).FUserID));

  {UserPassword}
  sPassword := Trim(ListItem(FIndex).FUserPassword);
  {DBPassword}
  if not IsStrEmpty(ListItem(FIndex).FDBPassword) then
    sPassword := ListItem(FIndex).FUserPassword + Chr(10) + ListItem(FIndex).FDBPassword;
  {Check Length}
  if Length(sPassword) > PE_SESS_PASSWORD_LEN then
    sPassword := Copy(sPassword, 1, PE_SESS_PASSWORD_LEN);
  if not IsStrEmpty(sPassword) then
    StrCopy(SessInfo.Password, PChar(sPassword));

  {Handle}
  if ListItem(FIndex).FHandle > 0 then
    SessInfo.SessionHandle := ListItem(FIndex).FHandle;

  {Set SessionInfo into Report}
  Cr.SetDLLHandle;
  if not PESetNthTableSessionInfo(Cr.FPrintJob, nTable, SessInfo, FPropagate) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'SessionInfo.Test <PESetNthTableSessionInfo>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Need to Test Table Connection first!}
  if Cr.SubItem.FTables.Count = 0 then
    Cr.SubItem.FTables.Retrieve;
  Cr.SubItem.FTables[FIndex].Test;
  {Test SessionInfo Connectivity}
  Cr.SetDLLHandle;
  Result := PETestNthTableConnectivity(Cr.FPrintJob, nTable);

  {If if failed, store the resulting error}
  if Result = False then
  begin
    Cr.SetDLLHandle;
    Cr.FLastErrorNumber := PEGetErrorCode(Cr.FPrintJob);
    {Get ErrorString}
    if not PEGetErrorText(Cr.FPrintJob, hTextHandle, nTextLen) then
      {Failed to Retrieve Error String from Print Engine}
      Cr.FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR)
    else
    begin
      pErrorText := StrAlloc(nTextLen);
      Cr.SetDLLHandle;
      if not PEGetHandleString(hTextHandle, pErrorText, nTextLen) then
      begin
        StrDispose(pErrorText);
        {Failed to Retrieve Error from Print Engine}
        Cr.FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
      end
      else
      begin
        Cr.FLastErrorString := String(pErrorText);
        {Remove the Period if it exists}
        if Pos('.', Cr.FLastErrorString) > 0 then
          Cr.FLastErrorString := Copy(Cr.FLastErrorString, 1,
            Pos('.', Cr.FLastErrorString) - 1);
        StrDispose(pErrorText);
      end;
    end; {if not PEGetErrorText}
  end; {if Result = False}
end;
{------------------------------------------------------------------------------}
{ Access method GetTable                                                       }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetTable : TCrSessionInfoTable;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTable;
end;
{------------------------------------------------------------------------------}
{ Access method SetTable                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetTable(const Value: TCrSessionInfoTable);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'SessionInfo.Table := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetUserName                                               }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetUserID: string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUserID;
end; { GetUserName }
{------------------------------------------------------------------------------}
{ Access method SetUserName                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetUserID(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FUserID := Value;
    {Check Length}
    if Length(ListItem(FIndex).FUserID) > PE_SESS_USERID_LEN then
      ListItem(FIndex).FUserID := Copy(ListItem(FIndex).FUserID, 1, PE_SESS_USERID_LEN);
  end;
end; { SetUserName }
{------------------------------------------------------------------------------}
{ Access method GetDBPassword                                                  }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetDBPassword: string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDBPassword;
end; { GetDBPassword }
{------------------------------------------------------------------------------}
{ Access method SetDBPassword                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetDBPassword(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FDBPassword := Value;
    {Check Length}
    if Length(ListItem(FIndex).FDBPassword) > PE_SESS_PASSWORD_LEN then
      ListItem(FIndex).FDBPassword := Copy(ListItem(FIndex).FDBPassword, 1, PE_SESS_PASSWORD_LEN);
  end;
end; { SetDBPassword }
{------------------------------------------------------------------------------}
{ Access method GetUserPassword                                                }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetUserPassword: string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FUserPassword;
end; { GetUserPassword }
{------------------------------------------------------------------------------}
{ Access method SetUserPassword                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetUserPassword(const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FUserPassword := Value;
    {Check Length}
    if Length(ListItem(FIndex).FUserPassword) > PE_SESS_PASSWORD_LEN then
      ListItem(FIndex).FUserPassword := Copy(ListItem(FIndex).FUserPassword, 1, PE_SESS_PASSWORD_LEN);
  end;
end; { SetUserPassword }
{------------------------------------------------------------------------------}
{ Access method GetHandle                                                      }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetHandle : DWord;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FHandle;
end;
{------------------------------------------------------------------------------}
{ Access method SetHandle                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetHandle (const Value: DWord);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FHandle := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'SessionInfo[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SessionInfo[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetItem(nIndex: integer) : TCrpeSessionInfo;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGraphTypeItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphTypeItem.Create;
begin
  inherited Create;
  FNumber := -1;
  FSectionGraphNum := -1;
  FSection := '';
  FStyle := unknownGraphType;
end;


{******************************************************************************}
{ Class TCrpeGraphType                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphType.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphType.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.CopyFrom (Source: TCrpeGraphType);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FSectionGraphNum := Source[cnt].SectionGraphNum;
    ListItem(cnt).FSection := Source[cnt].Section;
    ListItem(cnt).FStyle := Source[cnt].Style;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphType.IndexOf(GraphNumber : TCrGraphTypeNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GraphNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphType.ListItem(nIndex: integer): TCrpeGraphTypeItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphType.Add (GraphNumber: TCrGraphTypeNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GraphNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
         'GraphType <' + IntToStr(GraphNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGraphTypeItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GraphNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphType.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphType.Retrieve : boolean;
var
  nSections     : smallint;
  nIndex        : smallint;
  nCode         : smallint;
  slSectionsN,
  slSectionsS   : TStringList;
  cnt1,cnt2     : smallint;
  GType         : Smallint;
  GraphTypeInfo : PEGraphTypeInfo;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {Clear the GraphType strings}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphType.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GraphType.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  cnt2 := 0;
  {Loop through sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      nCode := StrToInt(slSectionsN[nIndex]);
      {Less GraphTypes available with SCR6 and 5}
      if Cr.FVersion.FMajor < 7 then
      begin
        {Get GraphType}
        Cr.SetDLLHandle;
        if PEGetGraphType(Cr.FPrintJob, nCode, cnt1, GType) then
        begin
          Add(cnt2);
          ListItem(FIndex).FSectionGraphNum := cnt1;
          ListItem(FIndex).FSection := slSectionsS[nIndex];
          ListItem(FIndex).FStyle := GetGraphType(GType, -1);
          Inc(cnt2);
          Result := True;
        end
      end
      {More GraphTypes availabe with SCR7}
      else
      begin
        {Get GraphTypeInfo}
        Cr.SetDLLHandle;
        if PEGetGraphTypeInfo(Cr.FPrintJob, nCode, cnt1, GraphTypeInfo) then
        begin
          Add(cnt2);
          ListItem(FIndex).FSectionGraphNum := cnt1;
          ListItem(FIndex).FSection := slSectionsS[nIndex];
          ListItem(FIndex).FStyle := GetGraphType(GraphTypeInfo.graphType,
            GraphTypeInfo.graphSubtype);
          Inc(cnt2);
          Result := True;
        end;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ GetGraphType method                                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetGraphType (nGraphType, nSubType: smallint): TCrGraphType;
begin
  {Default to Unknown}
  Result := unknownGraphType;
  {Old Graph Types: SCR 5 & 6}
  if nSubType = -1 then
  begin
    case nGraphType of
      PE_SIDE_BY_SIDE_BAR_GRAPH          : Result := barSideBySide;
      PE_FAKED_3D_SIDE_BY_SIDE_BAR_GRAPH : Result := bar3DSideBySide;
      PE_STACKED_BAR_GRAPH               : Result := barStacked;
      PE_FAKED_3D_STACKED_BAR_GRAPH      : Result := bar3DStacked;
      PE_PERCENT_BAR_GRAPH               : Result := barPercent;
      PE_FAKED_3D_PERCENT_BAR_GRAPH      : Result := bar3DPercent;
      PE_LINE_GRAPH                      : Result := lineRegular;
      PE_AREA_GRAPH                      : Result := areaAbsolute;
      PE_THREED_BAR_GRAPH                : Result := ThreeDRegular;
      PE_PIE_GRAPH                       : Result := pieRegular;
      PE_MULTIPLE_PIE_GRAPH              : Result := pieMultiple;
      PE_PROPORTIONAL_MULTI_PIE_GRAPH    : Result := pieMultiProp;
      PE_USER_DEFINED_GRAPH              : Result := userDefinedGraph;
      PE_UNKNOWN_TYPE_GRAPH              : Result := unknownGraphType;
    end;
  end
  {Newer GraphTypes: SCR7+}
  else
  begin
    case nGraphType of
      PE_GT_BARCHART :
        begin
          case nSubType of
            PE_GST_SIDEBYSIDEBARCHART        : Result := barSideBySide;
            PE_GST_STACKEDBARCHART           : Result := barStacked;
            PE_GST_PERCENTBARCHART           : Result := barPercent;
            PE_GST_FAKED3DSIDEBYSIDEBARCHART : Result := bar3DSideBySide;
            PE_GST_FAKED3DSTACKEDBARCHART    : Result := bar3DStacked;
            PE_GST_FAKED3DPERCENTBARCHART    : Result := bar3DPercent;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownBar;
          end;
        end;
      PE_GT_LINECHART :
        begin
          case nSubType of
            PE_GST_REGULARLINECHART               : Result := lineRegular;
            PE_GST_STACKEDLINECHART               : Result := lineStacked;
            PE_GST_PERCENTAGELINECHART            : Result := linePercent;
            PE_GST_LINECHARTWITHMARKERS           : Result := lineWithMarkers;
            PE_GST_STACKEDLINECHARTWITHMARKERS    : Result := lineStackedWithMarkers;
            PE_GST_PERCENTAGELINECHARTWITHMARKERS : Result := linePercentWithMarkers;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownLine;
          end;
        end;
      PE_GT_AREACHART :
        begin
          case nSubType of
            PE_GST_ABSOLUTEAREACHART        : Result := areaAbsolute;
            PE_GST_STACKEDAREACHART         : Result := areaStacked;
            PE_GST_PERCENTAREACHART         : Result := areaPercent;
            PE_GST_FAKED3DABSOLUTEAREACHART : Result := area3DAbsolute;
            PE_GST_FAKED3DSTACKEDAREACHART  : Result := area3DStacked;
            PE_GST_FAKED3DPERCENTAREACHART  : Result := area3DPercent;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownArea;
          end;
        end;
      PE_GT_PIECHART :
        begin
          case nSubType of
            PE_GST_REGULARPIECHART              : Result := pieRegular;
            PE_GST_FAKED3DREGULARPIECHART       : Result := pie3DRegular;
            PE_GST_MULTIPLEPIECHART             : Result := pieMultiple;
            PE_GST_MULTIPLEPROPORTIONALPIECHART : Result := pieMultiProp;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownPie;
          end;
        end;
      PE_GT_DOUGHNUTCHART :
        begin
          case nSubType of
            PE_GST_REGULARDOUGHNUTCHART              : Result := doughnutRegular;
            PE_GST_MULTIPLEDOUGHNUTCHART             : Result := doughnutMultiple;
            PE_GST_MULTIPLEPROPORTIONALDOUGHNUTCHART : Result := doughnutMultiProp;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownDoughnut;
          end;
        end;
      PE_GT_THREEDRISERCHART :
        begin
          case nSubType of
            PE_GST_THREEDREGULARCHART    : Result := ThreeDRegular;
            PE_GST_THREEDPYRAMIDCHART    : Result := ThreeDPyramid;
            PE_GST_THREEDOCTAGONCHART    : Result := ThreeDOctagon;
            PE_GST_THREEDCUTCORNERSCHART : Result := ThreeDCutCorners;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknown3DRiser;
          end;
        end;
      PE_GT_THREEDSURFACECHART :
        begin
          case nSubType of
            PE_GST_THREEDSURFACEREGULARCHART   : Result := ThreeDSurfaceRegular;
            PE_GST_THREEDSURFACEWITHSIDESCHART : Result := ThreeDSurfaceWithSides;
            PE_GST_THREEDSURFACEHONEYCOMBCHART : Result := ThreeDSurfaceHoneyComb;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknown3DSurface;
          end;
        end;
      PE_GT_SCATTERCHART :
        begin
          case nSubType of
            PE_GST_XYSCATTERCHART                   : Result := XYScatter;
            PE_GST_XYSCATTERDUALAXISCHART           : Result := XYScatterDualAxis;
            PE_GST_XYSCATTERWITHLABELSCHART         : Result := XYScatterLabeled;
            PE_GST_XYSCATTERDUALAXISWITHLABELSCHART : Result := XYScatterDualAxisLabeled;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownXYScatter;
          end;
        end;
      PE_GT_RADARCHART :
        begin
          case nSubType of
            PE_GST_REGULARRADARCHART  : Result := radarRegular;
            PE_GST_STACKEDRADARCHART  : Result := radarStacked;
            PE_GST_RADARDUALAXISCHART : Result := radarDualAxis;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownRadar;
          end;
        end;
      PE_GT_BUBBLECHART :
        begin
          case nSubType of
            PE_GST_REGULARBUBBLECHART  : Result := bubbleRegular;
            PE_GST_DUALAXISBUBBLECHART : Result := bubbleDualAxis;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownBubble;
          end;
        end;
      PE_GT_STOCKCHART  :
        begin
          case nSubType of
            PE_GST_HIGHLOWCHART                  : Result := stockHiLo;
            PE_GST_HIGHLOWDUALAXISCHART          : Result := stockHiLoDualAxis;
            PE_GST_HIGHLOWOPENCHART              : Result := stockHiLoOpen;
            PE_GST_HIGHLOWOPENDUALAXISCHART      : Result := stockHiLoOpenDualAxis;
            PE_GST_HIGHLOWOPENCLOSECHART         : Result := stockHiLoOpenClose;
            PE_GST_HIGHLOWOPENCLOSEDUALAXISCHART : Result := stockHiLoOpenCloseDualAxis;
            else {PE_GST_UNKNOWNSUBTYPECHART}
              Result := unknownStockHiLo;
          end;
        end;
      PE_GT_USERDEFINEDCHART : Result := userDefinedGraph;
      PE_GT_UNKNOWNTYPECHART : Result := unknownGraphType;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGraphTypeConst method                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.GetGraphTypeConst (xGraphType: TCrGraphType;
  var nGraphType: smallint; var nSubType: smallint);
var
  i: integer;
begin
  if nSubType = -1 then
  begin
    case xGraphType of
      barSideBySide   : nGraphType := PE_SIDE_BY_SIDE_BAR_GRAPH;
      barStacked      : nGraphType := PE_STACKED_BAR_GRAPH;
      barPercent      : nGraphType := PE_PERCENT_BAR_GRAPH;
      bar3DSideBySide : nGraphType := PE_FAKED_3D_SIDE_BY_SIDE_BAR_GRAPH;
      bar3DStacked    : nGraphType := PE_FAKED_3D_STACKED_BAR_GRAPH;
      bar3DPercent    : nGraphType := PE_FAKED_3D_PERCENT_BAR_GRAPH;
      lineRegular..linePercentWithMarkers : nGraphType := PE_LINE_GRAPH;
      areaAbsolute..area3DPercent         : nGraphType := PE_AREA_GRAPH;
      pieRegular..pie3DRegular            : nGraphType := PE_PIE_GRAPH;
      pieMultiple                         : nGraphType := PE_MULTIPLE_PIE_GRAPH;
      pieMultiProp                        : nGraphType := PE_PROPORTIONAL_MULTI_PIE_GRAPH;
      doughnutRegular..doughnutMultiProp  : nGraphType := PE_PIE_GRAPH;
      ThreeDRegular..ThreeDSurfaceHoneyComb : nGraphType := PE_THREED_BAR_GRAPH;
      {These ones are defaulted to barSideBySide, they do not
       exist in earlier versions of CRPE32}
      XYScatter..XYScatterDualAxisLabeled : nGraphType := PE_SIDE_BY_SIDE_BAR_GRAPH;
      radarRegular..radarDualAxis         : nGraphType := PE_SIDE_BY_SIDE_BAR_GRAPH;
      bubbleRegular..bubbleDualAxis       : nGraphType := PE_SIDE_BY_SIDE_BAR_GRAPH;
      stockHiLo..stockHiLoOpenCloseDualAxis : nGraphType := PE_SIDE_BY_SIDE_BAR_GRAPH;
      {UserDefined and Unknown}
      userDefinedGraph : nGraphType := PE_USER_DEFINED_GRAPH;
      unknownGraphType : nGraphType := PE_UNKNOWN_TYPE_GRAPH;
    end;
  end
  else
  begin
    for i := 0 to 1 do
    begin
      if i = 0 then
      begin
        {GraphType}
        case xGraphType of
          barSideBySide..bar3DPercent         : nGraphType := PE_GT_BARCHART;
          lineRegular..linePercentWithMarkers : nGraphType := PE_GT_LINECHART;
          areaAbsolute..area3DPercent         : nGraphType := PE_GT_AREACHART;
          pieRegular..pieMultiProp            : nGraphType := PE_GT_PIECHART;
          doughnutRegular..doughnutMultiProp  : nGraphType := PE_GT_DOUGHNUTCHART;
          ThreeDRegular..ThreeDCutCorners     : nGraphType := PE_GT_THREEDRISERCHART;
          ThreeDSurfaceRegular..ThreeDSurfaceHoneyComb :
            nGraphType := PE_GT_THREEDSURFACECHART;
          XYScatter..XYScatterDualAxisLabeled : nGraphType := PE_GT_SCATTERCHART;
          radarRegular..radarDualAxis         : nGraphType := PE_GT_RADARCHART;
          bubbleRegular..bubbleDualAxis       : nGraphType := PE_GT_BUBBLECHART;
          stockHiLo..stockHiLoOpenCloseDualAxis : nGraphType := PE_GT_STOCKCHART;
          userDefinedGraph : nGraphType := PE_GT_USERDEFINEDCHART;
          unknownGraphType : nGraphType := PE_GT_UNKNOWNTYPECHART;
        end
      end
      else
      begin
        {GraphSubType}
        case xGraphType of
          barSideBySide   : nSubType := PE_GST_SIDEBYSIDEBARCHART;
          barStacked      : nSubType := PE_GST_STACKEDBARCHART;
          barPercent      : nSubType := PE_GST_PERCENTBARCHART;
          bar3DSideBySide : nSubType := PE_GST_FAKED3DSIDEBYSIDEBARCHART;
          bar3DStacked    : nSubType := PE_GST_FAKED3DSTACKEDBARCHART;
          bar3DPercent    : nSubType := PE_GST_FAKED3DPERCENTBARCHART;
          lineRegular            : nSubType := PE_GST_REGULARLINECHART;
          lineStacked            : nSubType := PE_GST_STACKEDLINECHART;
          linePercent            : nSubType := PE_GST_PERCENTAGELINECHART;
          lineWithMarkers        : nSubType := PE_GST_LINECHARTWITHMARKERS;
          lineStackedWithMarkers : nSubType := PE_GST_STACKEDLINECHARTWITHMARKERS;
          linePercentWithMarkers : nSubType := PE_GST_PERCENTAGELINECHARTWITHMARKERS;
          areaAbsolute   : nSubType := PE_GST_ABSOLUTEAREACHART;
          areaStacked    : nSubType := PE_GST_STACKEDAREACHART;
          areaPercent    : nSubType := PE_GST_PERCENTAREACHART;
          area3DAbsolute : nSubType := PE_GST_FAKED3DABSOLUTEAREACHART;
          area3DStacked  : nSubType := PE_GST_FAKED3DSTACKEDAREACHART;
          area3DPercent  : nSubType := PE_GST_FAKED3DPERCENTAREACHART;
          pieRegular    : nSubType := PE_GST_REGULARPIECHART;
          pie3DRegular  : nSubType := PE_GST_FAKED3DREGULARPIECHART;
          pieMultiple   : nSubType := PE_GST_MULTIPLEPIECHART;
          pieMultiProp  : nSubType := PE_GST_MULTIPLEPROPORTIONALPIECHART;
          doughnutRegular    : nSubType := PE_GST_REGULARDOUGHNUTCHART;
          doughnutMultiple   : nSubType := PE_GST_MULTIPLEDOUGHNUTCHART;
          doughnutMultiProp  : nSubType := PE_GST_MULTIPLEPROPORTIONALDOUGHNUTCHART;
          ThreeDRegular           : nSubType := PE_GST_THREEDREGULARCHART;
          ThreeDPyramid           : nSubType := PE_GST_THREEDPYRAMIDCHART;
          ThreeDOctagon           : nSubType := PE_GST_THREEDOCTAGONCHART;
          ThreeDCutCorners        : nSubType := PE_GST_THREEDCUTCORNERSCHART;
          ThreeDSurfaceRegular    : nSubType := PE_GST_THREEDSURFACEREGULARCHART;
          ThreeDSurfaceWithSides  : nSubType := PE_GST_THREEDSURFACEWITHSIDESCHART;
          ThreeDSurfaceHoneyComb  : nSubType := PE_GST_THREEDSURFACEHONEYCOMBCHART;
          XYScatter                : nSubType := PE_GST_XYSCATTERCHART;
          XYScatterDualAxis        : nSubType := PE_GST_XYSCATTERDUALAXISCHART;
          XYScatterLabeled         : nSubType := PE_GST_XYSCATTERWITHLABELSCHART;
          XYScatterDualAxisLabeled : nSubType := PE_GST_XYSCATTERDUALAXISWITHLABELSCHART;
          radarRegular  : nSubType := PE_GST_REGULARRADARCHART;
          radarStacked  : nSubType := PE_GST_STACKEDRADARCHART;
          radarDualAxis : nSubType := PE_GST_RADARDUALAXISCHART;
          bubbleRegular  : nSubType := PE_GST_REGULARBUBBLECHART;
          bubbleDualAxis : nSubType := PE_GST_DUALAXISBUBBLECHART;
          stockHiLo                  : nSubType := PE_GST_HIGHLOWCHART;
          stockHiLoDualAxis          : nSubType := PE_GST_HIGHLOWDUALAXISCHART;
          stockHiLoOpen              : nSubType := PE_GST_HIGHLOWOPENCHART;
          stockHiLoOpenDualAxis      : nSubType := PE_GST_HIGHLOWOPENDUALAXISCHART;
          stockHiLoOpenClose         : nSubType := PE_GST_HIGHLOWOPENCLOSECHART;
          stockHiLoOpenCloseDualAxis : nSubType := PE_GST_HIGHLOWOPENCLOSEDUALAXISCHART;
          userDefinedGraph : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownBar       : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownLine      : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownArea      : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownPie       : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownDoughnut  : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknown3DRiser   : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknown3DSurface : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownXYScatter : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownRadar     : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownBubble    : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownStockHiLo : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
          unknownGraphType : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        end;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphType.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphType.Send : boolean;
var
  nGraphType    : Smallint;
  nIndex,
  nGraph,
  nCode         : smallint;
  GraphTypeInfo : PEGraphTypeInfo;
  nGType        : smallint;
  nSubType      : smallint;
  Changed       : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Loop through GraphType items}
  for nIndex := 0 to (Count - 1) do
  begin
    {Number}
    nGraph := ListItem(nIndex).FSectionGraphNum;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'GraphType.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Version: SCR5 & 6}
    if Cr.FVersion.FMajor < 7 then
    begin
      Cr.SetDLLHandle;
      if not PEGetGraphType(Cr.FPrintJob, nCode, nGraph, nGraphType) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphType.Send <PEGetGraphType>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Style}
      nSubType := -1;
      GetGraphTypeConst(ListItem(nIndex).FStyle, nGType, nSubType);

      {Send GraphType to Report}
      if nGraphType <> nGType then
      begin
        nGraphType := nGType;
        Cr.SetDLLHandle;
        if not PESetGraphType(Cr.FPrintJob, nCode, nGraph, nGraphType) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'GraphType.Send <PESetGraphType>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;
    end
    {Version: SCR7+}
    else
    begin
      Changed := False;
      {Get GraphType}
      Cr.SetDLLHandle;
      if not PEGetGraphTypeInfo(Cr.FPrintJob, nCode, nGraph, GraphTypeInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphType.Send <PEGetGraphTypeInfo>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;

      {Style}
      nSubType := PE_GST_UNKNOWNSUBTYPECHART;
      GetGraphTypeConst(ListItem(nIndex).FStyle, nGType, nSubType);

      {Compare}
      if (GraphTypeInfo.graphType <> nGType) or
         (GraphTypeInfo.graphSubtype <> nSubType) then
      begin
        GraphTypeInfo.graphType := nGType;
        GraphTypeInfo.graphSubType := nSubType;
        Changed := True;
      end;

      {Send GraphTypeInfo to Report}
      if Changed then
      begin
        Cr.SetDLLHandle;
        if not PESetGraphTypeInfo(Cr.FPrintJob, nCode, nGraph, GraphTypeInfo) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'GraphType.Send <PESetGraphTypeInfo>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;
    end;
  end;
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetNumber : TCrGraphTypeNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.SetNumber (const Value: TCrGraphTypeNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'GraphType.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionGraphNum                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetSectionGraphNum : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSectionGraphNum;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionGraphNum                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.SetSectionGraphNum (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSectionGraphNum := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetStyle                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetStyle : TCrGraphType;
begin
  Result := TCrGraphType(0);
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FStyle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetStyle                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.SetStyle (const Value: TCrGraphType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FStyle := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := SectionCodeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphType.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphType.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphType[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.GraphType[nIndex]                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphType.GetItem(nIndex: integer) : TCrpeGraphType;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGraphOptionsItem                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphOptionsItem.Create;
begin
  inherited Create;
  FNumber           := -1;
  FSectionGraphNum  := -1;
  FSection          := '';
  FMax              := -1;
  FMin              := -1;
  FDataValues       := cDefault;
  FGridLines        := cDefault;
  FLegend           := cDefault;
  FBarDirection     := bdDefault;
  FFont             := '';
end;


{******************************************************************************}
{ Class TCrpeGraphOptions                                                      }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphOptions.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphOptions.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.CopyFrom (Source: TCrpeGraphOptions);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FSectionGraphNum := Source[cnt].SectionGraphNum;
    ListItem(cnt).FSection := Source[cnt].Section;
    ListItem(cnt).FMax := Source[cnt].Max;
    ListItem(cnt).FMin := Source[cnt].Min;
    ListItem(cnt).FDataValues := Source[cnt].DataValues;
    ListItem(cnt).FGridLines := Source[cnt].GridLines;
    ListItem(cnt).FLegend := Source[cnt].Legend;
    ListItem(cnt).FBarDirection := Source[cnt].BarDirection;
    ListItem(cnt).FFont := Source[cnt].Font;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Member function Count                                                        }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.IndexOf(GraphNumber : TCrGraphOptionsNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GraphNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.ListItem(nIndex: integer): TCrpeGraphOptionsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.Add (GraphNumber: TCrGraphOptionsNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GraphNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'GraphOptions <' + IntToStr(GraphNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGraphOptionsItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GraphNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphOptions.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Member procedure Retrieve                                                    }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.Retrieve : boolean;
var
  GraphOpt      : PEGraphOptions;
  nSections     : smallint;
  nIndex        : smallint;
  nCode         : smallint;
  slSectionsN,
  slSectionsS   : TStringList;
  cnt1,cnt2     : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the GraphOptions strings}
  Clear;
  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptions.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GraphOptions.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  cnt2 := 0;
  {Loop through sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      nCode := StrToInt(slSectionsN[nIndex]);
      {GraphOptions}
      Cr.SetDLLHandle;
      if PEGetGraphOptions(Cr.FPrintJob, nCode, cnt1, GraphOpt) then
      begin
        Add(cnt2);
        {Number of Graph in Section}
        ListItem(FIndex).FSectionGraphNum := cnt1;
        {SectionCode}
        ListItem(FIndex).FSection := slSectionsS[nIndex];
        {Max}
        ListItem(FIndex).FMax := GraphOpt.graphMaxValue;
        {Min}
        ListItem(FIndex).FMin := GraphOpt.graphMinValue;
        {DataValues}
        ListItem(FIndex).FDataValues := cDefault;
        if GraphOpt.showDataValue = False then
          ListItem(FIndex).FDataValues := cFalse
        else if GraphOpt.showDataValue = True then
          ListItem(FIndex).FDataValues := cTrue;
        {GridLines}
        ListItem(FIndex).FGridLines := cDefault;
        if GraphOpt.showGridLine = False then
          ListItem(FIndex).FGridLines := cFalse
        else if GraphOpt.showGridLine = True then
          ListItem(FIndex).FGridLines := cTrue;
        {Legend}
        ListItem(FIndex).FLegend := cDefault;
        if GraphOpt.showLegend = False then
          ListItem(FIndex).FLegend := cFalse
        else if GraphOpt.showLegend = True then
          ListItem(FIndex).FLegend := cTrue;
        {BarDirection}
        ListItem(FIndex).FBarDirection := bdDefault;
        if GraphOpt.verticalBars = False then
          ListItem(FIndex).FBarDirection := bdHorizontal
        else if GraphOpt.verticalBars = True then
          ListItem(FIndex).FBarDirection := bdVertical;
        {Font}
        ListItem(FIndex).FFont := String(GraphOpt.fontFaceName);
        Inc(cnt2);
        Result := True;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Access method SendGraphOptions                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.Send : boolean;
var
   nIndex       : smallint;
   nGraph       : smallint;
   SectionCode  : smallint;
   GraphOpt     : PEGraphOptions;
   Changed      : boolean;
   sTmp         : string;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Number}
    nGraph := ListItem(nIndex).FSectionGraphNum;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, SectionCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'GraphOptions.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get GraphOptions from Report}
    Cr.SetDLLHandle;
    if not PEGetGraphOptions(Cr.FPrintJob, SectionCode, nGraph, GraphOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptions.Send <PEGetGraphOptions>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Font}
    sTmp := String(GraphOpt.fontFaceName);
    if CompareText(sTmp, ListItem(nIndex).FFont) <> 0 then
    begin
      StrPCopy(GraphOpt.fontFaceName, ListItem(nIndex).FFont);
      Changed := True;
    end;

    {VerticalBars}
    if ListItem(nIndex).FBarDirection <> bdDefault then
    begin
      if GraphOpt.verticalBars = (ListItem(nIndex).FBarDirection = bdHorizontal) then
      begin
        GraphOpt.verticalBars := not(GraphOpt.verticalBars);
        Changed := True;
      end;
    end;

    {DataValues}
    if ListItem(nIndex).FDataValues <> cDefault then
    begin
      if GraphOpt.showDataValue = (ListItem(nIndex).FDataValues = cFalse) then
      begin
        GraphOpt.showDataValue := not(GraphOpt.showDataValue);
        Changed := True;
      end;
    end;

    {GridLines}
    if ListItem(nIndex).FGridLines <> cDefault then
    begin
      if GraphOpt.showGridLine = (ListItem(nIndex).FGridLines = cFalse) then
      begin
        GraphOpt.showGridLine := not(GraphOpt.showGridLine);
        Changed := True;
      end;
    end;

    {Legend}
    if ListItem(nIndex).FLegend <> cDefault then
    begin
      if GraphOpt.showLegend = (ListItem(nIndex).FLegend = cFalse) then
      begin
        GraphOpt.showLegend := not(GraphOpt.showLegend);
        Changed := True;
      end;
    end;

    {Max}
    if ListItem(nIndex).FMax > -1 then
    begin
      if GraphOpt.graphMaxValue <> ListItem(nIndex).FMax then
      begin
        GraphOpt.graphMaxValue := ListItem(nIndex).FMax;
        Changed := True;
      end;
    end;

    {Min}
    if ListItem(nIndex).FMin > -1 then
    begin
      if GraphOpt.graphMinValue <> ListItem(nIndex).FMin then
      begin
        GraphOpt.graphMinValue := ListItem(nIndex).FMin;
        Changed := True;
      end;
    end;

    {Send the GraphOptions to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetGraphOptions(Cr.FPrintJob, SectionCode, nGraph, GraphOpt) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphOptions.Send <PESetGraphOptions>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.GetNumber : TCrGraphOptionsNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetNumber (const Value: TCrGraphOptionsNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'GraphOptions.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionGraphNum                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.GetSectionGraphNum : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSectionGraphNum;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionGraphNum                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetSectionGraphNum (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSectionGraphNum := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMax                                                    }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.GetMax : double;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMax;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMax                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetMax (const Value: double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMax := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMin                                                    }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetMin : double;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMin;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMin                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetMin (const Value: double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMin := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataValues                                             }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetDataValues : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataValues;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataValues                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetDataValues (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataValues := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGridLines                                              }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetGridLines : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGridLines;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGridLines                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetGridLines (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGridLines := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetLegend                                                 }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetLegend : TCrBoolean;
begin
  Result := cDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FLegend;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetLegend                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetLegend (const Value: TCrBoolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FLegend := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetBarDirection                                           }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetBarDirection : TCrGraphBarDirection;
begin
  Result := bdDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FBarDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetBarDirection                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetBarDirection (const Value: TCrGraphBarDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FBarDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetFont                                                   }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptions.GetFont : TFontName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetFont                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetFont (const Value: TFontName);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FFont := Value;
    {Check Length}
    if Length(ListItem(FIndex).FFont) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FFont := Copy(ListItem(FIndex).FFont, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := SectionCodeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptions.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphOptions[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphOptions.GetItem(nIndex: integer) : TCrpeGraphOptions;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGraphOptionInfoItem                                               }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphOptionInfoItem.Create;
begin
  inherited Create;
  FNumber           := -1;
  FSectionGraphNum  := -1;
  FSection          := '';
  FColor            := gcDefault;
  FLegend           := glDefault; { showLegend and LegendPosition }
  { Pie Charts and Doughut Charts }
  FPieSize          := gpsDefault;
  FPieSlice         := gslDefault;
  { Bar Chart }
  FBarSize          := gbsDefault;
  FBarDirection     := bdDefault;
  { Markers (used for line and bar charts) }
  FMarkerSize       := gmsDefault;
  FMarkerShape      := gshDefault;
  { Data Points }
  FDataPoints       := gdpDefault;
  FNumberFormat     := gnfDefault;
  { 3D }
  FViewingAngle     := gvaDefault;
end;


{******************************************************************************}
{ Class TCrpeGraphOptionInfo                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphOptionInfo.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphOptionInfo.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.CopyFrom (Source: TCrpeGraphOptionInfo);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FSectionGraphNum := Source[cnt].SectionGraphNum;
    ListItem(cnt).FSection := Source[cnt].Section;
    ListItem(cnt).FColor := Source[cnt].Color;
    ListItem(cnt).FLegend := Source[cnt].Legend;
    ListItem(cnt).FPieSize := Source[cnt].PieSize;
    ListItem(cnt).FPieSlice := Source[cnt].PieSlice;
    ListItem(cnt).FBarSize := Source[cnt].BarSize;
    ListItem(cnt).FBarDirection := Source[cnt].BarDirection;
    ListItem(cnt).FMarkerSize := Source[cnt].MarkerSize;
    ListItem(cnt).FMarkerShape := Source[cnt].MarkerShape;
    ListItem(cnt).FDataPoints := Source[cnt].DataPoints;
    ListItem(cnt).FNumberFormat := Source[cnt].NumberFormat;
    ListItem(cnt).FViewingAngle := Source[cnt].ViewingAngle;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Member function Count                                                        }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptionInfo.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.IndexOf(GraphNumber : TCrGraphOptionInfoNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GraphNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.ListItem(nIndex: integer): TCrpeGraphOptionInfoItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.Add (GraphNumber: TCrGraphOptionInfoNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GraphNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'GraphOptionInfo <' + IntToStr(GraphNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGraphOptionInfoItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GraphNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphOptionInfo.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Member procedure Retrieve                                                    }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.Retrieve : boolean;
var
  GrOptionInfo  : PEGraphOptionInfo;
  nSections     : smallint;
  nIndex        : smallint;
  nCode         : smallint;
  slSectionsN,
  slSectionsS   : TStringList;
  cnt1,cnt2     : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {GraphOptionInfo only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  {Clear the GraphOptionInfo strings}
  Clear;
  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GraphOptionInfo.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  cnt2 := 0;
  {Loop through sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      nCode := StrToInt(slSectionsN[nIndex]);
      {Get GraphOptionInfo}
      Cr.SetDLLHandle;
      if PEGetGraphOptionInfo(Cr.FPrintJob, nCode, cnt1, GrOptionInfo) then
      begin
        Add(cnt2);
        {Number of Graph in Section}
        ListItem(FIndex).FSectionGraphNum := cnt1;
        {SectionCode}
        ListItem(FIndex).FSection := slSectionsS[nIndex];
        {GraphColor}
        case GrOptionInfo.graphColor of
          PE_GCR_COLORCHART         : ListItem(FIndex).FColor := gcColor;
          PE_GCR_BLACKANDWHITECHART : ListItem(FIndex).FColor := gcMonochrome;
          else
            ListItem(FIndex).FColor := gcDefault;
        end;
        {ShowLegend and LegendPosition}
        case GrOptionInfo.showLegend of
          0: ListItem(FIndex).FLegend := glNone;
          1: begin
               case GrOptionInfo.legendPosition of
                 PE_GLP_PLACEUPPERRIGHT   : ListItem(FIndex).FLegend := glUpperright;
                 PE_GLP_PLACEBOTTOMCENTER : ListItem(FIndex).FLegend := glBottomCenter;
                 PE_GLP_PLACETOPCENTER    : ListItem(FIndex).FLegend := glTopCenter;
                 PE_GLP_PLACERIGHT        : ListItem(FIndex).FLegend := glRight;
                 PE_GLP_PLACELEFT         : ListItem(FIndex).FLegend := glLeft;
               end;
             end;
          else
            ListItem(FIndex).FLegend := glDefault;
        end;
        {PieSize}
        case GrOptionInfo.pieSize of
          PE_GPS_MINIMUMPIESIZE : ListItem(FIndex).FPieSize := gpsMinimum;
          PE_GPS_SMALLPIESIZE   : ListItem(FIndex).FPieSize := gpsSmall;
          PE_GPS_AVERAGEPIESIZE : ListItem(FIndex).FPieSize := gpsAverage;
          PE_GPS_LARGEPIESIZE   : ListItem(FIndex).FPieSize := gpsLarge;
          PE_GPS_MAXIMUMPIESIZE : ListItem(FIndex).FPieSize := gpsMaximum;
          else
            ListItem(FIndex).FPieSize := gpsDefault;
        end;
        {PieSlice}
        case GrOptionInfo.detachedPieSlice of
          PE_GDPS_NODETACHMENT  : ListItem(FIndex).FPieSlice := gslNone;
          PE_GDPS_SMALLESTSLICE : ListItem(FIndex).FPieSlice := gslSmall;
          PE_GDPS_LARGESTSLICE  : ListItem(FIndex).FPieSlice := gslLarge;
          else
            ListItem(FIndex).FPieSlice := gslDefault;
        end;
        {BarSize}
        case GrOptionInfo.barSize of
          PE_GBS_MINIMUMBARSIZE : ListItem(FIndex).FBarSize := gbsMinimum;
          PE_GBS_SMALLBARSIZE   : ListItem(FIndex).FBarSize := gbsSmall;
          PE_GBS_AVERAGEBARSIZE : ListItem(FIndex).FBarSize := gbsAverage;
          PE_GBS_LARGEBARSIZE   : ListItem(FIndex).FBarSize := gbsLarge;
          PE_GBS_MAXIMUMBARSIZE : ListItem(FIndex).FBarSize := gbsMaximum;
          else
            ListItem(FIndex).FBarSize := gbsDefault;
        end;
        {VerticalBars}
        case GrOptionInfo.verticalBars of
          0: ListItem(FIndex).FBarDirection := bdHorizontal;
          1: ListItem(FIndex).FBarDirection := bdVertical;
          else
            ListItem(FIndex).FBarDirection := bdDefault;
        end;
        {MarkerSize}
        case GrOptionInfo.markerSize of
          PE_GMS_SMALLMARKERS       : ListItem(FIndex).FMarkerSize := gmsSmall;
          PE_GMS_MEDIUMSMALLMARKERS : ListItem(FIndex).FMarkerSize := gmsMediumSmall;
          PE_GMS_MEDIUMMARKERS      : ListItem(FIndex).FMarkerSize := gmsMedium;
          PE_GMS_MEDIUMLARGEMARKERS : ListItem(FIndex).FMarkerSize := gmsMediumLarge;
          PE_GMS_LARGEMARKERS       : ListItem(FIndex).FMarkerSize := gmsLarge;
          else
            ListItem(FIndex).FMarkerSize := gmsDefault;
        end;
        {MarkerShape}
        case GrOptionInfo.markerShape of
          PE_GMSP_RECTANGLESHAPE : ListItem(FIndex).FMarkerShape := gshRectangle;
          PE_GMSP_CIRCLESHAPE    : ListItem(FIndex).FMarkerShape := gshCircle;
          PE_GMSP_DIAMONDSHAPE   : ListItem(FIndex).FMarkerShape := gshDiamond;
          PE_GMSP_TRIANGLESHAPE  : ListItem(FIndex).FMarkerShape := gshTriangle;
          else
            ListItem(FIndex).FMarkerShape := gshDefault;
        end;
        {DataPoints}
        case GrOptionInfo.dataPoints of
          PE_GDP_NONE      : ListItem(FIndex).FDataPoints := gdpNone;
          PE_GDP_SHOWLABEL : ListItem(FIndex).FDataPoints := gdpShowLabel;
          PE_GDP_SHOWVALUE : ListItem(FIndex).FDataPoints := gdpShowValue;
          else
            ListItem(FIndex).FDataPoints := gdpDefault;
        end;
        {NumberFormat}
        case GrOptionInfo.dataValueNumberFormat of
          PE_GNF_NODECIMAL          : ListItem(FIndex).FNumberFormat := gnfNoDecimal;
          PE_GNF_ONEDECIMAL         : ListItem(FIndex).FNumberFormat := gnfOneDecimal;
          PE_GNF_TWODECIMAL         : ListItem(FIndex).FNumberFormat := gnfTwoDecimal;
          PE_GNF_CURRENCYNODECIMAL  : ListItem(FIndex).FNumberFormat := gnfCurrencyNoDecimal;
          PE_GNF_CURRENCYTWODECIMAL : ListItem(FIndex).FNumberFormat := gnfCurrencyTwoDecimal;
          PE_GNF_PERCENTNODECIMAL   : ListItem(FIndex).FNumberFormat := gnfPercentNoDecimal;
          PE_GNF_PERCENTONEDECIMAL  : ListItem(FIndex).FNumberFormat := gnfPercentOneDecimal;
          PE_GNF_PERCENTTWODECIMAL  : ListItem(FIndex).FNumberFormat := gnfPercentTwoDecimal;
          else
            ListItem(FIndex).FNumberFormat := gnfDefault;
        end;
        {ViewingAngle}
        case GrOptionInfo.viewingAngle of
          PE_GVA_STANDARDVIEW      : ListItem(FIndex).FViewingAngle := gvaStandard;
          PE_GVA_TALLVIEW          : ListItem(FIndex).FViewingAngle := gvaTall;
          PE_GVA_TOPVIEW           : ListItem(FIndex).FViewingAngle := gvaTop;
          PE_GVA_DISTORTEDVIEW     : ListItem(FIndex).FViewingAngle := gvaDistorted;
          PE_GVA_SHORTVIEW         : ListItem(FIndex).FViewingAngle := gvaShort;
          PE_GVA_GROUPEYEVIEW      : ListItem(FIndex).FViewingAngle := gvaGroupEye;
          PE_GVA_GROUPEMPHASISVIEW : ListItem(FIndex).FViewingAngle := gvaGroupEmphasis;
          PE_GVA_FEWSERIESVIEW     : ListItem(FIndex).FViewingAngle := gvaFewSeries;
          PE_GVA_FEWGROUPSVIEW     : ListItem(FIndex).FViewingAngle := gvaFewGroups;
          PE_GVA_DISTORTEDSTDVIEW  : ListItem(FIndex).FViewingAngle := gvaDistortedStd;
          PE_GVA_THICKGROUPSVIEW   : ListItem(FIndex).FViewingAngle := gvaThickGroups;
          PE_GVA_SHORTERVIEW       : ListItem(FIndex).FViewingAngle := gvaShorter;
          PE_GVA_THICKSERIESVIEW   : ListItem(FIndex).FViewingAngle := gvaThickSeries;
          PE_GVA_THICKSTDVIEW      : ListItem(FIndex).FViewingAngle := gvaThickStd;
          PE_GVA_BIRDSEYEVIEW      : ListItem(FIndex).FViewingAngle := gvaBirdsEye;
          PE_GVA_MAXVIEW           : ListItem(FIndex).FViewingAngle := gvaMax;
          else
            ListItem(FIndex).FViewingAngle := gvaDefault;
        end;
        Inc(cnt2);
        Result := True;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.Send : boolean;
var
   nIndex       : smallint;
   nGraph       : smallint;
   SectionCode  : smallint;
   GrOptionInfo : PEGraphOptionInfo;
   Changed      : boolean;
   iTmp         : integer;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  {GraphOptionInfo only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Number}
    nGraph := ListItem(nIndex).FSectionGraphNum;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, SectionCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'GraphOptionInfo.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get GraphOptionInfo from Report}
    Cr.SetDLLHandle;
    if not PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.Send <PEGetGraphOptionInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {GraphColor}
    if ListItem(nIndex).FColor <> gcDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FColor of
        gcColor      : iTmp := PE_GCR_COLORCHART;
        gcMonochrome : iTmp := PE_GCR_BLACKANDWHITECHART;
      end;
      if GrOptionInfo.graphColor <> iTmp then
      begin
        GrOptionInfo.graphColor := iTmp;
        Changed := True;
      end;
    end;

    {Legend}
    if ListItem(nIndex).FLegend <> glDefault then
    begin
      iTmp := -1;
      case ListItem(nIndex).FLegend of
        glNone         : iTmp := -1;
        glUpperRight   : iTmp := PE_GLP_PLACEUPPERRIGHT;
        glBottomCenter : iTmp := PE_GLP_PLACEBOTTOMCENTER;
        glTopCenter    : iTmp := PE_GLP_PLACETOPCENTER;
        glRight        : iTmp := PE_GLP_PLACERIGHT;
        glLeft         : iTmp := PE_GLP_PLACELEFT;
      end;
      if iTmp = -1 then {glNone}
      begin
        {If the Legend is set to show, turn it off}
        if GrOptionInfo.showLegend <> 0 then
        begin
          GrOptionInfo.showLegend := 0;
          Changed := True;
        end;
      end
      else
      begin
        if GrOptionInfo.legendPosition <> iTmp then
        begin
          GrOptionInfo.legendPosition := iTmp;
          Changed := True;
        end;
      end;
    end;

    {This guards against an obscure out-of-range(5) value with older(?) graphs}
    if (GrOptionInfo.legendPosition < PE_GLP_PLACEUPPERRIGHT) or
       (GrOptionInfo.legendPosition > PE_GLP_PLACELEFT) then
      GrOptionInfo.legendPosition := PE_GLP_PLACEUPPERRIGHT;

    {PieSize}
    if ListItem(nIndex).FPieSize <> gpsDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FPieSize of
        gpsMinimum : iTmp := PE_GPS_MINIMUMPIESIZE;
        gpsSmall   : iTmp := PE_GPS_SMALLPIESIZE;
        gpsAverage : iTmp := PE_GPS_AVERAGEPIESIZE;
        gpsLarge   : iTmp := PE_GPS_LARGEPIESIZE;
        gpsMaximum : iTmp := PE_GPS_MAXIMUMPIESIZE;
      end;
      if GrOptionInfo.pieSize <> iTmp then
      begin
        GrOptionInfo.pieSize := iTmp;
        Changed := True;
      end;
    end;

    {PieSlice}
    if ListItem(nIndex).FPieSlice <> gslDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FPieSlice of
        gslNone  : iTmp := PE_GDPS_NODETACHMENT;
        gslSmall : iTmp := PE_GDPS_SMALLESTSLICE;
        gslLarge : iTmp := PE_GDPS_LARGESTSLICE;
      end;
      if GrOptionInfo.detachedPieSlice <> iTmp then
      begin
        GrOptionInfo.detachedPieSlice := iTmp;
        Changed := True;
      end;
    end;

    {BarSize}
    if ListItem(nIndex).FBarSize <> gbsDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FBarSize of
        gbsMinimum : iTmp := PE_GBS_MINIMUMBARSIZE;
        gbsSmall   : iTmp := PE_GBS_SMALLBARSIZE;
        gbsAverage : iTmp := PE_GBS_AVERAGEBARSIZE;
        gbsLarge   : iTmp := PE_GBS_LARGEBARSIZE;
        gbsMaximum : iTmp := PE_GBS_MAXIMUMBARSIZE;
      end;
      if GrOptionInfo.barSize <> iTmp then
      begin
        GrOptionInfo.barSize := iTmp;
        Changed := True;
      end;
    end;

    {BarDirection}
    if ListItem(nIndex).FBarDirection <> bdDefault then
    begin
      iTmp := Ord(ListItem(nIndex).FBarDirection);
      if GrOptionInfo.verticalBars <> iTmp then
      begin
        GrOptionInfo.verticalBars := iTmp;
        Changed := True;
      end;
    end;

    {MarkerSize}
    if ListItem(nIndex).FMarkerSize <> gmsDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FMarkerSize of
        gmsSmall       : iTmp := PE_GMS_SMALLMARKERS;
        gmsMediumSmall : iTmp := PE_GMS_MEDIUMSMALLMARKERS;
        gmsMedium      : iTmp := PE_GMS_MEDIUMMARKERS;
        gmsMediumLarge : iTmp := PE_GMS_MEDIUMLARGEMARKERS;
        gmsLarge       : iTmp := PE_GMS_LARGEMARKERS;
      end;
      if GrOptionInfo.markerSize <> iTmp then
      begin
        GrOptionInfo.markerSize := iTmp;
        Changed := True;
      end;
    end;

    {MarkerShape}
    if ListItem(nIndex).FMarkerShape <> gshDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FMarkerShape of
        gshRectangle : iTmp := PE_GMSP_RECTANGLESHAPE;
        gshCircle    : iTmp := PE_GMSP_CIRCLESHAPE;
        gshDiamond   : iTmp := PE_GMSP_DIAMONDSHAPE;
        gshTriangle  : iTmp := PE_GMSP_TRIANGLESHAPE;
      end;
      if GrOptionInfo.markerShape <> iTmp then
      begin
        GrOptionInfo.markerShape := iTmp;
        Changed := True;
      end;
    end;

    {DataPoints}
    if ListItem(nIndex).FDataPoints <> gdpDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FDataPoints of
        gdpNone      : iTmp := PE_GDP_NONE;
        gdpShowLabel : iTmp := PE_GDP_SHOWLABEL;
        gdpShowValue : iTmp := PE_GDP_SHOWVALUE;
      end;
      if GrOptionInfo.dataPoints <> iTmp then
      begin
        GrOptionInfo.dataPoints := iTmp;
        Changed := True;
      end;
    end;

    {NumberFormat}
    if ListItem(nIndex).FNumberFormat <> gnfDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FNumberFormat of
        gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
        gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
        gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
        gnfCurrencyNoDecimal  : iTmp := PE_GNF_CURRENCYNODECIMAL;
        gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
        gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
        gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
        gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
      end;
      if GrOptionInfo.dataValueNumberFormat <> iTmp then
      begin
        GrOptionInfo.dataValueNumberFormat := iTmp;
        Changed := True;
      end;
    end;

    {ViewingAngle}
    if ListItem(nIndex).FViewingAngle <> gvaDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(nIndex).FViewingAngle of
        gvaStandard      : iTmp := PE_GVA_STANDARDVIEW;
        gvaTall          : iTmp := PE_GVA_TALLVIEW;
        gvaTop           : iTmp := PE_GVA_TOPVIEW;
        gvaDistorted     : iTmp := PE_GVA_DISTORTEDVIEW;
        gvaShort         : iTmp := PE_GVA_SHORTVIEW;
        gvaGroupEye      : iTmp := PE_GVA_GROUPEYEVIEW;
        gvaGroupEmphasis : iTmp := PE_GVA_GROUPEMPHASISVIEW;
        gvaFewSeries     : iTmp := PE_GVA_FEWSERIESVIEW;
        gvaFewGroups     : iTmp := PE_GVA_FEWGROUPSVIEW;
        gvaDistortedStd  : iTmp := PE_GVA_DISTORTEDSTDVIEW;
        gvaThickGroups   : iTmp := PE_GVA_THICKGROUPSVIEW;
        gvaShorter       : iTmp := PE_GVA_SHORTERVIEW;
        gvaThickSeries   : iTmp := PE_GVA_THICKSERIESVIEW;
        gvaThickStd      : iTmp := PE_GVA_THICKSTDVIEW;
        gvaBirdsEye      : iTmp := PE_GVA_BIRDSEYEVIEW;
        gvaMax           : iTmp := PE_GVA_MAXVIEW;
      end;
      if GrOptionInfo.viewingAngle <> iTmp then
      begin
        GrOptionInfo.viewingAngle := iTmp;
        Changed := True;
      end;
    end;

    {Send the GraphOptionInfo to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphOptionInfo.Send <PESetGraphOptionInfo>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetNumber : TCrGraphOptionInfoNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetNumber (const Value: TCrGraphOptionInfoNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'GraphOptionInfo.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function  TCrpeGraphOptionInfo.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionGraphNum                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetSectionGraphNum : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSectionGraphNum;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionGraphNum                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetSectionGraphNum (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSectionGraphNum := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetColor                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetColor : TCrGraphColor;
begin
  Result := gcDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FColor;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetColor                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetColor (const Value: TCrGraphColor);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FColor := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetLegend                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetLegend : TCrGraphLegend;
begin
  Result := glDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FLegend;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetLegend                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetLegend (const Value: TCrGraphLegend);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FLegend := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetPieSize                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetPieSize : TCrGraphPieSize;
begin
  Result := gpsDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPieSize;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetPieSize                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetPieSize (const Value: TCrGraphPieSize);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPieSize := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetPieSlice                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetPieSlice : TCrGraphPieSlice;
begin
  Result := gslDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FPieSlice;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetPieSlice                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetPieSlice (const Value: TCrGraphPieSlice);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FPieSlice := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetBarSize                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetBarSize : TCrGraphBarSize;
begin
  Result := gbsDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FBarSize;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetBarSize                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetBarSize (const Value: TCrGraphBarSize);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FBarSize := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetBarDirection                                           }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetBarDirection : TCrGraphBarDirection;
begin
  Result := bdDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FBarDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetBarDirection                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetBarDirection (const Value: TCrGraphBarDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FBarDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMarkerSize                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetMarkerSize : TCrGraphMarkerSize;
begin
  Result := gmsDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMarkerSize;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMarkerSize                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetMarkerSize (const Value: TCrGraphMarkerSize);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMarkerSize := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMarkerShape                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetMarkerShape : TCrGraphMarkerShape;
begin
  Result := gshDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMarkerShape;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMarkerShape                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetMarkerShape (const Value: TCrGraphMarkerShape);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMarkerShape := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataPoints                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetDataPoints : TCrGraphDataPoints;
begin
  Result := gdpDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataPoints;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataPoints                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetDataPoints (const Value: TCrGraphDataPoints);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataPoints := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNumberFormat                                           }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetNumberFormat : TCrGraphNumberFormat;
begin
  Result := gnfDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumberFormat;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumberFormat                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetNumberFormat (const Value: TCrGraphNumberFormat);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNumberFormat := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetViewingAngle                                           }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetViewingAngle : TCrGraphViewingAngle;
begin
  Result := gvaDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FViewingAngle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetViewingAngle                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetViewingAngle (const Value: TCrGraphViewingAngle);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FViewingAngle := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := SectionCodeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphOptionInfo[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphOptionInfo.GetItem(nIndex: integer) : TCrpeGraphOptionInfo;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGraphAxisItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphAxisItem.Create;
begin
  inherited Create;
  FNumber           := -1;
  FSectionGraphNum  := -1;
  FSection          := '';
  { Grid Lines }
  FGridLineX        := gglDefault;
  FGridLineY        := gglDefault;
  FGridLineY2       := gglDefault;
  FGridLineZ        := gglDefault;
  { Auto Range }
  FDataValuesY      := gdvDefault;
  FDataValuesY2     := gdvDefault;
  FDataValuesZ      := gdvDefault;
  { Min/Max Values }
  FMinY             := -1;
  FMaxY             := -1;
  FMinY2            := -1;
  FMaxY2            := -1;
  FMinZ             := -1;
  FMaxZ             := -1;
  { Number Format }
  FNumberFormatY    := gnfDefault;
  FNumberFormatY2   := gnfDefault;
  FNumberFormatZ    := gnfDefault;
  { Automatic Division }
  FDivisionTypeY    := gdvDefault;
  FDivisionTypeY2   := gdvDefault;
  FDivisionTypeZ    := gdvDefault;
  { Manual Division }
  FDivisionsY       := -1;
  FDivisionsY2      := -1;
  FDivisionsZ       := -1;
end;


{******************************************************************************}
{ Class TCrpeGraphAxis                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphAxis.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphAxis.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Member procedure Clear                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.CopyFrom (Source: TCrpeGraphAxis);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FSectionGraphNum := Source[cnt].SectionGraphNum;
    ListItem(cnt).FSection := Source[cnt].Section;
    ListItem(cnt).FGridLineX := Source[cnt].GridLineX;
    ListItem(cnt).FGridLineY := Source[cnt].GridLineY;
    ListItem(cnt).FGridLineY2 := Source[cnt].GridLineY2;
    ListItem(cnt).FGridLineZ := Source[cnt].GridLineZ;
    ListItem(cnt).FDataValuesY := Source[cnt].DataValuesY;
    ListItem(cnt).FDataValuesY2 := Source[cnt].DataValuesY2;
    ListItem(cnt).FDataValuesZ := Source[cnt].DataValuesZ;
    ListItem(cnt).FMinY := Source[cnt].MinY;
    ListItem(cnt).FMaxY := Source[cnt].MaxY;
    ListItem(cnt).FMinY2 := Source[cnt].MinY2;
    ListItem(cnt).FMaxY2 := Source[cnt].MaxY2;
    ListItem(cnt).FMinZ := Source[cnt].MinZ;
    ListItem(cnt).FMaxZ := Source[cnt].MaxZ;
    ListItem(cnt).FNumberFormatY := Source[cnt].NumberFormatY;
    ListItem(cnt).FNumberFormatY2 := Source[cnt].NumberFormatY2;
    ListItem(cnt).FNumberFormatZ := Source[cnt].NumberFormatZ;
    ListItem(cnt).FDivisionTypeY := Source[cnt].DivisionTypeY;
    ListItem(cnt).FDivisionTypeY2 := Source[cnt].DivisionTypeY2;
    ListItem(cnt).FDivisionTypeZ := Source[cnt].DivisionTypeZ;
    ListItem(cnt).FDivisionsY := Source[cnt].DivisionsY;
    ListItem(cnt).FDivisionsY2 := Source[cnt].DivisionsY2;
    ListItem(cnt).FDivisionsZ := Source[cnt].DivisionsZ;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Member function Count                                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.IndexOf(GraphNumber : TCrGraphAxisNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GraphNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.ListItem(nIndex: integer): TCrpeGraphAxisItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.Add (GraphNumber: TCrGraphAxisNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GraphNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
       'GraphAxis <' + IntToStr(GraphNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGraphAxisItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GraphNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphAxis.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Member procedure Retrieve                                                    }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.Retrieve : boolean;
var
  GraphAxisInfo   : PEGraphAxisInfo;
  nSections       : smallint;
  nIndex          : smallint;
  nCode           : smallint;
  slSectionsN,
  slSectionsS     : TStringList;
  cnt1,cnt2       : smallint;

  procedure SetGridLine(iRpt: smallint; var glVCL: TCrGraphGridLines);
  begin
    case iRpt of
      PE_GGT_NOGRIDLINES            : glVCL := gglNone;
      PE_GGT_MINORGRIDLINES         : glVCL := gglMinor;
      PE_GGT_MAJORGRIDLINES         : glVCL := gglMajor;
      PE_GGT_MAJORANDMINORGRIDLINES : glVCL := gglMajorAndMinor;
      else
        glVCL := gglDefault;
    end;
  end;

  procedure SetDataValues(iRpt: smallint; var dvVCL: TCrGraphDVType);
  begin
    case iRpt of
      0 : dvVCL := gdvManual;
      1 : dvVCL := gdvAutomatic;
      else
        dvVCL := gdvDefault;
    end;
  end;

  procedure SetNumberFormat(iRpt: smallint; var nfVCL: TCrGraphNumberFormat);
  begin
    case iRpt of
      PE_GNF_NODECIMAL          : nfVCL := gnfNoDecimal;
      PE_GNF_ONEDECIMAL         : nfVCL := gnfOneDecimal;
      PE_GNF_TWODECIMAL         : nfVCL := gnfTwoDecimal;
      PE_GNF_CURRENCYNODECIMAL  : nfVCL := gnfCurrencyNoDecimal;
      PE_GNF_CURRENCYTWODECIMAL : nfVCL := gnfCurrencyTwoDecimal;
      PE_GNF_PERCENTNODECIMAL   : nfVCL := gnfPercentNoDecimal;
      PE_GNF_PERCENTONEDECIMAL  : nfVCL := gnfPercentOneDecimal;
      PE_GNF_PERCENTTWODECIMAL  : nfVCL := gnfPercentTwoDecimal;
      else
        nfVCL := gnfDefault;
    end;
  end;

  procedure SetAutomaticDivision(iRpt: smallint; var adVCL: TCrGraphDVType);
  begin
    case iRpt of
      PE_ADM_AUTOMATIC : adVCL := gdvAutomatic;
      PE_ADM_MANUAL    : adVCL := gdvManual;
      else
        adVCL := gdvDefault;
    end;
  end;

begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;
  {GraphAxis only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  {Clear the GraphOptionInfo strings}
  Clear;
  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GraphAxis.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  cnt2 := 0;
  {Loop through sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      nCode := StrToInt(slSectionsN[nIndex]);
      {Get GraphAxis}
      Cr.SetDLLHandle;
      if PEGetGraphAxisInfo(Cr.FPrintJob, nCode, cnt1, GraphAxisInfo) then
      begin
        Add(cnt2);
        {Number of Graph in Section}
        ListItem(FIndex).FSectionGraphNum := cnt1;
        {SectionCode}
        ListItem(FIndex).FSection := slSectionsS[nIndex];

        {GridLines}
        SetGridLine(GraphAxisInfo.groupAxisGridLine,
          ListItem(FIndex).FGridLineX);
        SetGridLine(GraphAxisInfo.dataAxisYGridLine,
          ListItem(FIndex).FGridLineY);
        SetGridLine(GraphAxisInfo.dataAxisY2GridLine,
          ListItem(FIndex).FGridLineY2);
        SetGridLine(GraphAxisInfo.seriesAxisGridLine,
          ListItem(FIndex).FGridLineZ);

        {DataValues - AutoRange}
        SetDataValues(GraphAxisInfo.dataAxisYAutoRange,
          ListItem(FIndex).FDataValuesY);
        SetDataValues(GraphAxisInfo.dataAxisY2AutoRange,
          ListItem(FIndex).FDataValuesY2);
        SetDataValues(GraphAxisInfo.seriesAxisAutoRange,
          ListItem(FIndex).FDataValuesZ);

        {Min/Max}
        ListItem(FIndex).FMinY  := GraphAxisInfo.dataAxisYMinValue;
        ListItem(FIndex).FMaxY  := GraphAxisInfo.dataAxisYMaxValue;
        ListItem(FIndex).FMinY2 := GraphAxisInfo.dataAxisY2MinValue;
        ListItem(FIndex).FMaxY2 := GraphAxisInfo.dataAxisY2MaxValue;
        ListItem(FIndex).FMinZ  := GraphAxisInfo.seriesAxisMinValue;
        ListItem(FIndex).FMaxZ  := GraphAxisInfo.seriesAxisMaxValue;

        {NumberFormat}
        SetNumberFormat(GraphAxisInfo.dataAxisYNumberFormat,
           ListItem(FIndex).FNumberFormatY);
        SetNumberFormat(GraphAxisInfo.dataAxisY2NumberFormat,
           ListItem(FIndex).FNumberFormatY2);
        SetNumberFormat(GraphAxisInfo.seriesAxisNumberFormat,
           ListItem(FIndex).FNumberFormatZ);

        {Automatic Division}
        SetAutomaticDivision(GraphAxisInfo.dataAxisYAutomaticDivision,
          ListItem(FIndex).FDivisionTypeY);
        SetAutomaticDivision(GraphAxisInfo.dataAxisY2AutomaticDivision,
          ListItem(FIndex).FDivisionTypeY2);
        SetAutomaticDivision(GraphAxisInfo.seriesAxisAutomaticDivision,
          ListItem(FIndex).FDivisionTypeZ);

        {Manual Division}
        ListItem(FIndex).FDivisionsY  := GraphAxisInfo.dataAxisYManualDivision;
        ListItem(FIndex).FDivisionsY2 := GraphAxisInfo.dataAxisY2ManualDivision;
        ListItem(FIndex).FDivisionsZ  := GraphAxisInfo.seriesAxisManualDivision;

        Inc(cnt2);
        Result := True;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.Send : boolean;
var
   nIndex         : smallint;
   nGraph         : smallint;
   SectionCode    : smallint;
   GraphAxisInfo  : PEGraphAxisInfo;
   iTmp           : integer;
   fTmp           : Double;
   Changed        : boolean;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;
  {GraphAxis only available in SCR 7+}
  if Cr.FVersion.FMajor < 7 then
    Exit;

  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Number}
    nGraph := ListItem(FIndex).FSectionGraphNum;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(FIndex).FSection, SectionCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'GraphAxis.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get GraphAxis from Report}
    Cr.SetDLLHandle;
    if not PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.Send <PEGetGraphAxisInfo>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {GridLines}
    if ListItem(FIndex).FGridLineX <> gglDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FGridLineX of
        gglNone          : iTmp := PE_GGT_NOGRIDLINES;
        gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
        gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
        gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
      end;
      if GraphAxisInfo.groupAxisGridLine <> iTmp then
      begin
        GraphAxisInfo.groupAxisGridLine := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FGridLineY <> gglDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FGridLineY of
        gglNone          : iTmp := PE_GGT_NOGRIDLINES;
        gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
        gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
        gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
      end;
      if GraphAxisInfo.dataAxisYGridLine <> iTmp then
      begin
        GraphAxisInfo.dataAxisYGridLine := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FGridLineY2 <> gglDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FGridLineY2 of
        gglNone          : iTmp := PE_GGT_NOGRIDLINES;
        gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
        gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
        gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
      end;
      if GraphAxisInfo.dataAxisY2GridLine <> iTmp then
      begin
        GraphAxisInfo.dataAxisY2GridLine := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FGridLineZ <> gglDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FGridLineZ of
        gglNone          : iTmp := PE_GGT_NOGRIDLINES;
        gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
        gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
        gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
      end;
      if GraphAxisInfo.seriesAxisGridline <> iTmp then
      begin
        GraphAxisInfo.seriesAxisGridline := iTmp;
        Changed := True;
      end;
    end;

    {DataValues - AutoRange}
    if ListItem(FIndex).FDataValuesY <> gdvDefault then
    begin
      iTmp := Ord(ListItem(FIndex).FDataValuesY);
      if iTmp = 2 then
        iTmp := 0
      else
        iTmp := 1;
      if GraphAxisInfo.dataAxisYAutoRange <> iTmp then
      begin
        GraphAxisInfo.dataAxisYAutoRange := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FDataValuesY2 <> gdvDefault then
    begin
      iTmp := Ord(ListItem(FIndex).FDataValuesY2);
      if iTmp = 2 then
        iTmp := 0
      else
        iTmp := 1;
      if GraphAxisInfo.dataAxisY2AutoRange <> iTmp then
      begin
        GraphAxisInfo.dataAxisY2AutoRange := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FDataValuesZ <> gdvDefault then
    begin
      iTmp := Ord(ListItem(FIndex).FDataValuesZ);
      if iTmp = 2 then
        iTmp := 0
      else
        iTmp := 1;
      if GraphAxisInfo.seriesAxisAutoRange <> iTmp then
      begin
        GraphAxisInfo.seriesAxisAutoRange := iTmp;
        Changed := True;
      end;
    end;

    {Min/Max}
    if ListItem(FIndex).FMinY > -1 then
    begin
      fTmp := ListItem(FIndex).FMinY;
      if GraphAxisInfo.dataAxisYMinValue <> fTmp then
      begin
        GraphAxisInfo.dataAxisYMinValue := fTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FMaxY > -1 then
    begin
      fTmp := ListItem(FIndex).FMaxY;
      if GraphAxisInfo.dataAxisYMaxValue <> fTmp then
      begin
        GraphAxisInfo.dataAxisYMaxValue := fTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FMinY2 > -1 then
    begin
      fTmp := ListItem(FIndex).FMinY2;
      if GraphAxisInfo.dataAxisY2MinValue <> fTmp then
      begin
        GraphAxisInfo.dataAxisY2MinValue := fTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FMaxY2 > -1 then
    begin
      fTmp := ListItem(FIndex).FMaxY2;
      if GraphAxisInfo.dataAxisY2MaxValue <> fTmp then
      begin
        GraphAxisInfo.dataAxisY2MaxValue := fTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FMinZ > -1 then
    begin
      fTmp := ListItem(FIndex).FMinZ;
      if GraphAxisInfo.seriesAxisMinValue <> fTmp then
      begin
        GraphAxisInfo.seriesAxisMinValue := fTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FMaxZ > -1 then
    begin
      fTmp := ListItem(FIndex).FMaxZ;
      if GraphAxisInfo.seriesAxisMaxValue <> fTmp then
      begin
        GraphAxisInfo.seriesAxisMaxValue := fTmp;
        Changed := True;
      end;
    end;

    {NumberFormat}
    if ListItem(FIndex).FNumberFormatY <> gnfDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FNumberFormatY of
        gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
        gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
        gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
        gnfCurrencyNoDecimal  : iTmp := PE_GNF_CURRENCYNODECIMAL;
        gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
        gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
        gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
        gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
      end;
      if GraphAxisInfo.dataAxisYNumberFormat <> iTmp then
      begin
        GraphAxisInfo.dataAxisYNumberFormat := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FNumberFormatY2 <> gnfDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FNumberFormatY2 of
        gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
        gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
        gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
        gnfCurrencyNoDecimal  : iTmp := PE_GNF_CURRENCYNODECIMAL;
        gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
        gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
        gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
        gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
      end;
      if GraphAxisInfo.dataAxisY2NumberFormat <> iTmp then
      begin
        GraphAxisInfo.dataAxisY2NumberFormat := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FNumberFormatZ <> gnfDefault then
    begin
      iTmp := PE_UNCHANGED;
      case ListItem(FIndex).FNumberFormatZ of
        gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
        gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
        gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
        gnfCurrencyNoDecimal  : iTmp := PE_GNF_CURRENCYNODECIMAL;
        gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
        gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
        gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
        gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
      end;
      if GraphAxisInfo.seriesAxisNumberFormat <> iTmp then
      begin
        GraphAxisInfo.seriesAxisNumberFormat := iTmp;
        Changed := True;
      end;
    end;

    {Automatic Division}
    if ListItem(FIndex).FDivisionTypeY <> gdvDefault then
    begin
      iTmp := Ord(ListItem(FIndex).FDivisionTypeY);
      if iTmp = 2 then
        iTmp := PE_ADM_MANUAL
      else
        iTmp := PE_ADM_AUTOMATIC;
      if GraphAxisInfo.dataAxisYAutomaticDivision <> iTmp then
      begin
        GraphAxisInfo.dataAxisYAutomaticDivision := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FDivisionTypeY2 <> gdvDefault then
    begin
      iTmp := Ord(ListItem(FIndex).FDivisionTypeY2);
      if iTmp = 2 then
        iTmp := PE_ADM_MANUAL
      else
        iTmp := PE_ADM_AUTOMATIC;
      if GraphAxisInfo.dataAxisY2AutomaticDivision <> iTmp then
      begin
        GraphAxisInfo.dataAxisY2AutomaticDivision := iTmp;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FDivisionTypeZ <> gdvDefault then
    begin
      iTmp := Ord(ListItem(FIndex).FDivisionTypeZ);
      if iTmp = 2 then
        iTmp := PE_ADM_MANUAL
      else
        iTmp := PE_ADM_AUTOMATIC;
      if GraphAxisInfo.seriesAxisAutomaticDivision <> iTmp then
      begin
        GraphAxisInfo.seriesAxisAutomaticDivision := iTmp;
        Changed := True;
      end;
    end;

    {Manual Division}
    if ListItem(FIndex).FDivisionsY > -1 then
    begin
      if GraphAxisInfo.dataAxisYManualDivision <> ListItem(FIndex).FDivisionsY then
      begin
        GraphAxisInfo.dataAxisYManualDivision := ListItem(FIndex).FDivisionsY;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FDivisionsY2 > -1 then
    begin
      if GraphAxisInfo.dataAxisY2ManualDivision <> ListItem(FIndex).FDivisionsY2 then
      begin
        GraphAxisInfo.dataAxisY2ManualDivision := ListItem(FIndex).FDivisionsY2;
        Changed := True;
      end;
    end;
    if ListItem(FIndex).FDivisionsZ > -1 then
    begin
      if GraphAxisInfo.seriesAxisManualDivision <> ListItem(FIndex).FDivisionsZ then
      begin
        GraphAxisInfo.seriesAxisManualDivision := ListItem(FIndex).FDivisionsZ;
        Changed := True;
      end;
    end;

    {Send the GraphAxis to the Report}
    if Changed then
    begin
      Cr.SetDLLHandle;
      if not PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphAxis.Send <PESetGraphAxisInfo>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetNumber : TCrGraphAxisNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumber (const Value: TCrGraphAxisNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'GraphAxis.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function  TCrpeGraphAxis.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionGraphNum                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetSectionGraphNum : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSectionGraphNum;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionGraphNum                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetSectionGraphNum (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSectionGraphNum := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGridLineX                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetGridLineX : TCrGraphGridLines;
begin
  Result := gglDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGridLineX;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGridLineX                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineX (const Value: TCrGraphGridLines);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGridLineX := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGridLineY                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetGridLineY : TCrGraphGridLines;
begin
  Result := gglDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGridLineY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGridLineY                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineY (const Value: TCrGraphGridLines);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGridLineY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGridLineY2                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetGridLineY2 : TCrGraphGridLines;
begin
  Result := gglDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGridLineY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGridLineY2                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineY2 (const Value: TCrGraphGridLines);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGridLineY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGridLineZ                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetGridLineZ : TCrGraphGridLines;
begin
  Result := gglDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGridLineZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGridLineZ                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineZ (const Value: TCrGraphGridLines);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGridLineZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataValuesY                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDataValuesY : TCrGraphDVType;
begin
  Result := gdvDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataValuesY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataValuesY                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDataValuesY (const Value: TCrGraphDVType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataValuesY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataValuesY2                                           }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDataValuesY2 : TCrGraphDVType;
begin
  Result := gdvDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataValuesY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataValuesY2                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDataValuesY2 (const Value: TCrGraphDVType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataValuesY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataValuesZ                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDataValuesZ : TCrGraphDVType;
begin
  Result := gdvDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataValuesZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataValuesZ                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDataValuesZ (const Value: TCrGraphDVType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataValuesZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMinY                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetMinY : Double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMinY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMinY                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMinY (const Value: Double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMinY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMaxY                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetMaxY : Double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMaxY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMaxY                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMaxY (const Value: Double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMaxY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMinY2                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetMinY2 : Double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMinY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMinY2                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMinY2 (const Value: Double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMinY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMaxY2                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetMaxY2 : Double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMaxY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMaxY2                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMaxY2 (const Value: Double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMaxY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMinZ                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetMinZ : Double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMinZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMinZ                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMinZ (const Value: Double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMinZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetMaxZ                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetMaxZ : Double;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FMaxZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetMaxZ                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMaxZ (const Value: Double);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FMaxZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNumberFormatY                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetNumberFormatY : TCrGraphNumberFormat;
begin
  Result := gnfDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumberFormatY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumberFormatY                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumberFormatY (const Value: TCrGraphNumberFormat);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNumberFormatY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNumberFormatY2                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetNumberFormatY2 : TCrGraphNumberFormat;
begin
  Result := gnfDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumberFormatY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumberFormatY2                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumberFormatY2 (const Value: TCrGraphNumberFormat);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNumberFormatY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNumberFormatZ                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetNumberFormatZ : TCrGraphNumberFormat;
begin
  Result := gnfDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumberFormatZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumberFormatZ                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumberFormatZ (const Value: TCrGraphNumberFormat);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FNumberFormatZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDivisionTypeY                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDivisionTypeY : TCrGraphDVType;
begin
  Result := gdvDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDivisionTypeY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDivisionTypeY                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionTypeY (const Value: TCrGraphDVType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDivisionTypeY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDivisionTypeY2                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDivisionTypeY2 : TCrGraphDVType;
begin
  Result := gdvDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDivisionTypeY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDivisionTypeY2                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionTypeY2 (const Value: TCrGraphDVType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDivisionTypeY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDivisionTypeZ                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDivisionTypeZ : TCrGraphDVType;
begin
  Result := gdvDefault;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDivisionTypeZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDivisionTypeZ                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionTypeZ (const Value: TCrGraphDVType);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDivisionTypeZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDivisionsY                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDivisionsY : LongInt;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDivisionsY;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDivisionsY                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionsY (const Value: LongInt);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDivisionsY := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDivisionsY2                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDivisionsY2 : LongInt;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDivisionsY2;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDivisionsY2                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionsY2 (const Value: LongInt);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDivisionsY2 := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDivisionsZ                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetDivisionsZ : LongInt;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDivisionsZ;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDivisionsZ                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionsZ (const Value: LongInt);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDivisionsZ := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := SectionCodeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
        'GraphAxis[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphAxis.GetItem(nIndex: integer) : TCrpeGraphAxis;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGraphDataItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphDataItem.Create;
begin
  inherited Create;
  FNumber           := -1;
  FSectionGraphNum  := -1;
  FSection          := '';
  FRowGroupN        := -1;
  FColGroupN        := -1;
  FSummarizedFieldN := -1;
  FDirection        := Unknown;
end;


{******************************************************************************}
{ Class TCrpeGraphData                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphData.Create;
begin
  inherited Create;
  FList := TList.Create;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphData.Destroy;
begin
  Clear;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.CopyFrom (Source: TCrpeGraphData);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FSectionGraphNum := Source[cnt].SectionGraphNum;
    ListItem(cnt).FSection := Source[cnt].Section;
    ListItem(cnt).FRowGroupN := Source[cnt].RowGroupN;
    ListItem(cnt).FColGroupN := Source[cnt].ColGroupN;
    ListItem(cnt).FSummarizedFieldN := Source[cnt].SummarizedFieldN;
    ListItem(cnt).FDirection := Source[cnt].Direction;
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphData.IndexOf(GraphNumber : TCrGraphDataNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GraphNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphData.ListItem(nIndex: integer): TCrpeGraphDataItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Member function Count                                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphData.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphData.Add (GraphNumber: TCrGraphDataNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GraphNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'GraphData <' + IntToStr(GraphNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGraphDataItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GraphNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphData.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Member procedure Retrieve                                                    }
{------------------------------------------------------------------------------}
function TCrpeGraphData.Retrieve : boolean;
var
  GraphDataInfo   : PEGraphDataInfo;
  nSections       : smallint;
  nIndex          : smallint;
  nCode           : smallint;
  slSectionsN,
  slSectionsS     : TStringList;
  cnt1,cnt2       : smallint;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the GraphData strings}
  Clear;
  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphData.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GraphData.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  cnt2 := 0;
  {Loop through sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      nCode := StrToInt(slSectionsN[nIndex]);
      {GraphData}
      Cr.SetDLLHandle;
      if PEGetGraphData(Cr.FPrintJob, nCode, cnt1, GraphDataInfo) then
      begin
        Add(cnt2);
        ListItem(FIndex).FSectionGraphNum := cnt1;
        ListItem(FIndex).FSection := slSectionsS[nIndex];
        ListItem(FIndex).FRowGroupN := GraphDataInfo.rowGroupN + 1;
        ListItem(FIndex).FColGroupN := GraphDataInfo.colGroupN + 1;
        ListItem(FIndex).FSummarizedFieldN := GraphDataInfo.summarizedFieldN;
        case GraphDataInfo.graphDirection of
          PE_GRAPH_ROWS_ONLY         : ListItem(FIndex).FDirection := Rows;
          PE_GRAPH_COLS_ONLY         : ListItem(FIndex).FDirection := Cols;
          PE_GRAPH_MIXED_ROW_COL     : ListItem(FIndex).FDirection := RowCol;
          PE_GRAPH_MIXED_COL_ROW     : ListItem(FIndex).FDirection := ColRow;
          PE_GRAPH_UNKNOWN_DIRECTION : ListItem(FIndex).FDirection := Unknown;
        end;
        Inc(cnt2);
        Result := True;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphData.Send : boolean;
const
  PEGraphDirectionCodes : array[TCrGraphDirection] of Integer =
   (PE_GRAPH_ROWS_ONLY, PE_GRAPH_COLS_ONLY, PE_GRAPH_MIXED_ROW_COL,
    PE_GRAPH_MIXED_COL_ROW, PE_GRAPH_UNKNOWN_DIRECTION);
var
  GrData   : PEGraphDataInfo;
  nIndex   : integer;
  nGraph   : smallint;
  nCode    : smallint;
  Changed  : boolean;
  nTmp     : smallint;
begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    {Number}
    nGraph := ListItem(FIndex).FSectionGraphNum;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(FIndex).FSection, nCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'GraphData.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Get GraphData from Report}
    Cr.SetDLLHandle;
    if not PEGetGraphData(Cr.FPrintJob, nCode, nGraph, GrData) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphData.Send <PEGetGraphData>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {RowGroupN}
    nTmp := ListItem(FIndex).FRowGroupN - 1;
    if nTmp > -1 then
    begin
      if GrData.rowGroupN <> nTmp then
      begin
        GrData.rowGroupN := nTmp;
        Changed := True;
      end;
    end
    else
      GrData.rowGroupN := PE_GRAPH_DATA_NULL_SELECTION;

    {ColGroupN}
    nTmp := ListItem(FIndex).FColGroupN - 1;
    if nTmp > -1 then
    begin
      if GrData.colGroupN <> nTmp then
      begin
        GrData.colGroupN := nTmp;
        Changed := True;
      end;
    end
    else
      GrData.colGroupN := PE_GRAPH_DATA_NULL_SELECTION;

    {SummarizedFieldN}
    nTmp := ListItem(FIndex).FSummarizedFieldN;
    if nTmp > -1 then
    begin
      if GrData.summarizedFieldN <> nTmp then
      begin
        GrData.summarizedFieldN := nTmp;
        Changed := True;
      end;
    end
    else
      GrData.summarizedFieldN := PE_GRAPH_DATA_NULL_SELECTION;

    {BarDirection}
    nTmp := PEGraphDirectionCodes[ListItem(FIndex).FDirection];
    if GrData.graphDirection <> nTmp then
    begin
      GrData.graphDirection := nTmp;
      Changed := True;
    end;

    {Send the GraphData to the Report}
    if Changed = True then
    begin
      Cr.SetDLLHandle;
      if not PESetGraphData(Cr.FPrintJob, nCode, nGraph, GrData) then
      begin
        Result := False;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphData.Send <PESetGraphData>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      Result := True;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetNumber : TCrGraphDataNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetNumber (const Value: TCrGraphDataNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'GraphData.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionGraphNum                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetSectionGraphNum : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSectionGraphNum;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionGraphNum                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetSectionGraphNum (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSectionGraphNum := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetRowGroupN                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetRowGroupN : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FRowGroupN;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetRowGroupN                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetRowGroupN (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FRowGroupN := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetColGroupN                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetColGroupN : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FColGroupN;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetColGroupN                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetColGroupN (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FColGroupN := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSummarizedFieldN                                       }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetSummarizedFieldN : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSummarizedFieldN;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSummarizedFieldN                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetSummarizedFieldN (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSummarizedFieldN := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDirection                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetDirection : TCrGraphDirection;
begin
  Result := Unknown;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDirection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDirection                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetDirection (const Value: TCrGraphDirection);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDirection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := SectionCodeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphData.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphData.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphData[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetItem                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphData.GetItem(nIndex: integer) : TCrpeGraphData;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeGraphTextItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphTextItem.Create;
begin
  inherited Create;
  FNumber           := -1;
  FSectionGraphNum  := -1;
  FSection          := '';
  FTitle            := '';
  FSubTitle         := '';
  FFootNote         := '';
  FGroupsTitle      := '';
  FSeriesTitle      := '';
  FXAxisTitle       := '';
  FYAxisTitle       := '';
  FZAxisTitle       := '';
  FTitleFont        := TFont.Create;
  FSubTitleFont     := TFont.Create;
  FFootNoteFont     := TFont.Create;
  FGroupsTitleFont  := TFont.Create;
  FDataTitleFont    := TFont.Create;
  FLegendFont       := TFont.Create;
  FGroupLabelsFont  := TFont.Create;
  FDataLabelsFont   := TFont.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphTextItem.Destroy;
begin
  FTitleFont.Free;
  FSubTitleFont.Free;
  FFootNoteFont.Free;
  FGroupsTitleFont.Free;
  FDataTitleFont.Free;
  FLegendFont.Free;
  FGroupLabelsFont.Free;
  FDataLabelsFont.Free;
  inherited Destroy;
end;


{******************************************************************************}
{ Class TCrpeGraphText                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphText.Create;
begin
  inherited Create;
  FList := TList.Create;
  FFont := TFont.Create; {temporary font for default}
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphText.Destroy;
begin
  Clear;
  FList.Free;
  FFont.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.Clear;
var
  cnt : smallint;
begin
  for cnt := (FList.Count - 1) downto 0 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.CopyFrom (Source: TCrpeGraphText);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Add(Source[cnt].Number);
    ListItem(cnt).FSectionGraphNum := Source[cnt].SectionGraphNum;
    ListItem(cnt).FSection := Source[cnt].Section;
    ListItem(cnt).FTitle := Source[cnt].Title;
    ListItem(cnt).FSubTitle := Source[cnt].SubTitle;
    ListItem(cnt).FFootNote := Source[cnt].FootNote;
    ListItem(cnt).FGroupsTitle := Source[cnt].GroupsTitle;
    ListItem(cnt).FSeriesTitle := Source[cnt].SeriesTitle;
    ListItem(cnt).FXAxisTitle := Source[cnt].XAxisTitle;
    ListItem(cnt).FYAxisTitle := Source[cnt].YAxisTitle;
    ListItem(cnt).FZAxisTitle := Source[cnt].ZAxisTitle;
    {Fonts: SCR7+}
    ListItem(cnt).FTitleFont.Assign(Source[cnt].TitleFont);
    ListItem(cnt).FSubTitleFont.Assign(Source[cnt].SubTitleFont);
    ListItem(cnt).FFootNoteFont.Assign(Source[cnt].FootNoteFont);
    ListItem(cnt).FGroupsTitleFont.Assign(Source[cnt].GroupsTitleFont);
    ListItem(cnt).FDataTitleFont.Assign(Source[cnt].DataTitleFont);
    ListItem(cnt).FLegendFont.Assign(Source[cnt].LegendFont);
    ListItem(cnt).FGroupLabelsFont.Assign(Source[cnt].GroupLabelsFont);
    ListItem(cnt).FDataLabelsFont.Assign(Source[cnt].DataLabelsFont);
  end;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphText.IndexOf(GraphNumber : TCrGraphTextNumber): integer;
var
  cnt : integer;
begin
  Result := -1;
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FNumber = GraphNumber then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphText.ListItem(nIndex: integer): TCrpeGraphTextItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphText.Retrieve : boolean;
const
  PETextArray : array[0..7] of Word = (PE_GTT_TITLE, PE_GTT_SUBTITLE,
    PE_GTT_FOOTNOTE, PE_GTT_SERIESTITLE, PE_GTT_GROUPSTITLE,
    PE_GTT_XAXISTITLE, PE_GTT_YAXISTITLE, PE_GTT_ZAXISTITLE);
  PEFontArray: array[0..7] of Word = (PE_GTF_TITLEFONT, PE_GTF_SUBTITLEFONT,
    PE_GTF_FOOTNOTEFONT, PE_GTF_GROUPSTITLEFONT, PE_GTF_DATATITLEFONT,
    PE_GTF_LEGENDFONT, PE_GTF_GROUPLABELSFONT, PE_GTF_DATALABELSFONT);
type
  TVCLTextArray = array[0..7] of string;
var
  GraphTextInfo   : PEGraphTextInfo;
  FontColorInfo   : PEFontColorInfo;
  hTitle          : Hwnd;
  iTitleLen       : smallint;
  pTitle          : PChar;
  TextArray       : TVCLTextArray;
  nSections       : smallint;
  nIndex          : smallint;
  nCode           : smallint;
  slSectionsN     : TStringList;
  slSectionsS     : TStringList;
  cnt1,cnt2,i     : smallint;
  HasText         : boolean;
  xFont           : TFont;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear the GraphText strings}
  Clear;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphText.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GraphText.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  cnt2 := 0;
  {Loop through sections}
  for nIndex := 0 to (nSections - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      nCode := StrToInt(slSectionsN[nIndex]);
      {SCR 5 & 6}
      if Cr.FVersion.FMajor < 7 then
      begin
        {GraphText}
        Cr.SetDLLHandle;
        if PEGetGraphText(Cr.FPrintJob, nCode, cnt1, GraphTextInfo) then
        begin
          Add(cnt2);
          ListItem(FIndex).FSectionGraphNum := cnt1;
          ListItem(FIndex).FSection := slSectionsS[nIndex];
          ListItem(FIndex).FTitle := String(GraphTextInfo.graphTitle);
          ListItem(FIndex).FSubTitle := String(GraphTextInfo.graphSubTitle);
          ListItem(FIndex).FFootNote := String(GraphTextInfo.graphFootNote);
          ListItem(FIndex).FGroupsTitle := String(GraphTextInfo.graphGroupsTitle);
          ListItem(FIndex).FSeriesTitle := String(GraphTextInfo.graphSeriesTitle);
          ListItem(FIndex).FXAxisTitle := String(GraphTextInfo.graphXAxisTitle);
          ListItem(FIndex).FYAxisTitle := String(GraphTextInfo.graphYAxisTitle);
          ListItem(FIndex).FZAxisTitle := String(GraphTextInfo.graphZAxisTitle);
          Inc(cnt2);
          Result := True;
        end;
      end
      {SCR 7+}
      else
      begin
        HasText := False;
        {Loop through the GraphText calls for each title type}
        for i := 0 to High(PETextArray) do
        begin
          {Initialize Text Array}
          TextArray[i] := '';
          Cr.SetDLLHandle;
          if PEGetGraphTextInfo(Cr.FPrintJob, nCode, cnt1,
            PETextArray[i], hTitle, iTitleLen) then
          begin
            {if iTitleLen > 1 then
             begin}
            {Allocate memory for temp PChar}
            pTitle := StrAlloc(iTitleLen);
            {Get the Text}
            Cr.SetDLLHandle;
            if not PEGetHandleString(hTitle, pTitle, iTitleLen) then
            begin
              if pTitle <> nil then
                StrDispose(pTitle);
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                  'GraphText.Retrieve <PEGetHandleString>') of
                cFalse   : Continue;
                cTrue    : Abort;
                cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end
            else
            begin
              TextArray[i] := String(pTitle);
              HasText := True;
            end;
            StrDispose(pTitle);
          end;
        end;

        {If Text was retrieved, copy to VCL}
        if HasText then
        begin
          Add(cnt2);
          ListItem(FIndex).FSectionGraphNum := cnt1;
          ListItem(FIndex).FSection := slSectionsS[nIndex];
          ListItem(FIndex).FTitle := TextArray[0];
          ListItem(FIndex).FSubTitle := TextArray[1];
          ListItem(FIndex).FFootNote := TextArray[2];
          ListItem(FIndex).FSeriesTitle := TextArray[3];
          ListItem(FIndex).FGroupsTitle := TextArray[4];
          ListItem(FIndex).FXAxisTitle := TextArray[5];
          ListItem(FIndex).FYAxisTitle := TextArray[6];
          ListItem(FIndex).FZAxisTitle := TextArray[7];
          Inc(cnt2);
          Result := True;
          {Get the GraphTextFont information}
          for i := 0 to High(PEFontArray) do
          begin
            Cr.SetDLLHandle;
            if PEGetGraphFontInfo(Cr.FPrintJob, nCode, cnt1,
              PEFontArray[i], FontColorInfo) then
            begin
              xFont := TFont.Create;
              xFont.Name := String(FontColorInfo.faceName);
              {$IFDEF CR_3UP}
              xFont.Charset := FontColorInfo.charSet;
              {$ENDIF CR_3UP}
              {xFont.Color := RGBToColor(FontColorInfo.color);}
              xFont.Color := FontColorInfo.color;
              xFont.Pitch := TFontPitch(FontColorInfo.fontPitch);
              xFont.Size := FontColorInfo.pointSize;
              xFont.Style := [];
              if FontColorInfo.isItalic <> 0 then
                xFont.Style := xFont.Style + [fsItalic];
              if FontColorInfo.isStruckOut <> 0 then
                xFont.Style := xFont.Style + [fsStrikeOut];
              if FontColorInfo.isUnderlined <> 0 then
                xFont.Style := xFont.Style + [fsUnderline];
              if FontColorInfo.weight > FW_NORMAL then
                xFont.Style := xFont.Style + [fsBold];
              {We ignore FontColorInfo.FontFamily}
              case PEFontArray[i] of
                PE_GTF_TITLEFONT       : ListItem(FIndex).FTitleFont.Assign(xFont);
                PE_GTF_SUBTITLEFONT    : ListItem(FIndex).FSubTitleFont.Assign(xFont);
                PE_GTF_FOOTNOTEFONT    : ListItem(FIndex).FFootNoteFont.Assign(xFont);
                PE_GTF_GROUPSTITLEFONT : ListItem(FIndex).FGroupsTitleFont.Assign(xFont);
                PE_GTF_DATATITLEFONT   : ListItem(FIndex).FDataTitleFont.Assign(xFont);
                PE_GTF_LEGENDFONT      : ListItem(FIndex).FLegendFont.Assign(xFont);
                PE_GTF_GROUPLABELSFONT : ListItem(FIndex).FGroupLabelsFont.Assign(xFont);
                PE_GTF_DATALABELSFONT  : ListItem(FIndex).FDataLabelsFont.Assign(xFont);
              end;
              xFont.Free;
            end;
          end;
        end;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphText.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGraphText.Add (GraphNumber: TCrGraphTextNumber): integer;
var
  p1: Pointer;
begin
  Result := -1;
  if IndexOf(GraphNumber) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
        'GraphText <' + IntToStr(GraphNumber) + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    p1 := TCrpeGraphTextItem.Create;
    FIndex := FList.Add(p1);
    ListItem(FIndex).FNumber := GraphNumber;
    Result := FIndex;
  end;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.Delete(nIndex: integer);
begin
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphType.Delete(' + IntToStr(nIndex) + ')') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  ListItem(nIndex).Free;
  FList.Delete(nIndex);
  if FIndex > (FList.Count - 1) then
    FIndex := (FList.Count - 1);
end;
{------------------------------------------------------------------------------}
{ Send method                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphText.Send : boolean;
const
  PETextArray : array[0..7] of Word = (PE_GTT_TITLE, PE_GTT_SUBTITLE,
    PE_GTT_FOOTNOTE, PE_GTT_SERIESTITLE, PE_GTT_GROUPSTITLE,
    PE_GTT_XAXISTITLE, PE_GTT_YAXISTITLE, PE_GTT_ZAXISTITLE);
  PEFontArray: array[0..7] of Word = (PE_GTF_TITLEFONT, PE_GTF_SUBTITLEFONT,
    PE_GTF_FOOTNOTEFONT, PE_GTF_GROUPSTITLEFONT, PE_GTF_DATATITLEFONT,
    PE_GTF_LEGENDFONT, PE_GTF_GROUPLABELSFONT, PE_GTF_DATALABELSFONT);
type
  TVCLTextArray = array[0..7] of string;
var
  GrText          : PEGraphTextInfo;
  FontColorInfo   : PEFontColorInfo;
  nIndex,
  nGraph,
  SectionCode     : smallint;
  xTitle,
  xSubTitle,
  xFootNote,
  xSeriesTitle,
  xGroupsTitle,
  xXAxisTitle,
  xYAxisTitle,
  xZAxisTitle     : string;
  xTitleFont,
  xSubTitleFont,
  xFootNoteFont,
  xGroupsTitleFont,
  xDataTitleFont,
  xLegendFont,
  xGroupLabelsFont,
  xDataLabelsFont : TFont;
  hTitle          : Hwnd;
  iTitleLen       : smallint;
  pTitle          : PChar;
  TextArray       : TVCLTextArray;
  s1              : string;
  i               : integer;
  Changed         : boolean;
  FontChanged     : boolean;

  {Compares Font info from Report and VCL to see if changed}
  function CompareFonts(RptFontInfo: PEFontColorInfo; var RptFont: TFont;
    FontArea: Word): boolean;
  var
    xFont : TFont;
  begin
    Result := False;
    {Store the Report settings}
    RptFont := TFont.Create;
    RptFont.Name := String(RptFontInfo.faceName);
    {$IFDEF CR_3UP}
    RptFont.Charset := RptFontInfo.charSet;
    {$ENDIF CR_3UP}
    {Font Color}
    RptFont.Color := RGBToColor(RptFontInfo.color);
    RptFont.Pitch := TFontPitch(RptFontInfo.fontPitch);
    RptFont.Size := RptFontInfo.pointSize;
    RptFont.Style := [];
    if RptFontInfo.isItalic <> 0 then
      RptFont.Style := RptFont.Style + [fsItalic];
    if RptFontInfo.isStruckOut <> 0 then
      RptFont.Style := RptFont.Style + [fsStrikeOut];
    if RptFontInfo.isUnderlined <> 0 then
      RptFont.Style := RptFont.Style + [fsUnderline];
    if RptFontInfo.weight > FW_NORMAL then
      RptFont.Style := RptFont.Style + [fsBold];
    {We ignore RptFontInfo.FontFamily}

    {Get VCL Font settings}
    case FontArea of
      PE_GTF_TITLEFONT       : xFont := ListItem(FIndex).FTitleFont;
      PE_GTF_SUBTITLEFONT    : xFont := ListItem(FIndex).FSubTitleFont;
      PE_GTF_FOOTNOTEFONT    : xFont := ListItem(FIndex).FFootNoteFont;
      PE_GTF_GROUPSTITLEFONT : xFont := ListItem(FIndex).FGroupsTitleFont;
      PE_GTF_DATATITLEFONT   : xFont := ListItem(FIndex).FDataTitleFont;
      PE_GTF_LEGENDFONT      : xFont := ListItem(FIndex).FLegendFont;
      PE_GTF_GROUPLABELSFONT : xFont := ListItem(FIndex).FGroupLabelsFont;
      PE_GTF_DATALABELSFONT  : xFont := ListItem(FIndex).FDataLabelsFont;
      else
        xFont := ListItem(FIndex).FTitleFont;
    end;

    {Compare VCL and Rpt settings}
    {Name}
    if xFont.Name <> '' then
    begin
      if LowerCase(xFont.Name) = CrEmptyStr then
        xFont.Name := '';
      if xFont.Name <> RptFont.Name then
      begin
        RptFont.Name := xFont.Name;
        Result := True;
      end;
    end;
    {$IFDEF CR_3UP}
    {CharSet}
    if xFont.Charset <> RptFont.Charset then
    begin
      RptFont.Charset := xFont.Charset;
      Result := True;
    end;
    {$ENDIF CR_3UP}
    {Color}
    if xFont.Color <> clUnchangedColor then
    begin
      if xFont.Color <> RptFont.Color then
      begin
        RptFont.Color := xFont.Color;
        Result := True;
      end;
    end;
    {Pitch}
    if xFont.Pitch <> RptFont.Pitch then
    begin
      RptFont.Pitch := xFont.Pitch;
      Result := True;
    end;
    {Size}
    if xFont.Size <> 0 then
    begin
      if xFont.Size <> RptFont.Size then
      begin
        RptFont.Size := xFont.Size;
        Result := True;
      end;
    end;
    {Style}
    if xFont.Style <> RptFont.Style then
    begin
      RptFont.Style := xFont.Style;
      Result := True;
    end;
  end;

  {Copies font information from VCL's TFont to PEFontColorInfo}
  procedure CopyFontInfo(var FontInfo: PEFontColorInfo; VCLFont: TFont);
  begin
    StrPCopy(FontInfo.faceName, VCLFont.Name);
    FontInfo.fontFamily := FF_DONTCARE;
    FontInfo.fontPitch := Ord(VCLFont.Pitch);
    {$IFDEF CR_3UP}
    FontInfo.charSet := VCLFont.Charset;
    {$ELSE}
    FontInfo.charSet := DEFAULT_CHARSET;
    {$ENDIF CR_3UP}
    FontInfo.pointSize := VCLFont.Size;
    if fsItalic in VCLFont.Style then
      FontInfo.isItalic := 1
    else
      FontInfo.isItalic := 0;
    if fsUnderline in VCLFont.Style then
      FontInfo.isUnderlined := 1
    else
      FontInfo.isUnderlined := 0;
    if fsStrikeOut in VCLFont.Style then
      FontInfo.isStruckOut := 1
    else
      FontInfo.isStruckOut := 0;
    if fsBold in VCLFont.Style then
      FontInfo.weight := FW_BOLD
    else
      FontInfo.weight := FW_NORMAL;
    {Font Color}
    FontInfo.color := ColorToRGB(VCLFont.Color);
  end;

begin
  Result := False;
  if (Count = 0) then
    Exit;
  if not Cr.OpenPrintJob then
    Exit;

  for nIndex := 0 to (Count - 1) do
  begin
    Changed := False;
    FontChanged := False;
    {Number}
    nGraph := ListItem(nIndex).FSectionGraphNum;
    {Convert SectionName to Code}
    if not StrToSectionCode(ListItem(nIndex).FSection, SectionCode) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
          'GraphText.Send <StrToSectionCode>') of
        cFalse   : Continue;
        cTrue    : Abort;
        cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {SCR5 and 6}
    if Cr.FVersion.FMajor < 7 then
    begin
      {Get GraphText values from Report}
      Cr.SetDLLHandle;
      if not PEGetGraphText(Cr.FPrintJob, SectionCode, nGraph, GrText) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.Send <PEGetGraphText>') of
          cFalse   : Continue;
          cTrue    : Abort;
          cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      xTitle := String(GrText.graphTitle);
      xSubTitle := String(GrText.graphSubTitle);
      xFootNote := String(GrText.graphFootNote);
      xGroupsTitle := String(GrText.graphGroupsTitle);
      xSeriesTitle := String(GrText.graphSeriesTitle);
      xXAxisTitle := String(GrText.graphXAxisTitle);
      xYAxisTitle := String(GrText.graphYAxisTitle);
      xZAxisTitle := String(GrText.graphZAxisTitle);
    end
    {SCR 7+}
    else
    begin
      {Loop through the GraphText calls for each title type}
      for i := 0 to High(PETextArray) do
      begin
        {Initialize Text Array}
        TextArray[i] := '';
        Cr.SetDLLHandle;
        if PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
          PETextArray[i], hTitle, iTitleLen) then
        begin
          {Allocate memory for temp PChar}
          pTitle := StrAlloc(iTitleLen);
          {Get the Text}
          Cr.SetDLLHandle;
          if not PEGetHandleString(hTitle, pTitle, iTitleLen) then
          begin
            if pTitle <> nil then
              StrDispose(pTitle);
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                 'GraphText.Send <PEGetHandleString>') of
              cFalse   : Continue;
              cTrue    : Abort;
              cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
            end;
          end
          else
            TextArray[i] := String(pTitle);
          StrDispose(pTitle);
        end;
      end;
      {Copy Text to variables}
      xTitle := TextArray[0];
      xSubTitle := TextArray[1];
      xFootNote := TextArray[2];
      xSeriesTitle := TextArray[3];
      xGroupsTitle := TextArray[4];
      xXAxisTitle := TextArray[5];
      xYAxisTitle := TextArray[6];
      xZAxisTitle := TextArray[7];
      {Get the GraphTextFont information}
      for i := 0 to High(PEFontArray) do
      begin
        Cr.SetDLLHandle;
        if PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
          PEFontArray[i], FontColorInfo) then
        begin
          case PEFontArray[i] of
            PE_GTF_TITLEFONT       :
            begin
              if CompareFonts(FontColorInfo, xTitleFont, PE_GTF_TITLEFONT) then
                FontChanged := True;
            end;
            PE_GTF_SUBTITLEFONT    :
            begin
              if CompareFonts(FontColorInfo, xSubTitleFont, PE_GTF_SUBTITLEFONT) then
                FontChanged := True;
            end;
            PE_GTF_FOOTNOTEFONT    :
            begin
              if CompareFonts(FontColorInfo, xFootNoteFont, PE_GTF_FOOTNOTEFONT) then
                FontChanged := True;
            end;
            PE_GTF_GROUPSTITLEFONT :
            begin
              if CompareFonts(FontColorInfo, xGroupsTitleFont, PE_GTF_GROUPSTITLEFONT) then
                FontChanged := True;
            end;
            PE_GTF_DATATITLEFONT   :
            begin
              if CompareFonts(FontColorInfo, xDataTitleFont, PE_GTF_DATATITLEFONT) then
                FontChanged := True;
            end;
            PE_GTF_LEGENDFONT      :
            begin
              if CompareFonts(FontColorInfo, xLegendFont, PE_GTF_LEGENDFONT) then
                FontChanged := True;
            end;
            PE_GTF_GROUPLABELSFONT :
            begin
              if CompareFonts(FontColorInfo, xGroupLabelsFont, PE_GTF_GROUPLABELSFONT) then
                FontChanged := True;
            end;
            PE_GTF_DATALABELSFONT  :
            begin
              if CompareFonts(FontColorInfo, xDataLabelsFont, PE_GTF_DATALABELSFONT) then
                FontChanged := True;
            end;
          end;
        end;
      end;
    end;

    {Title}
    if ListItem(nIndex).FTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FTitle) = CrEmptyStr then
        ListItem(nIndex).FTitle := '';
      if xTitle <> ListItem(nIndex).FTitle then
      begin
        xTitle := ListItem(nIndex).FTitle;
        Changed := True;
      end;
    end;
    {SubTitle}
    if ListItem(nIndex).FSubTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FSubTitle) = CrEmptyStr then
        ListItem(nIndex).FSubTitle := '';
      if xSubTitle <> ListItem(nIndex).FSubTitle then
      begin
        xSubTitle := ListItem(nIndex).FSubTitle;
        Changed := True;
      end;
    end;
    {FootNote}
    if ListItem(nIndex).FFootNote <> '' then
    begin
      if LowerCase(ListItem(nIndex).FFootNote) = CrEmptyStr then
        ListItem(nIndex).FFootNote := '';
      if xFootNote <> ListItem(nIndex).FFootNote then
      begin
        xFootNote := ListItem(nIndex).FFootNote;
        Changed := True;
      end;
    end;
    {GroupsTitle}
    if ListItem(nIndex).FGroupsTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FGroupsTitle) = CrEmptyStr then
        ListItem(nIndex).FGroupsTitle := '';
      if xGroupsTitle <> ListItem(nIndex).FGroupsTitle then
      begin
        xGroupsTitle := ListItem(nIndex).FGroupsTitle;
        Changed := True;
      end;
    end;
    {SeriesTitle}
    if ListItem(nIndex).FSeriesTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FSeriesTitle) = CrEmptyStr then
        ListItem(nIndex).FSeriesTitle := '';
      if xSeriesTitle <> ListItem(nIndex).FSeriesTitle then
      begin
        xSeriesTitle := ListItem(nIndex).FSeriesTitle;
        Changed := True;
      end;
    end;
    {XAxis}
    if ListItem(nIndex).FXAxisTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FXAxisTitle) = CrEmptyStr then
        ListItem(nIndex).FXAxisTitle := '';
      if xXAxisTitle <> ListItem(nIndex).FXAxisTitle then
      begin
        xXAxisTitle := ListItem(nIndex).FXAxisTitle;
        Changed := True;
      end;
    end;
    {YAxis}
    if ListItem(nIndex).FYAxisTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FYAxisTitle) = CrEmptyStr then
        ListItem(nIndex).FYAxisTitle := '';
      if xYAxisTitle <> ListItem(nIndex).FYAxisTitle then
      begin
        xYAxisTitle := ListItem(nIndex).FYAxisTitle;
        Changed := True;
      end;
    end;
    {ZAxis}
    if ListItem(nIndex).FZAxisTitle <> '' then
    begin
      if LowerCase(ListItem(nIndex).FZAxisTitle) = CrEmptyStr then
        ListItem(nIndex).FZAxisTitle := '';
      if xZAxisTitle <> ListItem(nIndex).FZAxisTitle then
      begin
        xZAxisTitle := ListItem(nIndex).FZAxisTitle;
        Changed := True;
      end;
    end;

    {Set the GraphText to the Report}
    {SCR 5 & 6}
    if Cr.FVersion.FMajor < 7 then
    begin
      if Changed then
      begin
        StrCopy(GrText.graphTitle, PChar(xTitle));
        StrCopy(GrText.graphSubTitle, PChar(xSubTitle));
        StrCopy(GrText.graphFootNote, PChar(xFootNote));
        StrCopy(GrText.graphGroupsTitle, PChar(xGroupsTitle));
        StrCopy(GrText.graphSeriesTitle, PChar(xSeriesTitle));
        StrCopy(GrText.graphXAxisTitle, PChar(xXAxisTitle));
        StrCopy(GrText.graphYAxisTitle, PChar(xYAxisTitle));
        StrCopy(GrText.graphZAxisTitle, PChar(xZAxisTitle));
        Cr.SetDLLHandle;
        if not PESetGraphText(Cr.FPrintJob, SectionCode, nGraph, GrText) then
        begin
          Result := False;
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'GraphText.Send <PESetGraphText>') of
            cFalse   : Continue;
            cTrue    : Abort;
            cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        Result := True;
      end;
    end
    {SCR7+}
    else
    begin
      if Changed then
      begin
        {Set Text}
        for i := 0 to High(PETextArray) do
        begin
          case PETextArray[i] of
            PE_GTT_TITLE       : s1 := xTitle;
            PE_GTT_SUBTITLE    : s1 := xSubTitle;
            PE_GTT_FOOTNOTE    : s1 := xFootNote;
            PE_GTT_SERIESTITLE : s1 := xSeriesTitle;
            PE_GTT_GROUPSTITLE : s1 := xGroupsTitle;
            PE_GTT_XAXISTITLE  : s1 := xXAxisTitle;
            PE_GTT_YAXISTITLE  : s1 := xYAxisTitle;
            PE_GTT_ZAXISTITLE  : s1 := xZAxisTitle;
          end;
          Cr.SetDLLHandle;
          if not PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
            PETextArray[i], PChar(s1)) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'GraphText.Send <PESetGraphTextInfo>') of
              cFalse   : Continue;
              cTrue    :
              begin
                xTitleFont.Free;
                xSubTitleFont.Free;
                xFootNoteFont.Free;
                xGroupsTitleFont.Free;
                xDataTitleFont.Free;
                xLegendFont.Free;
                xGroupLabelsFont.Free;
                xDataLabelsFont.Free;
                Abort;
              end;
              cDefault :
              begin
                xTitleFont.Free;
                xSubTitleFont.Free;
                xFootNoteFont.Free;
                xGroupsTitleFont.Free;
                xDataTitleFont.Free;
                xLegendFont.Free;
                xGroupLabelsFont.Free;
                xDataLabelsFont.Free;
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
          end;
        end;
      end;

      if FontChanged then
      begin
        {Set FontInfo}
        for i := 0 to High(PEFontArray) do
        begin
          case PEFontArray[i] of
            PE_GTF_TITLEFONT       : CopyFontInfo(FontColorInfo, xTitleFont);
            PE_GTF_SUBTITLEFONT    : CopyFontInfo(FontColorInfo, xSubTitleFont);
            PE_GTF_FOOTNOTEFONT    : CopyFontInfo(FontColorInfo, xFootNoteFont);
            PE_GTF_GROUPSTITLEFONT : CopyFontInfo(FontColorInfo, xGroupsTitleFont);
            PE_GTF_DATATITLEFONT   : CopyFontInfo(FontColorInfo, xDataTitleFont);
            PE_GTF_LEGENDFONT      : CopyFontInfo(FontColorInfo, xLegendFont);
            PE_GTF_GROUPLABELSFONT : CopyFontInfo(FontColorInfo, xGroupLabelsFont);
            PE_GTF_DATALABELSFONT  : CopyFontInfo(FontColorInfo, xDataLabelsFont);
          end;
          Cr.SetDLLHandle;
          if not PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
            PEFontArray[i], FontColorInfo) then
          begin
            case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                'GraphText.Send <PESetGraphFontInfo>') of
              cFalse   : Continue;
              cTrue    :
              begin
                xTitleFont.Free;
                xSubTitleFont.Free;
                xFootNoteFont.Free;
                xGroupsTitleFont.Free;
                xDataTitleFont.Free;
                xLegendFont.Free;
                xGroupLabelsFont.Free;
                xDataLabelsFont.Free;
                Abort;
              end;
              cDefault :
              begin
                xTitleFont.Free;
                xSubTitleFont.Free;
                xFootNoteFont.Free;
                xGroupsTitleFont.Free;
                xDataTitleFont.Free;
                xLegendFont.Free;
                xGroupLabelsFont.Free;
                xDataLabelsFont.Free;
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
          end;
        end;
      end;
      xTitleFont.Free;
      xSubTitleFont.Free;
      xFootNoteFont.Free;
      xGroupsTitleFont.Free;
      xDataTitleFont.Free;
      xLegendFont.Free;
      xGroupLabelsFont.Free;
      xDataLabelsFont.Free;
    end;
  end; { for }
end; { Send }
{------------------------------------------------------------------------------}
{ Read Access method GetNumber                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetNumber : TCrGraphTextNumber;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNumber;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNumber                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetNumber (const Value: TCrGraphTextNumber);
var
  nIndex : integer;
begin
  if Value = -1 then Exit;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
         'GraphText.Number := ' + IntToStr(Value)) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionGraphNum                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetSectionGraphNum : smallint;
begin
  Result := -1;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSectionGraphNum;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionGraphNum                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSectionGraphNum (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSectionGraphNum := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTitle                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetTitle                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FTitle := Copy(ListItem(FIndex).FTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSubTitle                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetSubTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSubTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSubTitle                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSubTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FSubTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FSubTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FSubTitle := Copy(ListItem(FIndex).FSubTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetFootNote                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetFootNote : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FFootNote;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetFootNote                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetFootNote (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FFootNote := Value;
    {Check Length}
    if Length(ListItem(FIndex).FFootNote) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FFootNote := Copy(ListItem(FIndex).FFootNote, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGroupsTitle                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetGroupsTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGroupsTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGroupsTitle                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetGroupsTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FGroupsTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FGroupsTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FGroupsTitle := Copy(ListItem(FIndex).FGroupsTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSeriesTitle                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetSeriesTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSeriesTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSeriesTitle                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSeriesTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FSeriesTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FSeriesTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FSeriesTitle := Copy(ListItem(FIndex).FSeriesTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetXAxisTitle                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetXAxisTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FXAxisTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetXAxisTitle                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetXAxisTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FXAxisTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FXAxisTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FXAxisTitle := Copy(ListItem(FIndex).FXAxisTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetYAxisTitle                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetYAxisTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FYAxisTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetYAxisTitle                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetYAxisTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FYAxisTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FYAxisTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FYAxisTitle := Copy(ListItem(FIndex).FYAxisTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetZAxisTitle                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetZAxisTitle : TCrGraphTextType;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FZAxisTitle;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetZAxisTitle                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetZAxisTitle (const Value: TCrGraphTextType);
begin
  if IndexValid(FIndex, FList.Count) then
  begin
    ListItem(FIndex).FZAxisTitle := Value;
    {Check Length}
    if Length(ListItem(FIndex).FZAxisTitle) > PE_GRAPH_TEXT_LEN then
      ListItem(FIndex).FZAxisTitle := Copy(ListItem(FIndex).FZAxisTitle, 1, PE_GRAPH_TEXT_LEN);
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetTitleFont                                              }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetTitleFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FTitleFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetTitle                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetTitleFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FTitleFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSubTitle                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetSubTitleFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSubTitleFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSubTitle                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSubTitleFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSubTitleFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetFootNote                                               }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetFootNoteFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FFootNoteFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetFootNote                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetFootNoteFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FFootNoteFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGroupsTitle                                            }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetGroupsTitleFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGroupsTitleFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGroupsTitle                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetGroupsTitleFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGroupsTitleFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataTitleFont                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetDataTitleFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataTitleFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataTitleFont                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetDataTitleFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataTitleFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetLegendFont                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetLegendFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FLegendFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetLegendFont                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetLegendFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FLegendFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetGroupLabelsFont                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetGroupLabelsFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FGroupLabelsFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetGroupLabelsFont                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetGroupLabelsFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FGroupLabelsFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetDataLabelsFont                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetDataLabelsFont : TFont;
begin
  Result := FFont;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FDataLabelsFont;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetDataLabelsFont                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetDataLabelsFont (const Value: TFont);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FDataLabelsFont.Assign(Value);
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSectionAsCode                                          }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetSectionAsCode : smallint;
var
  nCode: Smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
  begin
    StrToSectionCode(ListItem(FIndex).FSection, nCode);
    Result := nCode;
  end;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSectionAsCode                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSectionAsCode (const Value: smallint);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := SectionCodeToStr(Value);
end;
{------------------------------------------------------------------------------}
{ Read method SectionType                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphText.SectionType : string;
begin
  if ListItem(FIndex).FSection[1] = 'D' then
    Result := Copy(ListItem(FIndex).FSection,1,1)
  else
    Result := Copy(ListItem(FIndex).FSection,1,2)
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
    FIndex := nIndex
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'GraphText[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.GraphText[nIndex]                                             }
{------------------------------------------------------------------------------}
function TCrpeGraphText.GetItem(nIndex: integer) : TCrpeGraphText;
begin
  SetIndex(nIndex);
  Result := Self;
end;


{******************************************************************************}
{ Class TCrpeSubreportsItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSubreportsItem.Create;
begin
  inherited Create;
  {Subreport specific variables}
  FName                  := '';
  FSection               := '';
  FNLinks                := 0;
  FOnDemand              := False;
  {General variables shared by Main and Subreports}
  FPrintJob              := 0;
  FReportTitle           := '';
  FDetailCopies          := 1;
  FFieldMapping          := fmAuto;
  {General Classes shared by Main and Subreports}
  FReportOptions         := TCrpeReportOptions.Create;
  FMargins               := TCrpeMargins.Create;
  FConnect               := TCrpeConnect.Create;
  FLogOnInfo             := TCrpeLogonInfo.Create;
  FSectionFont           := TCrpeSectionFont.Create;
  FSectionFormat         := TCrpeSectionFormat.Create;
  FSectionFormatFormulas := TCrpeSectionFormatFormulas.Create;
  FAreaFormat            := TCrpeAreaFormat.Create;
  FAreaFormatFormulas    := TCrpeAreaFormatFormulas.Create;
  FSectionHeight         := TCrpeSectionHeight.Create;
  FSelection             := TCrpeSelection.Create;
  FGroupSelection        := TCrpeGroupSelection.Create;
  FSortFields            := TCrpeSortFields.Create;
  FGroupSortFields       := TCrpeGroupSortFields.Create;
  FGroupCondition        := TCrpeGroupCondition.Create;
  FGroupOptions          := TCrpeGroupOptions.Create;
  FSQL                   := TCrpeSQL.Create;
  FFormulas              := TCrpeFormulas.Create;
  FTables                := TCrpeTables.Create;
  FParamFields           := TCrpeParamFields.Create;
  FSessionInfo           := TCrpeSessionInfo.Create;
  FGraphType             := TCrpeGraphType.Create;
  FGraphText             := TCrpeGraphText.Create;
  FGraphData             := TCrpeGraphData.Create;
  FGraphOptions          := TCrpeGraphOptions.Create;
  FGraphOptionInfo       := TCrpeGraphOptionInfo.Create;
  FGraphAxis             := TCrpeGraphAxis.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSubreportsItem.Destroy;
begin
  {Close the Subreport}
  Cr.SetDLLHandle;
  if (FName <> '') and (FPrintJob > 0) and (Cr.hDLL > 0) then
    PECloseSubreport(FPrintJob);
  FReportOptions.Free;
  FMargins.Free;
  FConnect.Free;
  FLogOnInfo.Free;
  FSectionFont.Free;
  FSectionFormat.Free;
  FSectionFormatFormulas.Free;
  FAreaFormat.Free;
  FAreaFormatFormulas.Free;
  FSectionHeight.Free;
  FSelection.Free;
  FGroupSelection.Free;
  FSortFields.Free;
  FGroupSortFields.Free;
  FGroupCondition.Free;
  FGroupOptions.Free;
  FSQL.Free;
  FFormulas.Free;
  FTables.Free;
  FParamFields.Free;
  FSessionInfo.Free;
  FGraphType.Free;
  FGraphText.Free;
  FGraphData.Free;
  FGraphOptions.Free;
  FGraphOptionInfo.Free;
  FGraphAxis.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ procedure Clear                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.Clear;
begin
  {General variables shared by Main and Subreports}
  FReportTitle  := '';
  FDetailCopies := 1;
  FFieldMapping := fmAuto;
  {General Classes shared by Main and Subreports}
  FReportOptions.Clear;
  FMargins.Clear;
  FConnect.Clear;
  FLogOnInfo.Clear;
  FSectionFont.Clear;
  FSectionFormat.Clear;
  FSectionFormatFormulas.Clear;
  FAreaFormat.Clear;
  FAreaFormatFormulas.Clear;
  FSectionHeight.Clear;
  FSelection.Clear;
  FGroupSelection.Clear;
  FSortFields.Clear;
  FGroupSortFields.Clear;
  FGroupCondition.Clear;
  FGroupOptions.Clear;
  FSQL.Clear;
  FFormulas.Clear;
  FTables.Clear;
  FParamFields.Clear;
  FSessionInfo.Clear;
  FGraphType.Clear;
  FGraphText.Clear;
  FGraphData.Clear;
  FGraphOptions.Clear;
  FGraphOptionInfo.Clear;
  FGraphAxis.Clear;
end;


{******************************************************************************}
{ Class TCrpeSubreports                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSubreports.Create;
begin
  inherited Create;
  FList := TList.Create;
  FSubExecute := False;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSubreports.Destroy;
begin
  Clear;
  ListItem(0).Free;
  FList.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear method                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.Clear;
var
  cnt : smallint;
begin
  {Remove the Subreport info, leave the main Report info}
  for cnt := (FList.Count - 1) downto 1 do
  begin
    ListItem(cnt).Free;
    FList.Delete(cnt);
  end;
  FSubExecute := False;
  FIndex := 0;
end;
{------------------------------------------------------------------------------}
{ Copy method                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.CopyFrom (Source: TCrpeSubreports);
var
  cnt: integer;
begin
  Clear;
  for cnt := 0 to (Source.Count - 1) do
  begin
    Source[cnt];
    Add(Source.Name);
    {Copy variables}
    ListItem(cnt).FSection := Source.Section;
    ListItem(cnt).FNLinks := Source.NLinks;
    ListItem(cnt).FOnDemand := Source.OnDemand;
    ListItem(cnt).FPrintJob := Source.ListItem(cnt).FPrintJob;
    ListItem(cnt).FReportTitle := Source.ListItem(cnt).FReportTitle;
    ListItem(cnt).FDetailCopies := Source.ListItem(cnt).FDetailCopies;
    ListItem(cnt).FFieldMapping := Source.ListItem(cnt).FFieldMapping;
    {Copy Sub classes}
    ListItem(cnt).FReportOptions.CopyFrom(Source.ListItem(cnt).FReportOptions);
    ListItem(cnt).FMargins.CopyFrom(Source.ListItem(cnt).FMargins);
    ListItem(cnt).FConnect.CopyFrom(Source.ListItem(cnt).FConnect);
    ListItem(cnt).FLogOnInfo.CopyFrom(Source.ListItem(cnt).FLogOnInfo);
    ListItem(cnt).FSectionFont.CopyFrom(Source.ListItem(cnt).FSectionFont);
    ListItem(cnt).FSectionFormat.CopyFrom(Source.ListItem(cnt).FSectionFormat);
    ListItem(cnt).FSectionFormatFormulas.CopyFrom(Source.ListItem(cnt).FSectionFormatFormulas);
    ListItem(cnt).FAreaFormat.CopyFrom(Source.ListItem(cnt).FAreaFormat);
    ListItem(cnt).FAreaFormatFormulas.CopyFrom(Source.ListItem(cnt).FAreaFormatFormulas);
    ListItem(cnt).FSectionHeight.CopyFrom(Source.ListItem(cnt).FSectionHeight);
    ListItem(cnt).FSelection.CopyFrom(Source.ListItem(cnt).FSelection);
    ListItem(cnt).FGroupSelection.CopyFrom(Source.ListItem(cnt).FGroupSelection);
    ListItem(cnt).FSortFields.CopyFrom(Source.ListItem(cnt).FSortFields);
    ListItem(cnt).FGroupSortFields.CopyFrom(Source.ListItem(cnt).FGroupSortFields);
    ListItem(cnt).FGroupCondition.CopyFrom(Source.ListItem(cnt).FGroupCondition);
    ListItem(cnt).FGroupOptions.CopyFrom(Source.ListItem(cnt).FGroupOptions);
    ListItem(cnt).FSQL.CopyFrom(Source.ListItem(cnt).FSQL);
    ListItem(cnt).FFormulas.CopyFrom(Source.ListItem(cnt).FFormulas);
    ListItem(cnt).FTables.CopyFrom(Source.ListItem(cnt).FTables);
    ListItem(cnt).FParamFields.CopyFrom(Source.ListItem(cnt).FParamFields);
    ListItem(cnt).FSessionInfo.CopyFrom(Source.ListItem(cnt).FSessionInfo);
    ListItem(cnt).FGraphType.CopyFrom(Source.ListItem(cnt).FGraphType);
    ListItem(cnt).FGraphText.CopyFrom(Source.ListItem(cnt).FGraphText);
    ListItem(cnt).FGraphData.CopyFrom(Source.ListItem(cnt).FGraphData);
    ListItem(cnt).FGraphOptions.CopyFrom(Source.ListItem(cnt).FGraphOptions);
    ListItem(cnt).FGraphOptionInfo.CopyFrom(Source.ListItem(cnt).FGraphOptionInfo);
    ListItem(cnt).FGraphAxis.CopyFrom(Source.ListItem(cnt).FGraphAxis);
  end;
  FSubExecute := Source.FSubExecute;
  FIndex := Source.FIndex;
end;
{------------------------------------------------------------------------------}
{ Count method                                                                 }
{------------------------------------------------------------------------------}
function TCrpeSubreports.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSubreports.IndexOf(SubName: TCrSubreportName): integer;
var
  cnt : integer;
begin
  Result := -1;
  {This only works if the Subreports have unique names!}
  for cnt := 0 to FList.Count - 1 do
  begin
    if ListItem(cnt).FName = SubName then
    begin
      Result := cnt;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ListItem method                                                              }
{------------------------------------------------------------------------------}
function TCrpeSubreports.ListItem(nIndex: integer): TCrpeSubreportsItem;
begin
  Result := FList[nIndex];
end;
{------------------------------------------------------------------------------}
{ Add method                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreports.Add (SubName: TCrSubreportName): integer;
var
  sTmp : string;
  p1   : Pointer;
begin
  {Check Length}
  sTmp := SubName;
  if Length(sTmp) > PE_SUBREPORT_NAME_LEN then
    sTmp := Copy(sTmp, 1, PE_SUBREPORT_NAME_LEN);
  {Skip this test as Subreports could have the same name
   in SCR5,6 and 7 before MR1}
(*
  if IndexOf(SubName) <> -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ITEM_ALREADY_EXISTS,
      'Subreports <' + SubName + '>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
*)
  p1 := TCrpeSubreportsItem.Create;
  FIndex := FList.Add(p1);
  ListItem(FIndex).FName := sTmp;
  ListItem(FIndex).Cr := Cr;
  {Set Main class Pointer variables}
  ListItem(FIndex).FReportOptions.Cr := Cr;
  ListItem(FIndex).FMargins.Cr := Cr;
  ListItem(FIndex).FConnect.Cr := Cr;
  ListItem(FIndex).FTables.Cr := Cr;
  ListItem(FIndex).FParamFields.Cr := Cr;
  ListItem(FIndex).FParamFields.TempInfo.Cr := Cr;
  ListItem(FIndex).FParamFields.TempRanges.Cr := Cr;
  ListItem(FIndex).FSelection.Cr := Cr;
  ListItem(FIndex).FGroupSelection.Cr := Cr;
  ListItem(FIndex).FFormulas.Cr := Cr;
  ListItem(FIndex).FLogOnInfo.Cr := Cr;
  ListItem(FIndex).FSessionInfo.Cr := Cr;
  ListItem(FIndex).FAreaFormat.Cr := Cr;
  ListItem(FIndex).FAreaFormatFormulas.Cr := Cr;
  ListItem(FIndex).FSectionFormat.Cr := Cr;
  ListItem(FIndex).FSectionFormatFormulas.Cr := Cr;
  ListItem(FIndex).FSectionFont.Cr := Cr;
  ListItem(FIndex).FSectionHeight.Cr := Cr;
  ListItem(FIndex).FGraphType.Cr := Cr;
  ListItem(FIndex).FGraphText.Cr := Cr;
  ListItem(FIndex).FGraphData.Cr := Cr;
  ListItem(FIndex).FGraphOptions.Cr := Cr;
  ListItem(FIndex).FGraphOptionInfo.Cr := Cr;
  ListItem(FIndex).FGraphAxis.Cr := Cr;
  ListItem(FIndex).FSortFields.Cr := Cr;
  ListItem(FIndex).FGroupSortFields.Cr := Cr;
  ListItem(FIndex).FGroupCondition.Cr := Cr;
  ListItem(FIndex).FGroupOptions.Cr := Cr;
  ListItem(FIndex).FSQL.Cr := Cr;
  ListItem(FIndex).FSQL.FParams.Cr := Cr;
  ListItem(FIndex).FSQL.FExpressions.Cr := Cr;

  {VCL points to current Subreport}
  SetIndex(FIndex);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete method                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.Delete(nIndex: integer);
begin
  if (nIndex > 0) and (nIndex < (FList.Count)) then
  begin
    ListItem(nIndex).Free;
    FList.Delete(nIndex);
    if FIndex > (FList.Count - 1) then
      FIndex := (FList.Count - 1);
    SetIndex(FIndex);
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_DELETE_SUBREPORTS,
        'Subreports[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Retrieve method                                                              }
{  - Retrieves the Subreport Names                                             }
{  - Creates SubreportInfo structures for each Subreport                       }
{  - Opens each Subreport and saves the Job Number                             }
{------------------------------------------------------------------------------}
function TCrpeSubreports.Retrieve : boolean;
var
  SubreportHandle : LongInt;
  SubreportInfo   : PESubreportInfo;
  slSectionsN     : TStringList;
  slSectionsS     : TStringList;
  nSections       : smallint;
  nSubReports     : smallint;
  SectionCode     : smallint;
  cnt1, cnt2      : integer;
  bSubEx          : boolean;
begin
  Result := False;
  if not Cr.OpenPrintJob then
    Exit;

  {Clear out any previous Subreport info}
  if FList.Count > 1 then
  begin
    {Save and restore the SubExecute setting}
    bSubEx := FSubExecute;
    Clear;
    FSubExecute := bSubEx;
  end;

  {Get the # of Sections in the Report}
  Cr.SetDLLHandle;
  nSections := PEGetNSections(Cr.FPrintJob);
  if (nSections = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Subreports.Retrieve <PEGetNSections>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(slSectionsN, slSectionsS, nSections, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'Subreports.Retrieve <GetSectionCodes>') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Sections}
  for cnt1 := 0 to (nSections - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[cnt1]);
    Cr.SetDLLHandle;
    nSubReports := PEGetNSubreportsInSection(Cr.FPrintJob, SectionCode);
    if nSubReports > 0 then
    begin
      for cnt2 := 0 to nSubReports - 1 do
      begin
        {Get the Subreport Handle}
        Cr.SetDLLHandle;
        SubreportHandle := PEGetNthSubreportInSection(Cr.FPrintJob, SectionCode, cnt2);
        {Get the Subreport Name}
        Cr.SetDLLHandle;
        if not PEGetSubreportInfo(Cr.FPrintJob, SubreportHandle, SubreportInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Subreports.Retrieve <PEGetSubreportInfo>') of
            cFalse   : Continue;
            cTrue    : begin
                slSectionsN.Free;
                slSectionsS.Free;
                Abort;
              end;
            cDefault : begin
                slSectionsN.Free;
                slSectionsS.Free;
                raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
          end;
        end;

        {Create a new Subreport member}
        Add(String(SubreportInfo.SubreportName));
        {Store the Section Code string}
        ListItem(FIndex).FSection := slSectionsS[cnt1];
        {SCR 7+ features}
        if Cr.FVersion.FMajor > 6 then
        begin
          ListItem(FIndex).FNLinks := SubreportInfo.NLinks;
          if SubreportInfo.IsOnDemand > 0 then
            ListItem(FIndex).FOnDemand := True;
        end;
        {Open the Subreport PrintJob}
        Cr.SetDLLHandle;
        ListItem(FIndex).FPrintJob := PEOpenSubreport(
          Cr.FSubreports.ListItem(0).FPrintJob, PChar(ListItem(FIndex).FName));
        {Reset FPrintJob to main Report}
        SetIndex(0);
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  {Set pointer and PrintJob to Main Rpt}
  SetIndex(0);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ GetName method                                                               }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetName : TCrSubreportName;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FName;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetName                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetName (const Value: TCrSubreportName);
var
  nIndex : integer;
begin
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if csLoading in Cr.ComponentState then
    begin
      FIndex := 0;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'Subreports.Name := ' + Value) of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetSection                                                }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetSection : string;
begin
  Result := '';
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FSection;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetSection                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetSection (const Value: string);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FSection := Value;
end;
{------------------------------------------------------------------------------}
{ Read Access method GetNLinks                                                 }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetNLinks : smallint;
begin
  Result := 0;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FNLinks;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetNLinks                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetNLinks (const Value: smallint);
begin
  {Read Only}
end;
{------------------------------------------------------------------------------}
{ Read Access method GetOnDemand                                               }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetOnDemand : boolean;
begin
  Result := False;
  if IndexInRange(FIndex, FList.Count) then
    Result := ListItem(FIndex).FOnDemand;
end;
{------------------------------------------------------------------------------}
{ Write Access method SetOnDemand                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetOnDemand (const Value: boolean);
begin
  if IndexValid(FIndex, FList.Count) then
    ListItem(FIndex).FOnDemand := Value;
end;
{------------------------------------------------------------------------------}
{ Read method GetIndex                                                         }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetIndex : integer;
begin
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Write method SetIndex                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetIndex (const nIndex: integer);
begin
  if (FList.Count > 0) and (nIndex < FList.Count) and (nIndex > -1) then
  begin
    {Update Subreport Object index}
    FIndex := nIndex;
    {Update VCL index}
    Cr.FIndex := FIndex;
    {Update PrintJob Number}
    Cr.FPrintJob := ListItem(FIndex).FPrintJob;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
        'Subreports[' + IntToStr(nIndex) + ']') of
      cFalse   : Exit;
      cTrue    : Abort;
      cDefault : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Member function GetItem                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.Subreports[nIndex]                                            }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetItem(nIndex: integer) : TCrpeSubreports;
begin
  SetIndex(nIndex);
  Result := Self;
end;
{------------------------------------------------------------------------------}
{ Reference Properties                                                         }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetDetailCopies: Smallint;
begin
  Result := Cr.SubItem.FDetailCopies;
end;
procedure TCrpeSubreports.SetDetailCopies(const Value: Smallint);
begin
  Cr.SubItem.FDetailCopies := Value;
end;
function TCrpeSubreports.GetFieldMapping : TCrFieldMappingType;
begin
  Result := Cr.SubItem.FFieldMapping;
end;
procedure TCrpeSubreports.SetFieldMapping(const Value: TCrFieldMappingType);
begin
  Cr.SubItem.FFieldMapping := Value;
end;
function TCrpeSubreports.GetReportTitle: string;
begin
  Result := Cr.SubItem.FReportTitle;
end;
procedure TCrpeSubreports.SetReportTitle(const Value: string);
begin
  Cr.SubItem.FReportTitle := Value;
end;
{------------------------------------------------------------------------------}
{ Reference Method: Variable                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreports.PrintJob : Smallint;
begin
  Result := Cr.SubItem.FPrintJob;  {read-only}
end;
{------------------------------------------------------------------------------}
{ Reference Methods: Classes                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreports.Margins : TCrpeMargins;
begin
  Result := Cr.SubItem.FMargins;
end;
function TCrpeSubreports.Connect : TCrpeConnect;
begin
  Result := Cr.SubItem.FConnect;
end;
function TCrpeSubreports.LogOnInfo : TCrpeLogonInfo;
begin
  Result := Cr.SubItem.FLogOnInfo;
end;
function TCrpeSubreports.SectionFont : TCrpeSectionFont;
begin
  Result := Cr.SubItem.FSectionFont;
end;
function TCrpeSubreports.SectionFormat : TCrpeSectionFormat;
begin
  Result := Cr.SubItem.FSectionFormat;
end;
function TCrpeSubreports.SectionFormatFormulas : TCrpeSectionFormatFormulas;
begin
  Result := Cr.SubItem.FSectionFormatFormulas;
end;
function TCrpeSubreports.AreaFormat : TCrpeAreaFormat;
begin
  Result := Cr.SubItem.FAreaFormat;
end;
function TCrpeSubreports.AreaFormatFormulas : TCrpeAreaFormatFormulas;
begin
  Result := Cr.SubItem.FAreaFormatFormulas;
end;
function TCrpeSubreports.SectionHeight : TCrpeSectionHeight;
begin
  Result := Cr.SubItem.FSectionHeight;
end;
function TCrpeSubreports.Selection : TCrpeSelection;
begin
  Result := Cr.SubItem.FSelection;
end;
function TCrpeSubreports.GroupSelection : TCrpeGroupSelection;
begin
  Result := Cr.SubItem.FGroupSelection;
end;
function TCrpeSubreports.SortFields : TCrpeSortFields;
begin
  Result := Cr.SubItem.FSortFields;
end;
function TCrpeSubreports.GroupSortFields : TCrpeGroupSortFields;
begin
  Result := Cr.SubItem.FGroupSortFields;
end;
function TCrpeSubreports.GroupCondition : TCrpeGroupCondition;
begin
  Result := Cr.SubItem.FGroupCondition;
end;
function TCrpeSubreports.GroupOptions : TCrpeGroupOptions;
begin
  Result := Cr.SubItem.FGroupOptions;
end;
function TCrpeSubreports.SQL : TCrpeSQL;
begin
  Result := Cr.SubItem.FSQL;
end;
function TCrpeSubreports.Formulas : TCrpeFormulas;
begin
  Result := Cr.SubItem.FFormulas;
end;
function TCrpeSubreports.Tables : TCrpeTables;
begin
  Result := Cr.SubItem.FTables;
end;
function TCrpeSubreports.ParamFields : TCrpeParamFields;
begin
  Result := Cr.SubItem.FParamFields;
end;
function TCrpeSubreports.SessionInfo : TCrpeSessionInfo;
begin
  Result := Cr.SubItem.FSessionInfo;
end;
function TCrpeSubreports.GraphType : TCrpeGraphType;
begin
  Result := Cr.SubItem.FGraphType;
end;
function TCrpeSubreports.GraphText : TCrpeGraphText;
begin
  Result := Cr.SubItem.FGraphText;
end;
function TCrpeSubreports.GraphData : TCrpeGraphData;
begin
  Result := Cr.SubItem.FGraphData;
end;
function TCrpeSubreports.GraphOptions : TCrpeGraphOptions;
begin
  Result := Cr.SubItem.FGraphOptions;
end;
function TCrpeSubreports.GraphOptionInfo : TCrpeGraphOptionInfo;
begin
  Result := Cr.SubItem.FGraphOptionInfo;
end;
function TCrpeSubreports.GraphAxis : TCrpeGraphAxis;
begin
  Result := Cr.SubItem.FGraphAxis;
end;
function TCrpeSubreports.ReportOptions : TCrpeReportOptions;
begin
  Result := Cr.SubItem.FReportOptions;
end;


{******************************************************************************}
{ ECrpeEngine Class Definition                                                 }
{******************************************************************************}
constructor ECrpeError.Create(const nNo: Integer; const sMsg: string);
var
  s, sNo : string;
begin
  Str(nNo, sNo);
  s := 'Error:' + sNo + ' ' + sMsg;
  inherited Create(s);
  ErrorNo := nNo;
end; {ECrpeError}


{******************************************************************************}
{ TCrpeString Class Definition                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Member procedure Put                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeString.Put(Index: Integer; const S: string);
begin
  if (Index = Count) then     { OK to expand by one }
    Add(S)
  else
    inherited Put(Index, S);
end; { Put }


{******************************************************************************}
{ Class TLogOnInfoDlg                                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ FormShow procedure                                                           }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.FormShow(Sender: TObject);
var
  cnt    : integer;
  s1, s2 : string;
begin
  slServerName := TStringList.Create;
  slUserID     := TStringList.Create;
  slPassword   := TStringList.Create;
  slDatabaseName := TStringList.Create;
  for cnt := 0 to slLogInfo.Count - 1 do
  begin
    s1 := slLogInfo[cnt];
    s2 := GetToken(s1, ';;');
    slServerName.Add(s2);
    s2 := GetToken(s1, ';;');
    slUserID.Add(s2);
    s2 := GetToken(s1, ';;');
    slDatabaseName.Add(s2);
    slPassword.Add(s1);
  end;
  UpdateLogOn;
end;
{------------------------------------------------------------------------------}
{ UpdateLogOn procedure                                                        }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.UpdateLogOn;
var
  cnt : smallint;
begin
  {Clear and Enable/Disable controls}
  lbConnections.Clear;
  {Update list box}
  for cnt := 0 to (slLogInfo.Count - 1) do
    lbConnections.Items.Add(IntToStr(cnt + 1));
  lbConnections.ItemIndex := 0;
  lbConnectionsClick(self);
end;
{------------------------------------------------------------------------------}
{ lbConnectionsClick procedure                                                 }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.lbConnectionsClick(Sender: TObject);
var
  n : integer;
begin
  {Fill in controls}
  n := lbConnections.ItemIndex;
  editServerName.Text := slServerName[n];
  editUserID.Text := slUserID[n];
  editDatabaseName.Text := slDatabaseName[n];
  editPassword.Text := slPassword[n];
end;
{------------------------------------------------------------------------------}
{ editServerNameChange procedure                                               }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.editServerNameChange(Sender: TObject);
begin
  slServerName[lbConnections.ItemIndex] := editServerName.Text;
end;
{------------------------------------------------------------------------------}
{ editUserIDChange procedure                                                   }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.editUserIDChange(Sender: TObject);
begin
  slUserID[lbConnections.ItemIndex] := editUserID.Text;
end;
{------------------------------------------------------------------------------}
{ editPasswordChange procedure                                                 }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.editPasswordChange(Sender: TObject);
begin
  slPassword[lbConnections.ItemIndex] := editPassword.Text;
end;
{------------------------------------------------------------------------------}
{ editDatabaseNameChange procedure                                             }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.editDatabaseNameChange(Sender: TObject);
begin
  slDatabaseName[lbConnections.ItemIndex] := editDatabaseName.Text;
end;
{------------------------------------------------------------------------------}
{ btnOkClick procedure                                                         }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.btnOkClick(Sender: TObject);
var
  cnt : integer;
begin
  for cnt := 0 to slLogInfo.Count - 1 do
  begin
    slLogInfo[cnt] := slServerName[cnt] + ';;' +
      slUserID[cnt] + ';;' + slDatabaseName[cnt] + ';;' +
      slPassword[cnt];
  end;
end;
{------------------------------------------------------------------------------}
{ GetToken function                                                            }
{------------------------------------------------------------------------------}
function TLogOnInfoDlg.GetToken(var s: string; const sDelimiter: string): string;
var
  nPos, nOfs, nLen : Byte;
  sTmp             : string;

  function IsStrEmpty(const sValue: string): boolean;
  var
    sTmp : string;
  begin
    Result := True;
    sTmp := Trim(sValue);
    if Length(sTmp) > 0 then
      Result := False;
  end; { IsStrEmpty }

begin
  {Get the position of the Delimiter}
  nPos := Pos(sDelimiter, s);
  {Get the length of the Delimiter}
  nLen := Length(sDelimiter);
  nOfs := nLen - 1;
  if (IsStrEmpty(s)) or ((nPos = 0) and (Length(s) > 0)) then
  begin
    Result := s;
    s := '';
  end
  else
  begin
    sTmp := Copy(s, 1, nPos + nOfs);
    s := Copy(s, nPos + nLen, Length(s));
    Result := Copy(sTmp, 1, Length(sTmp) - nLen);
  end;
end; { GetToken }
{------------------------------------------------------------------------------}
{ FormClose procedure                                                          }
{------------------------------------------------------------------------------}
procedure TLogOnInfoDlg.FormClose(Sender: TObject;
  var Action: TCloseAction);
begin
  slServerName.Free;
  slUserID.Free;
  slPassword.Free;
  slDatabaseName.Free;
  Release;
end;



end.


